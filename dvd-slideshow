#!/bin/bash
#    dvd-slideshow
#    Copyright 2003 Scott Dylewski  <scott at dylewski.com>
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#

name='dvd-slideshow'
version='0.8.0-pre9'

echo "[dvd-slideshow]            dvd-slideshow $version"
echo "[dvd-slideshow]            Licensed under the GNU GPL"
echo "[dvd-slideshow]            Copyright 2003-2006 by Scott Dylewski"
echo "[dvd-slideshow]            "

## todo: (sorted by priority?)
# binary rendering engine for much better speed
# kenburns with rotation
# explain difference between Low/Medium/High quality modes
# fast preview mode for slcreator!
# add hints for smoothest kenburns effects. (no zoom and pan)
# do more complete error checking at start of script
# fix "audio" duration keyword in audio example

# test kenburns coorinates accuracy re: sq_pixel_multiplier

## known bugs:
# continuous subtitles don't work across non-image/transition lines
# bug when first line/slide has a subtitle but no others do?
#  convert image.jpg -bordercolor black -border 0 "$tmpdir/fade_$dj.ppm" works for transparent .png images
# in ImageMagick > 6.0.6, but not in 6.0.6 for some reason.  (black output).  

LANG=C

changes ()
{
echo 'Changes:
0.8.0	
    New features & Changes:	
	pre9:
	Allow multiple \n in titles (up to 4)
	Added variables subtitle_color, subtitle_outline_color, and subtitle_location
	Remove option for srt subtitles since we can force render them now.
	pre8:
	Use variable subtitle_type=render to force subtitles to be rendered in frames.
	Updated audio timing to be more accurate for long slideshows
	Added kenburns syntax for crop,kb,crop duration
	Wipe up/down works in addition to left/right now.
	pre7:
	Kenburns has smooth start and end now, but worse for very deep zooms.
	Add option to sharpen images (-sharpen) with ImageMagicks unsharp mask.
	*Now using ffmpeg to encode video.  Seems over 2x faster than mpeg2enc.
	.flv output [alpha] use -flv for now, but his might change
	Specify output size other than default with -s 320x240 (alpha)
	*Added -border option to add space between image and edge of screen.
	*Added "wipe" transition between frames:
	wipe:duration:subtitle:[right|left]  (soon up|down also)
	mp4/aac audio is possible with faad
	*Fadein/Fadeout/Crossfade to/from kenburns/scroll effects works now:
	( fades happen during movement of effect )
	 ***NOTE: The slideshow timings of fades will change with this version! 
	Adding .avi video inline is possible.  See docs.  [alpha]
	Initial theme support [beta]
	Widescreen (16:9) support using -w [alpha] Not tested yet.
	Improved font variables.
	kenburns effect is much smoother for slow effects in high-quality mode. (slower)
	Changed imagewidth and imageheight functions to only use:
	 imagewidth -format %w or -format %h for slight speed improvement.
    	Added -vcd and -svcd output options [beta] (lightly tested)
	Reformated progress indicators and output during fades.
	Inline audio processed as background job when specifiying -smp	
	General code cleanup including more function calls
	Audio fadein and fadeout times can be specified in decimals like 0.250
	Automatically sets smp option if the current kernel has "smp" in the name.
	Removed internal option for yuvcat
    Bug fixes: 	
	Escape brackets in [:blank:] (thanks Christian Moli√®re)
	Fixed mismatch in kenburns coordinates due to non-square pixels. (thanks Tony Sauri)
	Manual chapter markers fixed.
	Fixed reading of $HOME/.dvd-slideshowrc settings.
	Single or double quotes allowed in variable settings.
	Got rid of lsof debugging lines.  No longer needed.
	Fixed bug in seconds2ms that mishandled durations of 0.080 ms (thanks Eric)
	Remove wc --chars calls for compatibility with FreeBSD
	Remove seq calls for compatibility with FreeBSD
	Add FreeBSD font path so fonts are found.
0.7.5	
    New features & Changes:	
	Use "\n" to force line breaks up to two lines in title text (not titlebar yet).
	Fixed code to rotate images.  (not public yet)
	  Use image.jpg:duration:subtitle:[effect1:effect1_params:]rotate:angle
	Configuration variables will be read in sequence now.  So you can configure font
	  colors and sizes throughout the input file.
	Allow comments in all lines.  Everything after <space># will be ignored.
	Scroll effect is MUCH smoother for slow scrolls in high-quality mode! (takes 3x longer)
	Slideshow name -n is optional now.  Defaults to the base name of the input file.
        * Changed old "title" keyword to "titlebar:duration:toptitle:bottomtitle"
        * Added "title:duration:title_text" function where a single title is rendered in the middle of the screen.
	Add check for missing subtitle syntax in crop/scroll/kenburns.
	Longer progress bar.
	Reads ~/.dvd-slideshowrc in a loop for better debugging and security.
    Bug fixes: 	
	Added "+repage" in convert lines after cropping when using internal .mpc image format. 
	   ( Fixes kenburns and crop errors with ImageMagick > 6.2.2 )
	Fixed kenburns problems with black backgrounds. 
	Fixed "geometry does not contain image" problem with kenburns effect.
	Works for slide or transition duration > 35 seconds now.
	Add quotes around yuv fifo to allow for spaces in output directory.
	Fixed "squishing" when fading out or crossfading to a scroll effect. 
	Fixed problem where audio "fadein" was being rendered as a subtitle.
	Traps bad duration=0 for images and effects.
0.7.4	
    Bug fixes: 	
	Changed mpeg2enc process file descriptor from 55 to 3 for
	compatibility with bash >= 3.1 (fixes hang at wait for mpeg2enc to finish)
	Echos details to logfile about mpeg2enc process for future debugging.
	Output directory gets created if it does not exist.
	Fixed bug in kenburns positioning with black background.
	Better error messages when no oggdec or lame found.
	Fixed error where kenburns intermediate files were not being deleted.
0.7.3	
    New features:	
	Fixed kenburns zoom in adjusted to a "constant" velocity!  
	You can include other .txt files by using a line include:filename.txt in your input .txt file. Thanks Thomas Weber!
	User can manually add chapter markers by using the "chapter" keyword alone on one line of the input .txt file.
	Added variable "mpeg2enc_params" so advanced users can easily change the parameters.
	All timing accurate to 0.001 (1 ms) now.  
	Added -smp option to process faster on high-end machines. 
	Added -writechaps option to write out chapter markers to <slideshow_name>.chap
    Bug fixes: 	
	Fixed bugs causing errors when spaces were in paths.
	Fixed bugs in the audio processing: error on last audio file.
	Changed mpeg2enc -M 3 (use multiprocessors) to -M 0 because 1.8.0 was crashing on athlon 64 X2 machines.
	Added "-compose src-over" option to composite calls for compatibility with Debian Etch.
	Fixed bug when passing a single audio file longer than the slideshow.
	Removed rpm check for supporting applications.
	Checks for crossfade duration = 0 and handles it correctly.
	Checks that audio and image files exist while parsing .txt file.
	Fixed minor bug where an extra (non-existant) subtitle was rendered.
	Fixed bug when fading in to a first slide that is a scroll effect.
	Subtitle timing bug fixed!
	Small fix in displaying total number of pictures processed
	Better logging to logfile.
	Fixed ignored line if last line does not contain a line break.
0.7.2	
	Faster kenburns effect rendering when using black background.
	Allow multiple sequential audio files in input .txt file.
	Changed "head -1" to "head -n 1"
	Allow .png and .jpeg extensions.
	allow \n in subtitles to designate end-of line breakpoints
	Checks for required program version better now.
	Fixed ppmtoy4m compatibility error for compatibility with
	mjpegtools >= 1.6.3-0.1
	Allow "exit" keyword in .txt file (for easier debugging).
	Fixed pixel aspect ratio problem. (hopefully)
	Add option to render subtitles with spumux and .srt files (beta)
	Cleans up old temporary files if they exist.
	Better logfile output.  Hopefully catches program call errors.
	Title2 text and bar locations referenced to bottom of frame
	for better PAL/NTSC compatibility.
	Subtitle stays constant between slides if they both
	have the same subtitle (thanks Andre Weilert)	
	All temporary files are created in a temporary directory now.
	Fixed bug when fading in to a scroll effect. (remove tab at EOL).
	Changed progress indicator slightly.
0.7.1	
	Added log file output to dvd-slideshow.log
	Updated documentation and examples.
	Background color can now take a #RRGGBB value.
	Nicer progress indicator.
	AC3 audio is now the default.  Pass -mp2 to force MP2 audio.
	Autocrop works on background images now also.
	Added code to check for all temporary fade_xxxx.ppm images
	before proceeding to encode mpeg video.  
	Fadein or crossfade to a scroll effect works correctly now.
0.7.0	
	Default variables can be set in a ${HOME}/.dvd-slideshowrc file
	Default variables can be set in the input .txt file
	Crossfade and fadein to kenburns effect correctly fades
	 to the first frame geometry instead of the whole image.
	New keywords for the start and end points in kenburns effect:
	 topleft/middle/middleright etc.  See docs for details.
	New keywords for the crop function also.
	9999 audio files possible now. Used to be a limit of 9
	Fixed bug when fading in to a cropped image.
	Removed -R 2 and -c options in mpeg2enc because
	 some people had problems.
	Fixed subtitle timing bug, so now the subtitles appear
	 and disappear closer to the correct time.
	Changed encoded audio bitrate from 224kb/s to 128kb/s
	Works with toolame 0.2m beta and 0.2L now
        Got rid of calls to NetPBM functions, so it is no longer required...
	Changed "wc -m" call to "wc --chars" for better compatibility.
	Fixed syntax so spaces should be allowed in input files now.
	Changed "seq 2 1" to "seq 2 -1 1" for better compatibility
	Added option to "autocrop" images (-c) that are close to the
		output aspect ratio, but not quite.
	Title syntax changed... (see documentation)
	Fadein/crossfade to a title or background slide works now.
	Fadein/fadeout/crossfade works when previous/next slide is not
	 actually an image/title/background. The next real slide will
	 be used instead.
	Fixed bug in Low quality mode (-L) (extracopies bug)
	Fixed bug with subtitles with new versions of imagemagick.
	White can be used a a background keyword for white backgrounds.

0.6.0	
	Fixed major bug/error when generating long slideshows. 
		Now all video gets piped in YUV fomat through mpeg2enc
		in one single block. (fix by Mike Beller)
	Added option to generate AC3 audio files (requires ffmpeg)
	Fixed title slide when using -L (low quality mode)	
	Allow for slide durations to be specified in hundreths of a second: 5.23
	Reports total audio and video lengths at the beginning of the code.
	Fixed bug when using subtitles. (no subtitles were generated)
	Changed output files to be .vob extension instead of .mpg	
	Better font searching (thanks Jim Crumley)
	Use backslash to escape a colon in subtitles (thanks Jim Crumley)
	Allow avi input files.  pre-alpha support.  (thanks Jim Crumley)
0.5.4	
	Added option to re-define background image from text file input.
	Code cleanup (slightly)
	Added support for two audio tracks.  
	Added audio effects:  fadein/fadeout	
	Default command-line audio fadein/fadeout time is 3 seconds.
0.5.2	
	Fixed bug in musictitle Title info parsing.
	Checks to make sure a slidshow name is passed.
	Added low-quality mode (-L) for testing.  Speeds things up about 4x.
	Reduced verbosity.
	Checks for required fonts. Subtitles look much better now.
	Word-wraps long subtitle lines into two lines.
0.5.0	
	Added KenBurns effect!  See docs for usage.
	Added scroll effect!  See docs for usage.
	Added crop effect.  See docs for usage.
	Audio can be started and stoped for multiple files within
		the text file.  See docs for usage.
	Added "musictitle" option for displaying audio info.
	You can now comment out lines in the textfile by using the # character.
	Also ignores blank lines in textfile.
	Fades can now have up to 9999 frames.
	Total slides can now be 9999.  You guys are crazy.
	fixed small bug when no chapters are specified.
	Chapter markers are now rounded up to the next full second due to
		a bug in some versions of dvdauthor.
	Only checks for oggdec or lame if you pass an ogg or mp3 file.
	Changed syntax of command line input for files and audio.
	Passing images on the command line is no longer "public". 
		Use the text file in put instead.
	Fixed audio problem with some mp3 files getting pops in them.
0.4.8   
	Changed audio to process raw (headerless) audio files before 
		joining them.
        Fixed bug when passing multiple audio files (again).
        Fixed audio fadein/fadeout time to 1 second
        Fixed bug in audio where it plays to fast when burned on dvd.
        Checks to make sure audio files exist before processing.
0.4.6	Fixed bug when passing multiple audio files. (thanks Scott Merrill)
	Removed -t option from toolame command for better support for old versions.
0.4.4	Only writes chapter markers when there is a picture or title
	First chapter marker is now fixed at time 0
	Max number of chapter markers is now 99 (thanks Jens Gecius)
	Fixed bug when checking for toolame (thanks Jens Gecius)
	Added "crossfade" option!
	Will use mpeg3cat from libmpeg3 to join mpegs if available.
	Small fix to allow semicolons in subtitles (thanks Jim Crumley)
	Added -s option to mpeg2enc calls for (maybe?) better compatibility.
0.4.2	Current working directory will be used if -o not specified.
	Allow "background" keyword in text file to insert background.
	Make sure all ImageMagick calls have -depth 8 to make ppmtoy4m happy.
	No font is specified in ImageMagick calls, so it should use the default.
	Changed default menu to a steelblue gradient when no image is passed.
0.4	Fixed bug when no background specified (again).
	Added error checking to make sure image files exist.
	Ogg audio format supported (you must have oggdec).
	Uses toolame for mp2 audio encoding when available.
	Audio timing improved.
	Fixed bug when double-quotes were in subtitle.
	Added black, fadein, and fadeout options in txtfile!
	-p  (PAL format option) added. Not tested, but should work.
0.3	Fixed error when no background specified.  Now default is black
	Added checking for required programs before running.
0.2	Initial release'
}

help ()
{
echo "`basename $0` Version $version "
echo 'http://dvd-slideshow.sourceforge.net'
echo 'Copyright 2003-2006 Scott Dylewski <scott at dylewski.com>'
echo 	 
echo 'Description: 
	Creates a dvd-compatible mpeg2 video from a bunch of images.
	You can add music if you want also. Supports several effects
	like fadein/fadeout/crossfade/crop/kenburns.  

Usage:
 dvd-slideshow [-n <slideshow_name>] [-o <output_directory>] [-b <background_jpeg>] 
  [-a <audio_file1> -a <audio_file2> ... -a <audio_fileN>] 
  [-p] [-L | -H] [-mp2] [-r] [-smp] [-theme <themefile>] -f input_file.txt
	
Options: 
 [-n slideshow_name]
	  The program uses this
	  string as the filename base for the output files
	  so you can distinguish it from other slideshows
	  that you can send to the same output directory.

 [-o <outupt directory>]
	  Directory where the final .vob and dvdauthor .xml files
	  will be written.  Default is to write in the directory
	  where dvd-slideshow was run.
 		
 [-b <background jpeg>]
	  Image to use for the background of the slideshow.
	  All of the pictures will be
	  overlaid on top of this background image. If no file 
	  is specified, black will be used for the slideshow
	  and a blue gradient for the title slide.
	  
 [-a <audio file>]
          Audio file to play in background during the slideshow.
          It will be faded out at the end.  Supports mp3, ogg, 
	  aac, mp4, or wav formats at this point.
	  Multiple files will be joined.
	  See also the more flexible text file input method.
	  To pass multiple files, use the -a switch again.

 [-mp2]
	Use MP2 audio instead of AC3.
	Default audio format is now AC3 because it seems to be more
	compatible with the DVD hardware players.

 [-p]
	Use PAL output video format instead of NTSC

 [-L]
	Render a low-quality video suitable for debugging.
	This sets the resolution to 1/2 of full resolution and
	decreases the quality of fades/transitions.

 [-H]
	(Beta) Render a higher-quality video.  
	This uses the default dvd resolution and keeps all other output
	parameters the same, but enables some pixel-sampling methods
	that make the scroll effect look better at very slow velocities.
	This will make dvd-slideshow take up to 4x longer to process the
	scroll effect. Only applied when needed; the output will explain. 

 [-theme <themefile>]
 	Use the given theme when setting variables/colors/etc.

 [-border N]
 	Make a border of N pixels around each image.  

 [-sharpen]
 	Sharpen images

 [-r]
 	Autocrop horizontal images to fill the full size of the screen.

 [-w]   Alpha! 
 	Render widescreen output (16:9) instead of standard (4:3) 
	Please send bug reports to scott at dylewski dot com

 [-smp]
 	Enable more processes to run at the same time for multiprocessor
	machines.  Basically, this just renders each frame of a transition
	in the background at the same time, and then waits for them to be finished.
	Use this at your own risk on slower machines! If you do not have enough
	memory to hold all the frames for one "crossfade" or "kenburns" effect,
	then linux starts swapping to disk, and your machine may seem to lock
	up for a while.  USE THIS AT YOUR OWN RISK!

 [-nocleanup]
 	Leave temporary files in the temporary directory.  Useful for debugging.

 -h or -help 
   Prints this help. 

 -v or -version 
   Prints dvd-slideshow version number. 

 -f input_file.txt
          File to specify all the parameters and order easily
          for bigger slideshows. It uses the ':' character as a 
	  separator for the fields:
          [image.jpg|keyword]:duration:subtitle:effect:effect_params
          with each line being separate.  File options
          will override the ones passed on the command line.

	  NOTE: the effect parameters are separated by a semicolon ;
	  instead of a colon :

	  You can escape a colon with a backslash in subtitle text.

	  Durations can be specified in seconds with
	  up to three decimal points, like 5.583 seconds.

	  Keywords:
            title:duration:Title_text
                makes a title slide. Text is centered on the screen.
            titlebar:duration:Upper_Title:Lower_Title
                makes a title slide.  Upper and lower titles are
                optional; if one is missing, only the other will
                be displayed. White bands are underlayed behind
                the text.
	    musictitle:duration:subtitle:Title;Artist;Album
	   	makes a black frame with the song info 
		printed in the bottom left corner.
	    background:duration:subtitle:image 
	    	makes a slide with the current background 
		or it resets the current background image to a new one:
		"background:2:"  will display the current background
		for 2 seconds. 
		"background:2::image.jpg"  will set the background to
		image.jpg and also display it for 2 seconds.
		"background:0::image.jpg"  will set the background to 
		image.jpg, but will not use it until the next picture. 
		"black" or "white" can be used instead of an image 
		name to display a black or white background.
		You can also use a hex RGB code as the background color.

	    fadein:duration:subtitle
	    	fades in to the next slide
	    fadeout:duration:subtitle
	    	fades out to the background
	    crossfade:duration:subtitle
	    	fades from one picture to the next.
	    wipe:duration:subtitle:[up|down|left|right]
	    	wipes from one picture to the next.

	    chapter
	  	Force manual chapter marker timing.  Chapter markers will
	  	only be created where the "chapter" keyword occurs.
		The default is to add chapter markers at every slide.
	    include:includefile.txt
	  	Other input files can be included in the input .txt file.
	  	The file includefile.txt will be concatenated in the
	  	place where the line occurs.
		Useful for setting up a bunch of variables, fonts, etc
		and then just including one standard file at the start of
		your input .txt file.
	    exit
		Stops the slideshow at the current point as if the input
		.txt file ended at this point. Useful for debugging.

	  Effects:
	    Effects are only used with images, not keywords.
	    In the following effects, x0,y0 represents the
	    top left corner of a defined box, and x1,y1 is
	    the bottom right corner. 
	    NOTE: the effect parameters are separated by a
	    semicolon ; instead of a colon :
            crop:
	    	image.jpg:dur:sub:crop:x0,y0;x1,y1
		Crops the image about the coordinates specified.
		Full box description:
	    	  x0,y0;x1,y1
		  Specifies the top-left(0) and bottom-right(1) points.
		Keyword description:
		  frame_size;frame_location
		  where frame_size indicates the fraction of the final 
		  dvd window width/height, and frame_location refers
		  to the CENTER POINT of the picture,
		  and can be any of the following keywords:
		 	topleft		top		topright
			left		middle		right
			bottomleft	bottom		bottomright
		   or
		 	x%,y%
			where % is a percentage of the window width,height
			starting from the top left corner of the dvd window.
		   or
		 	imagewidth | imageheight
			where the image width or height will be scaled to 
			fill the full width or height of the dvd screen.
		Crop examples:
	    	image.jpg:dur:sub:crop:651,390;1134,759
		image.jpg:dur:sub:crop:30%;60%,60%
		image.jpg:dur:sub:crop:50%;topleft
		image.jpg:dur:sub:crop:imageheight;left
	    kenburns:
	    	image.jpg:dur:sub:kenburns:start_box;end_box
		The kenburns effect will crop/zoom from the start
		to the end box.
	    	Where now we have start and end boxes, defined in
		the same way as in the "crop" function, but now
		we have two boxes defined.
		Full box description:
	    	  xs0,ys0;xs1,ys1;xe0,ye0;xe1,ye1
		  Specifies the top-left(0) and bottom-right(1) points.
		Keyword description:
		  start 0%-100%;start_location;end 0%-100%;end_location
		Kenburns examples:
	    	image.jpg:dur:sub:kenburns:651,390;1134,759;372,330;1365,1089
		image.jpg:dur:sub:kenburns:30%;60%,60%;75%;40%,50%
		image.jpg:dur:sub:kenburns:50%;topleft;50%;bottomright
		image.jpg:dur:sub:kenburns:100%;left;0,0;720,480
		image.jpg:dur:sub:kenburns:100%;left;imageheight;left
		kenburns note:  if you find yourself using a lot of lines like:
		crop, kenburns, crop
		where the crop coordinates are the same as the start & end
		of the kenburns, you can use a duration like 1,5,1 for one
		second of crop, followed by a 5 second kenburns, followed by
		another one second of crop (times are adjustable).  (alpha)
	    scroll:
	    	image.jpg:dur:sub:scroll:[left|right|up|down]
		This is most useful for displaying panorama-style
		pictures that are much wider than they are tall.
		This will automatically resize the picture so that
		the image height is equal to the video display 
		height (480) before scrolling (or conversely for tall
		images).

	    The subtitle field is optional, but if you are passing
	    effects after the subtitle field, be sure to include 
	    all the colons :: in order for the parser to get the
	    correct info.
	    Two subtitle tracks are possible (alpha).  Separate them
	    using a semicolon ;. 

	    When passing a picture, you can optionally use the
	    keyword "audio" instead of the integer duration in 
	    seconds.  What this does is force the duration of
	    that image to be the length of the previous audio 
	    track.  This is useful for making a music video dvd.

	  Audio:
	    Audio tracks can be inter-mixed with the video.  If 
	    an audio track is placed between two different images,
	    that audio track will begin playing at the start of the
	    second image.  When placing audio, use the syntax:

            audiofile:track:effect1:effect1_params:effect2:effect2_params

	    The audiofile can be an ogg, mp3, aac/mp4 or wav file.
	    Track is the resulting dvd audio track.
	    Effects are audio effects where
	    you can specify things like fadein/fadeout
	    for the audio.  Example:
            audiofile.ogg:1:fadein:3:fadeout:2

	    If you want to concatenate two audio files, just place them
	    one right after another.  

	  Video: [alpha]
	    You can add video (.avi only) files and either use 
	    the audio from the video or ignore it and use your own
	    from the slideshow:
	   
	    To just play the video in the middle of a slieshow, use:
	    videofile.avi
	    To ignore the audio from the video, and use your own, use:
	    videofile.avi:noaudio
	    To use the audio in the video but fade it in or out, use:
	    videofile.avi::fadein:1:fadeout:2

	Configuration file and variables:
	  You can configure some of the variables and settings
	  that control dvd-slideshow through keywords in the input
	  .txt file or through a ~/.dvd-slideshowrc file.  The heirarchy
	  is as follows: 
	  program defaults --> ~/.dvd-slideshowrc --> theme settings --> command-line --> input file variables
	  So the input file will over-ride your personal settings, etc.
	  The following variable are supported (with this syntax):
	   
	  debug=1       # 0 (low=default), 1 (some debug info), 2 (per frame info), 3 (function info)
	  pal=0  	# 0=ntsc 1=pal
	  ac3=1         # 0=mp2 audio 1=ac3 audio
	  copy=0        # add copies of original images to the output directory
	  autocrop=1    # autocrop images to fill full screen
  	  high_quality=0	# set high-quality mode
	  border=0	# change to number of pixels around the image that is filled in with background
	  sharpen=0	# change to 1 to enable image sharpening

#	  font_dir="/usr/share/fonts"
#	  font_name='n019004l.pfb' # helvetica bold URW font is default
	  font=/usr/share/fonts/default/Type1/n019004l.pfb # Helvetical bold URW font
#	  font=/usr/share/fonts/default/Type1/n0190241.pfb # Helvetical bold oblique
#	  font=/usr/share/fonts/default/Type1/a0100151.pfb # AvantGarde DemiBold
#	  font=/usr/share/fonts/default/Type1/n0220041.pfb # Courier Bold

	  ## Subtitle:
	  subtitle_type="dvd"  # use "render" to force rendering of text.
	  subtitle_font_size=24
	  subtitle_color="white"
	  subtitle_outline_color="black"
	  subtitle_location="bottom"

	  ## Title:
	  title_font_size=48
	  title_font_color="black"  # or use hex "#RRGGBB"

	  ## top title:
	  toptitle_font_size=48
	  toptitle_font_color="black"  # or use hex "#RRGGBB"
	  toptitle_bar_height=125  # 0 for no 50% white behind text
	  toptitle_text_location_x=80
	  toptitle_text_location_y=50

	  # bottom title: 
	  bottomtitle_font_size=36
	  bottomtitle_font_color="black"  # or use hex "#RRGGBB"
	  bottomtitle_bar_location_y=156 # relative to bottom of image
	  bottomtitle_bar_height=55  # 0 for no 50% white behind text
	  bottomtitle_text_location_x=0
	  bottomtitle_text_location_y=155
	  
	  # kenburns:
	  kenburns_acceleration=1 # in seconds, or:
	  kenburns_acceleration=25%  # as a percentage of the total kenburns effect time
'
	echo '  '
}

if [ $# -lt 1 ]; then
	echo "[dvd-slideshow] ERROR: Too few arguments"
	help
	exit 1
fi


###################################################################
# Default variables
# order of perference:  
# program defaults --> ~.dvd-slideshowrc --> command-line args --> .txtfile settings

## setup program default variables (user configurable)
debug=0 # 0-2
pal=0  
copy=0
low_quality=0
#medium_quality=0  #default
high_quality=0
autocrop=0
ac3=1
widescreen=0
border=0  
sharpen=''
#subtitle_type="render"	# force subtitles to be rendered as graphics on the images.
subtitle_type="dvd"	# or, use empty for default.
font_dir="/usr/share/fonts/"
font_dir2="/usr/X11R6/lib/X11/fonts/"
font_dir3="/usr/local/share/fonts/"
default_fontname1='n019004l.pfb' # helvetica bold URW fonts
default_fontname2='helb____.ttf' # helvetica bold truetype
	  ## Subtitle:
	  subtitle_font_size=24
	  subtitle_color="white"
	  subtitle_outline_color="black"
	  subtitle_location="bottom" # or "top"

	  ## Title:
	  title_font_size=48
	  title_font_color='black'  # or use hex "#RRGGBB"

	  ## top title:
	  toptitle_font_size=48
	  toptitle_font_color='black' # or use hex "#RRGGBB"
	  toptitle_bar_height=125  # 0 for no 50% white behind text
	  toptitle_text_location_x=80
	  toptitle_text_location_y=50

	  # bottom title: 
	  bottomtitle_font_size=36
	  bottomtitle_font_color="black"  # or use hex "#RRGGBB"
	  bottomtitle_bar_location_y=156 # relative to bottom of image
	  bottomtitle_bar_height=55  # 0 for no 50% white behind text
	  bottomtitle_text_location_x=0
	  bottomtitle_text_location_y=155

logfile='dvd-slideshow.log'
themedir='/home/scott/bin/dvd_project/themes'

##################################################################################
## not user configurable:
verbosity=0  # for mpeg2enc and such
slideshow_name=""
titletext=""
i_audio=0
j_audio=0
write_chap=0
subtitle_number=0
n=0
m=0
browse_num=0
submenu=0
write_chaps=0
chapmenu=0
browsable=0
yuvpid=0                    # pid of child mpeg2enc process
yuvfirstfile=1              # tells when to strip yuv headers
write_last_subtitle=0
write_last_subtitle2=0
commandline_audiofiles=0
nocleanup=0 
function_error=0
vcd=0; svcd=0
print_themes=0

mpeg_encoder='ffmpeg' # or mpeg2enc.  I find ffmpeg 2x faster than mpeg2enc
#mpeg_encoder='mpeg2enc' # or mpeg2enc.  I find ffmpeg 2x faster than mpeg2enc
output_format='mpeg2' # or flv, mp4, mp4_ipod.  mpeg2 is default
#output_format='flv' # or flv, mp4, mp4_ipod

# set smp option based on kernel name:
if [ -z "`uname -a | grep -i smp`" ] ; then
	smp=0
else
	smp=1
fi

kenburns_acceleration=2 # in seconds

theargs="$*"
## command-line settings:
for arg
do
	case "$arg" in
	## config variables:
	-p) shift; commandline_pal=1 ;;  # use pal format
	-r) shift; commandline_autocrop=1 ;;  # autocrop landscape-oriented images
	-C) shift; commandline_copy=1 ;;  # make backup copy of all pictures passed. 
	-mp2) shift; commandline_ac3=0 ;;  # use mp2 audio
	-ac3) shift; commandline_ac3=1 ;;  # use ac3 audio
	-V) shift; commandline_debug="$1"; shift ;;
	## non-config variables:
	-i) shift; image[$n]="$1"; let n=$n+1; shift;;
	-o) shift; outdir="${1%%/}"; shift ;; # ${1%%/} omits trailing slash from outdir
	-b) shift; bgfile="$1"; shift ;;
	-theme) shift; commandline_theme="$1"; shift ;;
	-themes) shift; print_themes=1 ; shift ;;  # print available themes
	-n) shift; slideshow_name="$1"; shift ;;
	-t) shift; time_per_picture="$1"; shift ;;  ## in tenths or hundredths of seconds?
	-f) shift; input_txtfile="$1"; shift
                if [ ! -f "$input_txtfile" ] ; then
                echo "[dvd-slideshow] ERROR: Input file $input_txtfile does not exist."
                exit 1
                fi ;;
	-border) shift; commandline_border="$1" ; shift ;;  # add border around image [in pixels]
	-sharpen) commandline_sharpen="1" ; shift ;;  # Sharpen image
	-s) shift; commandline_output_size="$1" ; shift ;;  # output size (over-rides defaults).  use something like 320x240
	-F) shift; commandline_output_framerate="$1" ; shift ;;  # output framerate (over-rides defaults). use 15 or 10 or 20 (integers only now)  # DO NOT USE
	-writechaps) shift; write_chaps=1 ;;  # Write out chapter times to $slideshow_name.chap
#	-c) shift; chapmenu=1 ; submenu=1 ;;  # create a chapter select sub-menu (implies submenu)
#	-B) shift; browsable=1 ; submenu=1 ;;  # create a browsable slideshow (not working)
	-vcd) shift; vcd=1 ;;  # use vcd resolution and mp1 audio
	-svcd) shift; svcd=1 ;;  # use svcd resolution and mp1 audio
	-mpeg2enc) shift; mpeg_encoder='mpeg2enc' ;; # force using mpeg2enc instead of ffmpeg
	-flv) shift; output_format='flv' ;; # force using mpeg2enc instead of ffmpeg
	-swf) shift; output_format='swf' ;; # force using mpeg2enc instead of ffmpeg
	-w) shift; widescreen=1 ;;  # use 16:9 instead of 4:3 aspect ratio
	-L) shift; low_quality=1 ;;  # use low-quality mode
	-M) shift; commandline_high_quality=0 ; low_quality=0 ;;  # use medium-quality mode (this is the default)
	-H) shift; commandline_high_quality=1 ;;  # ALPHA.  use high-quality mode (This might take much longer to process in the future)
	-smp) shift; smp=1 ;;  # use multi-threaded mode (might crash on low-memory machines?)
	-nosmp) shift; smp=0 ;;  # use multi-threaded mode (might crash on low-memory machines?)
	-nocleanup) shift; nocleanup=1 ;;  # leave all temp files
	-a) shift; 
                # make sure the file exists and is the correct type!
                suffix=`echo "$1" | awk -F. '{print tolower($NF)}'`
                if [ "$suffix" == 'ogg' ] || [ "$suffix" == 'mp3' ] || [ "$suffix" == 'wav' ] || [ "$suffix" == 'm4a' ] || [ "$suffix" == 'aac' ] ; then
                	if [ ! -f "$1" ] ; then
                       	 echo "[dvd-slideshow] ERROR: File $1 does not exist"
                         exit 1
                        fi
                        passed_audio[$m]="$1"
                        let m=$m+1
			commandline_audiofiles=$(( $commandline_audiofiles + 1 ))
                        shift;
                else
                       	 echo "[dvd-slideshow] ERROR: File $1 is not an ogg, mp3, m4a, aac, or wav file."
                         exit 1
                fi ;;
	-h) help ; exit 0 ; shift ;;
	-?) help ; exit 0 ; shift ;;
	-help) help ; exit 0 ; shift ;;
	-version) echo "$version" ; exit 0 ; shift ;;
	esac
done

##################################################################
### no more user input after this line?

###################################################################
## Functions:

myecho ()
{
	## use this version of echo to write to screen and to the logfile:
	echo "$*"
	echo "$*" >> "$outdir/$logfile"
}

logecho ()
{
	## use this version of echo to write to the logfile:
	echo "$*" >> "$outdir/$logfile"
}

myechon ()
{
	## use this version of echo to write to screen and to the logfile:
	echo -n "$*"
	echo -n "$*" >> "$outdir/$logfile"
}


## check_rm checks to see if the file exists before it's deleted:
check_rm ()
{
	if [ -f "$1" ] ; then
		rm "$1"
	fi
}

cleanup ()
{
if [ "$nocleanup" -eq 0 ] ; then
	## clean up temporary files
	myecho "[dvd-slideshow] cleanup..."
	check_rm temp_slideshow_image.ppm ; check_rm temp.ppm
	check_rm temp_slideshow_image_scaled.ppm
	check_rm "$tmpdir/slideshow_background.ppm"
	check_rm "$tmpdir/slideshow_background.mpc"
	check_rm "$tmpdir/slideshow_background.cache"
	check_rm "$tmpdir/title_background.png"
	check_rm "$tmpdir"/"$slideshow_name".spumux
	check_rm "$tmpdir/trash.txt"
	check_rm "$tmpdir/browse.spumux"
	check_rm "$tmpdir/$subtitle_file"
	check_rm "$tmpdir/subtitle.png"
	check_rm "$tmpdir/dvd_title.png"; check_rm "$tmpdir/dvd_title_2.png"
	check_rm "$tmpdir/video.mpg"
	check_rm "$tmpdir/video_0.mpg"
	check_rm "$tmpdir/audio1.mp2"; check_rm "$tmpdir/audio2.mp2"
	check_rm "$tmpdir/audio1.wav"; check_rm "$tmpdir/audio2.wav"
	check_rm "$tmpdir/audio.raw"; check_rm "$tmpdir/audio_new.raw"
	check_rm "$tmpdir/box.png"
	check_rm "$tmpdir/up_arrow.png"; check_rm "$tmpdir/left_arrow.png"; check_rm "$tmpdir/right_arrow.png"
	check_rm "$tmpdir/up_arrow_mask.png"; check_rm "$tmpdir/left_arrow_mask.png"; check_rm "$tmpdir/right_arrow_mask.png"
	check_rm "$tmpdir/menu_ur.png"; check_rm "$tmpdir/menu_lur.png"; check_rm "$tmpdir/menu_lu.png"
	check_rm "$tmpdir/menu_mask_ur.png"; check_rm "$tmpdir/menu_mask_lur.png"; check_rm "$tmpdir/menu_mask_lu.png"
	check_rm "$tmpdir/temp.png"; check_rm "$tmpdir/temp2.png"
	check_rm "$tmpdir/audio1.ac3"; check_rm "$tmpdir/audio2.ac3"
	check_rm "$tmpdir/temp_slideshow_image.png"
	check_rm "$tmpdir/temp_slideshow_image.mpc"
	check_rm "$tmpdir/temp_slideshow_image.cache"
	check_rm "$tmpdir/temp_slideshow_image_scaled.jpg"
	check_rm "$tmpdir/temp_slideshow_image_scaled.mpc"
	check_rm "$tmpdir/temp_slideshow_image_scaled.cache"
	check_rm "$tmpdir/title.ppm"
	check_rm "$tmpdir/temp.ppm"
	check_rm "$tmpdir/title1.ppm"
	check_rm "$tmpdir/kenburns_????.mpc" 
	check_rm "$tmpdir/kenburns_????.cache"
	check_rm "$outdir/$tmptxtfile"
	k=0
	dk=0
	for file in "${image[@]}"; do
 		[ $k -lt 1000 ] && dk="0$k" || dk=$k
 		[ $k -lt 100 ] && dk="00$k" || dk=$dk
 		[ $k -lt 10 ] && dk="000$k" || dk=$dk
		check_rm "$tmpdir/fade_$dk.ppm"
		check_rm "$tmpdir/audio1_$dk.wav"
		check_rm "$tmpdir/audio1_$dk.raw"
		check_rm "$tmpdir/audio2_$dk.wav"
		check_rm "$tmpdir/audio2_$dk.raw"
		check_rm "$tmpdir/slide_$k.ppm"
		check_rm "$tmpdir/slide_$k"_thumb.ppm
		check_rm "$tmpdir/slide_nav_$dk".ppm
		check_rm "$tmpdir/slide_$dk.mpg"
		check_rm "$tmpdir/subtitle_$k.png"
		check_rm "$tmpdir/slide_$k.mpc"
		check_rm "$tmpdir/slide_$k.cache"
		let k=$k+1
	done
	# close pipe to mpeg2enc
        exec 3>&-  
        check_rm "$tmpdir/$yuvfifo"
        if [ "$yuvpid" -ne 0 ]; then
        	kill -TERM $yuvpid
        fi
	## that should be everything.  Now try deleting tempdir:
	rm -r "$tmpdir"
fi
}

forcequit () ## function gets run when we have some sort of forcequit...
{
	## clean up temporary files
	cleanup
	exit
}

trap 'forcequit' INT
trap 'forcequit' KILL
trap 'forcequit' TERM

## check for the necessary programs:
checkforprog ()
{
        it=`which $1 2> /dev/null`
        if [ -z "$it" ] ; then
                myecho "[dvd-slideshow] ERROR: $1 not found! "
                myecho "[dvd-slideshow] Check the dependencies and make sure everything is installed."
                exit 1
        fi
}

checkfor_oggdec ()
{
        it=`which oggdec 2> /dev/null`
        if [ -z "$it" ] ; then
                myecho "[dvd-slideshow] ERROR: oggdec not found! "
                myecho "[dvd-slideshow] You need to download the vorbis-tools package"
		myecho "[dvd-slideshow] in order to use .ogg audio files."
                exit 1
        fi
}

checkfor_lame ()
{
        it=`which lame 2> /dev/null`
        if [ -z "$it" ] ; then
                myecho "[dvd-slideshow] ERROR: lame not found! "
                myecho "[dvd-slideshow] You need to download the lame package"
		myecho "[dvd-slideshow] in order to use .mp3 audio files."
                exit 1
        fi
}

checkfor_faad ()
{
        it=`which faad 2> /dev/null`
        if [ -z "$it" ] ; then
                myecho "[dvd-slideshow] ERROR: faad not found! "
                myecho "[dvd-slideshow] You need to download the faad package"
		myecho "[dvd-slideshow] in order to use .m4a audio files."
                exit 1
        fi
}


rpmversion ()
{
	if [ -z `which rpm 2> /dev/null` ] ; then
		ver=''
	else
		ver=`rpm -q $1`
	fi
	if [ "`echo $ver | awk -F- '{print $1}'`" == "$1" ] ; then
		# rpm returned version of program
		vers=`echo $ver | awk -F- '{print $2}'`
#		echo "[dvd-slideshow] Found $1 version $vers"
	else
		# no rpm, try other methods
		vers=0  # no version found (yet)	
#		echo "[dvd-slideshow] Found $1"
	fi
	echo "$vers"  # returns 0 if no version found, but executable exists
}

hms ()  # HMS
{
	## pass a number in thousandths of seconds and get back a 
	## time code of the form HR:MM:SS.XXX
	if [ -z "$1" ] ; then
		myecho "[dvd-slideshow] Error in hms function"	
		function_error=1
	else
		hours=$(( $1 / 3600000 )) ; [ $hours -eq 0 ] && hours="0" 
		it=$(( $1 - $hours * 3600000 ))
		minutes=$(( $it / 60000 )) ; [ $minutes -eq 0 ] && minutes="0" 
		it=$(( $1 - $minutes * 60000 ))
		seconds=$(( $it / 1000 )) ; [ $seconds -eq 0 ] && seconds="0" 
		thousandths_out=$( printf %3.3d $(( $it - $seconds * 1000 )) );
#		characters=`echo "$thousandths" | wc --chars`
#		characters=${#thousandths}
#		if [ $characters -eq 1 ] ; then
#			thousandths_out="000"  # empty string!
#		elif [ $characters -eq 2 ] ; then
#			thousandths_out="00$thousandths"  # 1 decimal place
#		elif [ $characters -eq 3 ] ; then
#			thousandths_out="0$thousandths"  # 2 decimal places
#		elif [ $characters -eq 4 ] ; then
#			thousandths_out="$thousandths"  # 3 decimal places
#		else
#			myecho "[dvd-slideshow] Error in hms function"	
#			function_error=1
#		fi
		it="$hours:$minutes:$seconds.$thousandths_out"
		echo "${it}"
	fi
}

hms2seconds ()
{
	## pass a number in H:MM:SS.xxx and get back number of seconds
	if [ -z "$1" ] ; then
		echo ''
	else
		hours=`echo $1 | cut -d: -f1`
		minutes=`echo $1 | cut -d: -f2`
		seconds=`echo $1 | cut -d: -f3 | cut -d. -f1`
		fraction=`echo $1 | cut -d: -f3 | cut -d. -f2`
#		characters=`echo "$fraction" | wc --chars`
		characters=${#fraction}
		if [ "$characters" -eq 1 ] ; then ## no decimal was specified
			duration_ms="0"
		elif [ "$characters" -eq 2 ] ; then ## 1 decimal was specified
			duration_ms="$fraction"00
		elif [ "$characters" -eq 3 ] ; then ## 2 decimal was specified
			duration_ms="$fraction"0
		elif [ "$characters" -eq 4 ] ; then ## 3 decimal was specified. 
			duration_ms="$fraction"
		else
			echo "[dvd-slideshow] ERROR: Duration string $1 is bad."
			echo "[dvd-slideshow] 	Probably too many decimal places.  "
			echo '[dvd-slideshow]   There is no point specifying 0.0001 seconds."'
			# try rounding to only 3 decimal places?	
			function_error=1
		fi
		it=$(( $seconds + $minutes * 60 + $hours * 3600 ))
		## round up thousandths?
		echo "$it"."$duration_ms"
	fi
}


max ()
{
	## get the max of the arguments
	last_number=0
	for number
	do
		if [ "$number" -gt "$last_number" ] ; then
			last_number="$number"
		fi
	done
	echo "$last_number"
}

min ()
{
	## get the min of the arguments
	last_number=10000000000000000
	for number
	do
		if [ "$number" -lt "$last_number" ] ; then
			last_number="$number"
		fi
	done
	echo "$last_number"
}

addzeros ()
{
			[ $1 -lt 1000 ] && dj2="0$1" || dj2=$1
			[ $1 -lt 100 ] && dj2="00$1" || dj2=$dj2
			[ $1 -lt 10 ] && dj2="000$1" || dj2=$dj2
			echo "$dj2"
}

# strip every yuv file except the first
yuvstrip ()
{
       read junk
       cat
       return 0
}


encode_video ()
{
if [ "$yuvfirstfile" -eq 1 ]; then
	yuvfirstfile=0
	ffmpeg -i "$1" -y -aspect $aspect_ratio -s "$dvd_width"x"$dvd_height" -r $framerate -an -pix_fmt yuv420p -f yuv4mpegpipe - >&3
else
	ffmpeg -i "$1" -y -aspect $aspect_ratio -s "$dvd_width"x"$dvd_height" -r $framerate -an -pix_fmt yuv420p -f yuv4mpegpipe - | yuvstrip >&3
fi
}


encode ()
# for encoding one image for N frames
# encode $image $frames
{
local myimage="$1"
local myframes="$2"
if [ "$yuvfirstfile" -eq 1 ]; then
        yuvfirstfile=0
	ppmtoy4m -v $verbosity -n "$myframes" -r -S "$subsample" -F $ppmtoy4m_frc -A $ppmtoy4m_aspect -I p "$myimage" >&3
else
	ppmtoy4m -v $verbosity -n "$myframes" -r -S "$subsample" -F $ppmtoy4m_frc -A $ppmtoy4m_aspect -I p "$myimage" | yuvstrip >&3
fi
}


encode_fade ()
{
if [ "$yuvfirstfile" -eq 1 ]; then
	yuvfirstfile=0
	find "$tmpdir" -name "fade*.ppm" -type f -print0 | sort -z -d | xargs -0 cat | ppmtoy4m -v $verbosity -n 0 -S "$subsample" -F $ppmtoy4m_frc -A $ppmtoy4m_aspect -I p | cat >&3
else
	find "$tmpdir" -name "fade*.ppm" -type f -print0 | sort -z -d | xargs -0 cat | ppmtoy4m -v $verbosity -n 0 -S "$subsample" -F $ppmtoy4m_frc -A $ppmtoy4m_aspect -I p | yuvstrip >&3
fi
}

waitforfile ()
{
	# $1 is the filename
	## wait for the file to exist...
	while [ ! -f "$1" ] 
	do
		sleep 0.2s
	done
}

waitforfiles ()  # WAITFORFILES
# waitforfiles $filename $ext $last_file [$start_file]
{
	# $1 is the filename (with path)
	# $2 is the filename extension
	# $3 is the max digits in the series
	## wait for all files in a fade to exist...
	local dir_tmp=`dirname "$1"`
	local newfile_tmp="0"
	local di_tmp="0"
	local ext=$2
	[ -n "$4" ] && local start="$( printf %4.0f $4 )" || local start="1" 
	local end="$( printf %4.0f $3 )"
	for (( i_tmp=start ; i_tmp<=end ; i_tmp++ )) ; do
		di_tmp=`addzeros $i_tmp`
		newfile_tmp="$1"_$di_tmp.$ext
		[ $debug -ge 2 ] && logecho "waiting for file $newfile_tmp"
		while [ ! -f "$newfile_tmp" ] 
		do
			sleep 0.1s
		done
	done
}

extracopies ()  # EXTRACOPIES
# extracopies $this_frame $total_frames $extension(ppm or png)
{
	local this_frame=$1
	local total_frames=$2
	local suffix=$3
	[ -z "$suffix" ] && suffix='ppm'
	waitforfile "$tmpdir/fade_$dj"."$suffix" 
	if [ $stepsize -gt 1 ] ; then
		if [ $this_frame -eq $total_frames ] ; then
			## last frame in sequence, don't make any copies!
			echo -n ''
		elif [ $this_frame -gt $(( $total_frames - $stepsize )) ] ; then
			## make ( $total_frames - $this_frame ) copies
			end=$(( $total_frames - $this_frame ))
			for (( it=1 ; it<=end ; it++ )) ; do
				dj2=`addzeros $(( $this_frame + $it ))`
				cp "$tmpdir/fade_$dj.$suffix" "$tmpdir/fade_$dj2.$suffix"
				waitforfile "$tmpdir/fade_$dj2"."$suffix"   # need on slow systems?
			done
		else
			## loop over number of copies = stepsize-1
			end=$(( $stepsize - 1 ))
#			for it in `seq 1 $(( $stepsize - 1 ))`; do
			for (( it=1 ; it<=end ; it++ )) ; do
				dj2=`addzeros $(( $this_frame + $it ))`
				cp "$tmpdir/fade_$dj.$suffix" "$tmpdir/fade_$dj2.$suffix"
				waitforfile "$tmpdir/fade_$dj2"."$suffix"   # need on slow systems?
			done
		fi
	fi
}

seconds2ms ()
{
	## break up the duration into the integer seconds and ms:
	out_duration=`echo $1 | awk '{ print $1 * 1000 }'`
	echo "$out_duration"
}

previouseffectincrement ()
{
	## get previous slide:  we can safely ignore the previous fadeouts because they get applied
	## only to the previous image
	local previousimage='0'
	local increment=1
	local image1='0' ; local dur1=0 ; local image_file1='0'
	while [ $(( $i - $increment )) -ge 0 ] ; do
		[ -n "${image[$i-$increment]}" ] && image1="${image[$(($i-$increment))]}" 
		[ -n "${duration[$i-$increment]}" ] && dur1="${duration[$(($i-$increment))]}" 
		[ -n "${image_file[$i-$increment]}" ] && image_file1=${image_file[$i-$increment]}
#echo "i=$i increment=$increment image_file=${image_file[$i-$increment]}" 1>&2
		if [ "$image_file1" == "1" ] || [ "$image1" == 'title' ] || [ "$image1" == 'titlebar' ] || [ "$image1" == 'musictitle' ] || ( [ "$image1" == 'background' ] && [ "$dur1" -ne 0 ] ) ; then
			previousimage="0"  #  i.e., not a fade
			break
		elif [ "$image1" == 'fadein' ] || [ "$image1" == 'crossfade' ] || [ "$image1" == 'wipe' ] ; then
			previousimage="$increment"
			break
		else 
			## previous line is not an image.  Check for crossfade:
			increment=$(( $increment + 1 ))	
		fi
	done
	echo "$previousimage"
}

nexteffectincrement ()
{
	## get next effect, but we can safely ignore the fadein
	local nextimage='0'
	local increment=1
	local image1='0' ; local dur1=0 ; local image_file1='0'
	while [ $(( $i + $increment )) -le ${#image[@]} ] ; do
#echo "i=$i increment=$increment ${#image[@]} nextimage=$nextimage" 1>&2
		[ -n "${image[$i+$increment]}" ] && image1="${image[$(($i+$increment))]}" 
		[ -n "${duration[$i+$increment]}" ] && dur1="${duration[$(($i+$increment))]}" 
		[ -n "${image_file[$i+$increment]}" ] && image_file1=${image_file[$i+$increment]}
		if [ "$image_file1" == "1" ] || [ "$image1" == 'title' ] || [ "$image1" == 'titlebar' ] || [ "$image1" == 'musictitle' ] || ( [ "$image1" == 'background' ] && [ "$dur1" != 0 ] ) ; then
			nextimage="0"  # i.e., not fadein
			break
		elif [ "$image1" == 'fadeout' ] || [ "$image1" == 'crossfade' ] || [ "$image1" == 'wipe' ] ; then
			nextimage="$increment"
			break
		else 
			## next line is not an image.  Check for crossfade:
			increment=$(( $increment + 1 ))	
		fi
	done
	echo "$nextimage"
}

nextslidename ()  # NEXTSLIDENAME
{
	## get next slide:
	nextimage=''
	increment=1
	while [ $(( $i + $increment )) -le ${#image[@]} ] ; do
		image1="${image[$(($i+$increment))]}" ; dur1="${duration[$(($i+$increment))]}" ; image_file1=${image_file[$i+$increment]}
		if [ "$image_file1" == "1" ] || [ "$image1" == 'title' ] || [ "$image1" == 'titlebar' ] || [ "$image1" == 'musictitle' ] || ( [ "$image1" == 'background' ] && [ "$dur1" -ne 0 ] ) ; then
			nextimage="$image1"
			break
		else 
			## next line is not an image!
			increment=$(( $increment + 1 ))	
		fi
	done
	if [ -z "$nextimage" ] ; then
		echo "" 1>&2
		echo '[dvd-slideshow] ERROR: Could not find a valid next slide' 1>&2
		echo '[dvd-slideshow]        This happens when a fade cannot locate a future image in your .txt file' 1>&2
		echo '[dvd-slideshow]	     Fix this in your input file and re-run dvd-slideshow.' 1>&2
		function_error=1
	else
		echo "$nextimage"
	fi
}

previousslideincrement ()
{
	previousimage=''
	increment=1
	while [ $(( $i - $increment )) -ge 0 ] ; do
		image1="${image[$(($i-$increment))]}" ; dur1="${duration[$(($i-$increment))]}" ; image_file1=${image_file[$i-$increment]}
#		image_file[$i]=0 ; audio_file[$i]=0 ; avi_file[$i]=0
		if [ $image_file1 -eq 1 ] || [ "$image1" == 'title' ] || [ "$image1" == 'titlebar' ] || [ "$image1" == 'musictitle' ] || ( [ "$image1" == 'background' ] && [ "$dur1" -ne 0 ] ) ; then
			previousimage="$image1"
			break
		else 
			## previous line is not an image!
			increment=$(( $increment + 1 ))	
		fi
	done
	if [ -z "$previousimage" ] ; then
		increment=0
#		echo "" 1>&2
#		echo '[dvd-slideshow] ERROR: Could not find a valid previous slide' 1>&2
#		echo '[dvd-slideshow]        This happens when a dvd-slideshow cannot locate a past image in your .txt file' 1>&2
#		echo '[dvd-slideshow]	     Fix this in your input file and re-run dvd-slideshow.' 1>&2
#		function_error=0
		echo "$increment"
	else
		echo "$increment"
	fi
}

nextslideincrement ()
{
	nextimage=''
	increment=1
	while [ $(( $i + $increment )) -le ${#image[@]} ] ; do
		image1="${image[$(($i+$increment))]}" ; dur1="${duration[$(($i+$increment))]}" ; image_file1=${image_file[$i+$increment]}
#		image_file[$i]=0 ; audio_file[$i]=0 ; avi_file[$i]=0
		if [ "$image_file1" == "1" ] || [ "$image1" == 'title' ] || [ "$image1" == 'titlebar' ] || [ "$image1" == 'musictitle' ] || ( [ "$image1" == 'background' ] && [ "$dur1" -ne 0 ] ) ; then
			nextimage="$image1"
			break
		else 
			## next line is not an image!
			increment=$(( $increment + 1 ))	
		fi
	done
	if [ -z "$nextimage" ] ; then
#		echo "" 1>&2
#		echo '[dvd-slideshow] ERROR: Could not find a valid next slide' 1>&2
#		echo '[dvd-slideshow]        This happens when a fade cannot locate a future image in your .txt file' 1>&2
#		echo '[dvd-slideshow]	     Fix this in your input file and re-run dvd-slideshow.' 1>&2
#		function_error=1
		increment=0
		echo "$increment"
	else
		echo "$increment"
	fi
}

previousslideppm ()
{
	## get previous image:
	if [ -f "$tmpdir/slide_$(($i-1)).ppm" ] ; then
		previousimage="$tmpdir/slide_$(($i-1)).ppm"
	elif [ -f "$tmpdir/slide_$(($i-2)).ppm" ] ; then
		previousimage="$tmpdir/slide_$(($i-2)).ppm"
	elif [ -f "$tmpdir/slide_$(($i-3)).ppm" ] ; then
		previousimage="$tmpdir/slide_$(($i-3)).ppm"
	else 
		## previous line is not an image!
		echo "" 1>&2
		echo '[dvd-slideshow] ERROR: Could not find a valid previous image' 1>&2
		echo '[dvd-slideshow]	     This happens when a fade cannot locate a previous image in your .txt file' 1>&2
		echo '[dvd-slideshow]	     Fix this in your input file and re-run dvd-slideshow.' 1>&2
		function_error=1
	fi
	echo "$previousimage"
}

read_next_variables ()  # READ_NEXT_VARIABLES
{
	## get next slide:
	local nextimage=''
	local increment=1
	while [ $(( $i + $increment )) -le ${#image[@]} ] ; do
		local image1="${image[$(($i+$increment))]}" ; local dur1="${duration[$(($i+$increment))]}" ; local image_file1=${image_file[$i+$increment]}
		if [ "$image_file1" == "1" ] || [ "$image1" == 'title' ] || [ "$image1" == 'titlebar' ] || [ "$image1" == 'musictitle' ] || ( [ "$image1" == 'background' ] && [ "$dur1" -ne 0 ] ) ; then
			nextimage="$image1"
			break
		else 
			## next line is not an image!
			# read variable if it exists:
			set_variables "$image1" 1
#			it=`set_variables "$image1" 0`
#			if [ -n "$it" ] ; then
#				myecho "[dvd-slideshow] Set future variable $it"
#			fi
			increment=$(( $increment + 1 ))	
		fi
	done
	if [ -z "$nextimage" ] ; then
		echo "" 1>&2
		echo '[dvd-slideshow] ERROR: Could not find a valid next slide' 1>&2
		echo '[dvd-slideshow]        This happens when a fade cannot locate a future image in your .txt file' 1>&2
		echo '[dvd-slideshow]	     Fix this in your input file and re-run dvd-slideshow.' 1>&2
		function_error=1
	fi
}

titlebarslide ()
# titlebarslide $title1 $title2 $output_filename $background_file
{
	## $1 contains the head title, and $2 contains the sub-title
	local title1="$1"
	local title2="$2"
	if [ -n "$3" ] ; then
		local output_file="$3"
	else
		local output_file="$tmpdir/title.ppm"  # default
	fi
	if [ -n "$4" ] && [ -f "$4" ] ; then
		local bg="$4"
	else
		local bg="$tmpdir"/slideshow_background.ppm # default
	fi
	check_rm "$output_file"

	# figure out actual coordinates:
	if [ "$low_quality" -eq 1 ] || [ "$vcd" -eq 1 ] || [ "$output_format" == 'flv' ] || [ "$output_format" == 'swf' ] ; then
		## top title:
		local f_toptitle_font_size=$(( $toptitle_font_size * $dvd_height / 480 ))
		local f_toptitle_bar_height=$(( $toptitle_bar_height * $dvd_height / 480 ))
		local f_toptitle_text_location_x=$(( $toptitle_text_location_x * $dvd_height / 480 ))
		local f_toptitle_text_location_y=$(( $toptitle_text_location_y * $dvd_height / 480 ))
		# bottom title:
		local f_bottomtitle_font_size=$(( $bottomtitle_font_size * $dvd_height / 480 ))
		local f_bottomtitle_bar_location_y=$(( $bottomtitle_bar_location_y * $dvd_height / 480 ))
		local f_bottomtitle_bar_height=$(( $bottomtitle_bar_height * $dvd_height / 480 ))
		local f_bottomtitle_text_location_x=$(( $bottomtitle_text_location_x * $dvd_height / 480 ))
		local f_bottomtitle_text_location_y=$(( $bottomtitle_text_location_y * $dvd_height / 480 ))
	elif [ "$svcd" -eq 1 ] ; then  # x-resolution is 480x480 (ntsc) or 480x576 (pal)
		## top title:
		local f_toptitle_font_size=$(( $toptitle_font_size ))
		local f_toptitle_bar_height=$(( $toptitle_bar_height ))
		local f_toptitle_text_location_x=$(( $toptitle_text_location_x / 3 ))
		local f_toptitle_text_location_y=$(( $toptitle_text_location_y ))
		# bottom title:
		local f_bottomtitle_font_size=$(( $bottomtitle_font_size ))
		local f_bottomtitle_bar_location_y=$(( $bottomtitle_bar_location_y ))
		local f_bottomtitle_bar_height=$(( $bottomtitle_bar_height ))
		local f_bottomtitle_text_location_x=$(( $bottomtitle_text_location_x / 3 ))
		local f_bottomtitle_text_location_y=$(( $bottomtitle_text_location_y ))
	else
		local f_toptitle_font_size=$(( $toptitle_font_size ))
		local f_toptitle_bar_height=$(( $toptitle_bar_height ))
		local f_toptitle_text_location_x=$(( $toptitle_text_location_x ))
		local f_toptitle_text_location_y=$(( $toptitle_text_location_y ))
		# bottom title:
		local f_bottomtitle_font_size=$(( $bottomtitle_font_size ))
		local f_bottomtitle_bar_location_y=$(( $bottomtitle_bar_location_y ))
		local f_bottomtitle_bar_height=$(( $bottomtitle_bar_height ))
		local f_bottomtitle_text_location_x=$(( $bottomtitle_text_location_x ))
		local f_bottomtitle_text_location_y=$(( $bottomtitle_text_location_y ))
	fi
	## now the title2 y-locations were specified relative to the bottom of the image
	## but imagemagick needs them relative to the top of the image:
	f_bottomtitle_bar_location_y=$(( $dvd_height - $f_bottomtitle_bar_location_y ))
	f_bottomtitle_text_location_y=$(( $dvd_height - $f_bottomtitle_text_location_y ))
	local title2_bgtop=$f_bottomtitle_bar_location_y
	local title2_bgbot=$(( $f_bottomtitle_bar_location_y + $f_bottomtitle_bar_height ))

	if [ -z "$title1" ] && [ -z "$title2" ] ; then
		myecho "[dvd-slideshow] ERROR: No title text was found. Syntax:"
		myecho "[dvd-slideshow]        titlebar:duration:TopTitle:BottomTitle"
		cleanup; exit 1
	fi
	check_rm "$tmpdir/title1.png"

	if [ -n "$title1" ] ; then  # title1 exists
		if [ "$f_toptitle_bar_height" -ne 0 ] ; then
			convert -size "$dvd_width"x"$dvd_height" xc:transparent -fill white \
		       	-draw "Rectangle 0,0,$dvd_width,$f_toptitle_bar_height" miff:- | \
			composite -compose src-over -type TrueColor -depth 8 -dissolve 50 - \
			"$bg" "$tmpdir/slide_$i.png"	
		else
			convert "$bg" -type TrueColor -depth 8 "$tmpdir/slide_$i.png"
		fi
		convert -size "$dvd_width"x"$dvd_height" xc:transparent -fill "$toptitle_font_color" \
		-pointsize "$f_toptitle_font_size" -gravity NorthWest -font "$title_font" \
		-draw "text $f_toptitle_text_location_x,$f_toptitle_text_location_y \"${title1}\"" miff:- | \
		composite -compose src-over -type TrueColor -depth 8 - \
		"$tmpdir/slide_$i.png" "$tmpdir/title1.png"
		convert "$tmpdir/title1.png" -type TrueColor -depth 8 "$output_file"
	fi
	if [ -n "$title2" ] ; then # title2 exists
		if [ "$f_bottomtitle_bar_height" -ne 0 ] ; then
			convert -size "$dvd_width"x"$dvd_height" xc:transparent -fill white -quality 100\
			-draw "Rectangle 0,$title2_bgtop,$dvd_width,$title2_bgbot" -type TrueColor -depth 8 "$tmpdir/title_background.png"
		else
			convert -size "$dvd_width"x"$dvd_height" xc:transparent -type TrueColor -depth 8 "$tmpdir/title_background.png"
		fi
		if [ -f "$tmpdir/title1.png" ] ; then # use title1 image
			composite -compose src-over -type TrueColor -depth 8 -dissolve 50 -quality 100 "$tmpdir/title_background.png" "$tmpdir/title1.png" "$tmpdir/slide_$i.png"	
		else  # use background image (no first title)
			composite -compose src-over -type TrueColor -depth 8 -dissolve 50 -quality 100 "$tmpdir/title_background.png" "$bg" "$tmpdir/slide_$i.png"	
		fi
		convert -size "$dvd_width"x"$dvd_height" xc:transparent -fill "$bottomtitle_font_color" \
			-pointsize "$f_bottomtitle_font_size" -gravity North -font "$title_font" \
			-draw "text $f_bottomtitle_text_location_x,$f_bottomtitle_text_location_y \"${title2}\"" -type TrueColor -depth 8 miff:- | \
		composite -compose src-over -type TrueColor -depth 8 - \
			"$tmpdir/slide_$i.png" "$output_file"
	fi
	check_rm "$tmpdir/title1.png"
}

titleslide ()
{
# titleslide $title $output_filename $background
	title="$1"
	if [ -z "$title" ] ; then
		myecho "[dvd-slideshow] ERROR: No title text was found. Syntax:"
		myecho "[dvd-slideshow]        title:duration:Title_text"
		cleanup; exit 1
	fi
	if [ -n "$2" ] ; then
		local output_file="$2"
	else
		local output_file="$tmpdir/title.ppm"
	fi
	if [ -n "$3" ] && [ -f "$3" ] ; then
		local bg="$3"
	else
		local bg="$tmpdir"/slideshow_background.ppm
	fi
	check_rm "$output_file"

	if [ "$low_quality" -eq 1 ] || [ "$vcd" -eq 1 ] || [ "$output_format" == 'flv' ] || [ "$output_format" == 'swf' ] ; then
		local f_title_font_size=$(( $title_font_size * $dvd_height / 480 ))
	else
		local f_title_font_size=$(( $title_font_size ))
	fi
	## if background is black and font color is black, change font color to white
	if [ "$bgfile" == 'black' ] && [ "$title_font_color" == 'black' ] ; then
		title_font_color='white'
	fi

#		it=`echo "${subtitle[$i]}" | awk -F'\\' '{print $2}' | cut -c 1`
#		if [ "$it" == 'n' ] ; then
	## check to see if we find any user-specified breaks \n
	it=`echo "$title" | awk -F'\\' '{print $2}' | cut -c 1`
	if [ "$it" == 'n' ] ; then
		logecho "[dvd-slideshow] Found \\n in title"
		# user entered a \n to force line wraps
		# break lines at line wraps
		title1=`echo "${title}" | awk -F'\\' '{print $1}'`
		title2=`echo "${title}" | awk -F'\\' '{print $2}' | cut -c 2-`
		title3=`echo "${title}" | awk -F'\\' '{print $3}' | cut -c 2-`
		title4=`echo "${title}" | awk -F'\\' '{print $4}' | cut -c 2-`

		convert -size "$dvd_width"x"$dvd_height" xc:transparent -fill $title_font_color \
		-pointsize $f_title_font_size -gravity Center -font "$title_font" -annotate 0 "$title1\n$title2\n$title3\n$title4" -type TrueColor -depth 8 miff:- | \
		composite -compose src-over -type TrueColor -depth 8 - "$bg" "$output_file"
	else	# no forced line wraps.  Eventually Check for long lines
		convert -size "$dvd_width"x"$dvd_height" xc:transparent -fill $title_font_color \
		-pointsize $f_title_font_size -gravity Center -font "$title_font" -draw "text 0,0 \"${title}\"" -type TrueColor -depth 8 miff:- | \
		composite -compose src-over -type TrueColor -depth 8 - "$bg" "$output_file"
	fi
}

musictitleslide ()
{
# musictitleslide $Title $Artist $Album $output_file $background_file
		local Title="$1"
		local Artist="$2"
		local Album="$3"
		# draw text:
		if [ -n "$4" ] ; then
			local output_file="$4"
		else
			local output_file="$tmpdir/title.ppm"
		fi
		if [ -n "$5" ] && [ -f "$5" ] ; then
			local bg="$5"
		else
			local bg="$tmpdir"/slideshow_background.ppm
		fi
		check_rm "$output_file"
		if [ "$low_quality" -eq 1 ] || [ "$vcd" -eq 1 ] || [ "$output_format" == 'flv' ] || [ "$output_format" == 'swf' ] ; then
			f_subtitle_font_size=$(( $subtitle_font_size * $dvd_height / 480 ))
			convert -size $dvd_width"x"$dvd_height xc:transparent \
			-pointsize "$f_subtitle_font_size" -gravity SouthWest -font "$title_font" \
			-draw "fill white text 40,100 \"$Title\"" \
			-draw "fill white text 40,75 \"$Artist\"" \
			-draw "fill white text 40,50 \"$Album\"" -quality 100 -type TrueColor -depth 8 "$tmpdir/mytitle.png"
		else  # medium or high quality
			f_subtitle_font_size=$(( $subtitle_font_size ))
			convert -size $dvd_width"x"$dvd_height xc:transparent \
			-pointsize "$f_subtitle_font_size" -gravity SouthWest -font "$title_font" \
			-draw "fill white text 80,200 \"$Title\"" \
			-draw "fill white text 80,150 \"$Artist\"" \
			-draw "fill white text 80,100 \"$Album\"" -quality 100 -type TrueColor -depth 8 "$tmpdir/mytitle.png"
		fi
		composite -compose src-over -type TrueColor -depth 8 "$tmpdir/mytitle.png" "$bg" "$output_file"
		check_rm "$tmpdir"/mytitle.png
}

checkforautocrop ()
{
	if [ "$autocrop" -eq 1 ] ; then
		# figure out whether to autocrop the image or not
	        image_width=`imagewidth "$1"`
	        image_height=`imageheight "$1"`
	        ratio="$(( 100* $image_width / $image_height ))"
	        out_ratio="$(( 100* $dvd_width / $dvd_height ))"
		do_autocrop_w=0 ; do_autocrop_h=0
		out_ratio_plus=$(( $out_ratio + 30 ))
		out_ratio_minus=$(( $out_ratio - 30 ))
		if [ "$ratio" -gt $out_ratio_minus ] && [ $ratio -lt $out_ratio_plus ]; then
			## if ratio is +/- 30 from output ratio 
			if [ "$ratio" -lt "$(( $out_ratio ))" ] ; then
				do_autocrop_h=1 # image too wide, crop height
			elif [ "$ratio" -gt "$(( $out_ratio ))" ] ; then
				do_autocrop_w=1 # image too tall, crop width
			fi
		fi
		[ $debug -ge 3 ] && myecho "[dvd-slideshow:checkforautocrop] image_width=$image_width image_height=$image_height ratio=$ratio out_ratio=$out_ratio"
		[ $debug -ge 3 ] && myecho "[dvd-slideshow:checkforautocrop] do_autocrop_w=$do_autocrop_w  do_autocrop_h=$do_autocrop_h"
	else
		do_autocrop_h=0 ; do_autocrop_w=0
	fi
}

background () # BACKGROUND
{
		## input is:  $1 = effect/image
		# output is written to "$tmpdir"/slideshow_background.ppm 
		bg="$1"
		if [ -f "$bg" ] ; then # if effect is a background file
			myecho "[dvd-slideshow] Creating background $( truncate_filename "$bg")"
			checkforautocrop "$bg"
                       if [ "$do_autocrop_w" -eq 1 ]; then   
                               # autocrop background image width (width too large)
                               convert "${bg}" -resize "$sq_to_dvd_pixels" -resize x"$dvd_height" \
                               -gravity center -crop "$dvd_width"x"$dvd_height"'+0!+0!' -type TrueColor -depth 8 "$tmpdir"/slideshow_background.ppm
                       elif [ "$do_autocrop_h" -eq 1 ]; then
                               # autocrop background image height (height too large)
                               convert "${bg}" -resize "$sq_to_dvd_pixels" -resize "$dvd_width"x \
                               -gravity center -crop "$dvd_width"x"$dvd_height"'+0!+0!' -type TrueColor -depth 8 "$tmpdir"/slideshow_background.ppm
                       else
                               #don't autorop
                               convert "${bg}" -resize "$sq_to_dvd_pixels" -resize x"$dvd_height" -bordercolor black -border "$dvd_width"x240 \
                               -gravity center -crop "$dvd_width"x"$dvd_height"'+0!+0!' -type TrueColor -depth 8 "$tmpdir"/slideshow_background.ppm
                       fi
			bgfile="$bg"
		elif [ "$bg" == 'black' ] ; then  # I guess we could add other types of backgrounds here!
			## use plain black background with no picture
			myecho "[dvd-slideshow] Creating black background"
			convert -size "$dvd_width"'x'"$dvd_height" xc:black -type TrueColor -depth 8 "$tmpdir"/slideshow_background.ppm
			bgfile="black"
		elif [ "$bg" == 'white' ] ; then  # I guess we could add other types of backgrounds here!
			## use plain white background with no picture
			myecho "[dvd-slideshow] Creating white background"
			convert -size "$dvd_width"'x'"$dvd_height" xc:white -type TrueColor -depth 8 "$tmpdir"/slideshow_background.ppm
			bgfile="white"
		elif [ "${bg:0:1}" == '#' ] ; then  # user passed a #RRGGBB hex color
			myecho "[dvd-slideshow] Creating $bg color background"
			convert -size "$dvd_width"'x'"$dvd_height" xc:"$bg" -type TrueColor -depth 8 "$tmpdir"/slideshow_background.ppm
			bgfile="hex"
		else
			myecho "[dvd-slideshow] ERROR: No background file specified!"
			myecho "[dvd-slideshow] 	Correct syntax is:"
			myecho "[dvd-slideshow] background:duration:subtitle:background_image_or_color"
			exit 1
		fi
#		convert "$normal_bg" -type TrueColor -depth 8 "$tmpdir/slideshow_background.mpc"
}

coordinates_in_dvd_aspect_ratio_frame ()
{
	# dvd_width dvd_height image_width image_height x_coordinate y_coordinate
	#dvd_width=$1; dvd_height=$2
	#image_width=$3; image_height=$4
	#x_image_coordinate=$5 y_image_coordinate=$6
	# output: x_dvd_coordinate y_dvd_coordinate

	## calculate frame size after adding black side bars for portrait pictures:
	ratio=$(( 1000* $3 / $4 ))
	out_ratio=$(( 1000* $1 / $2 ))  
	if [ "$ratio" -gt "$(( $out_ratio ))" ] ; then
		# image width greater than output width at same scale
		new_image_width=$3
		new_image_height=`div10 $(( 10* $2 * $3 / $1 ))`
		x_dvd_coordinate=0
		y_dvd_coordinate=`div10 $(( 10*( $new_image_height - $4 ) / 2 ))`
	elif [ "$ratio" -le $(( $out_ratio )) ] ; then
		# image height greater than output height at same scale 
		new_image_width=`div10 $(( 10* $1 * $4 / $2 ))`
		new_image_height=$4
		y_dvd_coordinate=0
		x_dvd_coordinate=`div10 $(( 10*( $new_image_width - $3 ) / 2 ))`
	fi
	# calculate coordinate transformation by xi,yi
#	x_dvd_coordinate=$(( $x_image_coordinate - $xi ))
#	y_dvd_coordinate=$(( $y_image_coordinate - $yi ))
}

parse_window ()  # PARSE_WINDOW
# parse_window $
{
	# pass a string $1 (kenburns start or end arguments)

	# xi,yi is the top left corner of the image relative to the frame
	# xw,yh are the width and height of the crop (must be even numbers)
	# x0,y0 is the top left corner of the crop in the image frame.
	# x1,y1 is the bottom right corner of the crop in the image frame.
	# textfile format is:  
	# file:duration:comment:kenburns:xs0,ys0;xs1,ys1;xe0,ye0;xe1,ye1;[startangle,endangle]
	# or
	# file:duration:comment:kenburns:start 0%-100%;start_location;end 0%-100%;end_location;[startangle,endangle]
	# where 0%-100% indicates the fraction of the window width/height, and
	# where start_location and end_location can be:
	# 	topleft			topmiddle|top		topright
	#	middleleft|left		middle			middleright|right
	#	bottomleft		bottommiddle|bottom	bottomright
	# or
	# 	x%,y%
	#	where % is a percentage of the window width/height starting from the
	# 	top left corner of the screen.
	# or
	# 	imagewidth | imageheight
	#	where the window width or height will be scaled to fill the full
	#	width or height of the dvd screen.
	#	
	# ( angles not implemented yet! )
	# and the optional startangle,endangle parameters will allow for rotation of the image during
	# the kenburns effect.  Startangle is optional, and if omitted, will default to zero.
	# Positive numbers denote clockwise rotation, and negative numbers denote counter-clockwise rotation.
	# 

	it=`echo "$1" | awk -F';' '{print $1}' | awk -F% '{print NF}'`
	firstarg=`echo "$1" | awk -F';' '{print $1}'`
	image_width="`imagewidth "$2"`"   # returns non-square image size
	image_height="`imageheight "$2"`"
	## calculate frame size after adding black side bars for portrait pictures:
	ratio=$(( 1000* $image_width / $image_height ))
	out_ratio=$(( 1000* $frame_width / $frame_height ))  # doesn't change during script
	[ $debug -ge 3 ] && myecho "[dvd-slideshow:parse_window] image_width=$image_width image_height=$image_height ratio=$ratio out_ratio=$out_ratio"
	if [ "$ratio" -gt "$out_ratio" ] ; then
		# image width greater than output width at same scale
		new_image_width=$image_width
		new_image_height=`div10 $(( 10* $frame_height * $image_width / $frame_width ))`
#		echo "1 frame_width=$frame_width frame_height=$frame_height image_width=$image_width image_height=$image_height sq_pixel_multip=$sq_pixel_multiplier "
		xi=0  # will need to add frame border later...
		yi=`div10 $(( 10*( $new_image_height - $image_height ) / 2 ))`
	elif [ "$ratio" -le $out_ratio ] ; then
		# image height greater than output height at same scale 
#		new_image_width=`div10 $(( 10* $frame_width * $image_height / $frame_height * $sq_pixel_multiplier / 1000 ))`
		new_image_width=`div10 $(( 10* $frame_width * $image_height / $frame_height ))`
		new_image_height=$image_height
#		echo "2 frame_width=$frame_width frame_height=$frame_height image_width=$image_width image_height=$image_height sq_pixel_multip=$sq_pixel_multiplier "
		yi=0 # will need to add frame border later...
		xi=`div10 $(( 10*( $new_image_width - $image_width ) / 2 ))`
	fi
	[ $debug -ge 3 ] && echo "[dvd-slideshow:parse_window] x0=$x0 y0=$y0  x1=$x1 y1=$y1  xi=$xi yi=$yi"
	[ $debug -ge 3 ] && myecho "[dvd-slideshow:parse_window] new_image_width=$new_image_width new_image_height=$new_image_height xi=$xi yi=$yi"
	if [ "$it" -eq 2 ] || [ "$firstarg" == 'imagewidth' ] || [ "$firstarg" == 'imageheight' ] ; then 
		## use "keywords"
		## first parse the zoom amount:
		loc=`echo "$1" | awk -F';' '{print $2}'`
		if [ "$firstarg" == 'imagewidth' ] ; then 
			# scale width to equal output dvd width:
			xw=$image_width
			yh=`div10 $(( 10 * $frame_height * $xw / $frame_width ))`
		elif [ "$firstarg" == 'imageheight' ] ; then 
			# scale height to equal output dvd width:
			yh=$image_height
			xw=`div10 $(( 10 *$frame_width * $yh / $frame_height ))`
		else
			## this needs to be in the non-square pixel frame, hence the
			## sq_pixel_multiplier 
			zoom_percent=`echo "$1" | awk -F';' '{print $1}' | awk -F% '{print $1}'`
			[ $debug -ge 3 ] && myecho "[dvd-slideshow:parse_window] zoom=$zoom_percent, loc=$loc "
			xw=`div10 $(( 10 * $new_image_width * $zoom_percent / 100 ))`
			yh=`div10 $(( 10 * $new_image_height * $zoom_percent / 100 ))`
		fi
		## next line is because we want the zoom % coordinates to be relative to the
		## whole screen size, so if you have a tall, narrow picture, 50% will mean
		## half of the height, etc...	
		# now, calculate the actual coordinates:
		[ $debug -ge 3 ] && myecho "[dvd-slideshow:parse_window] xw=$xw yh=$yh"

		## middle calculations are for using the "middle" keywords:
		ymiddle0=`div10 $(( 10 *$new_image_height / 2 - 10 *$yh / 2 ))`
		ymiddle1=`div10 $(( 10 *$new_image_height / 2 + 10 *$yh / 2 ))`
		xmiddle0=`div10 $(( 10 *$new_image_width / 2 - 10 *$xw / 2 ))`
		xmiddle1=`div10 $(( 10 *$new_image_width / 2 + 10 *$xw / 2 ))`
		[ $debug -ge 3 ] && myecho "[dvd-slideshow:parse_window] ymiddle0=$ymiddle0 ymiddle1=$ymiddle1  xmiddle0=$xmiddle0 xmiddle1=$xmiddle1"

		## now parse the box location:
		it=`echo "$1" | awk -F';' '{print $2}' | awk -F% '{print NF}'`
		if [ "$it" -ge 2 ] ; then # second arg contains a %
			# location is specified a a percent of the window size
			xcenter_pct=`echo "$1" | awk -F';' '{print $2}' | awk -F',' '{print $1}' | awk -F% '{print $1}'`
			ycenter_pct=`echo "$1" | awk -F';' '{print $2}' | awk -F',' '{print $2}' | awk -F% '{print $1}'`
#			[ $debug -ge 3 ] && myecho "[dvd-slideshow] xcenter_pct=$xcenter_pct ycenter_pct=$ycenter_pct"
			[ -z "$xcenter_pct" ] && (myecho '[dvd-slideshow] Error: bad xcenter percentage' ; cleanup; exit 1)
			[ -z "$ycenter_pct" ] && (myecho '[dvd-slideshow] Error: bad ycenter percentage' ; cleanup; exit 1)
			xcenter=$(( 10 * $new_image_width * $xcenter_pct / 100 ))
			ycenter=$(( 10 * $new_image_height * $ycenter_pct / 100 ))
			[ $debug -ge 3 ] && myecho "[dvd-slideshow:parse_window] xcenter=$xcenter ycenter=$ycenter"
#			x0=`div10 $(( $xcenter - 10 * $xw / 2 ))`; x1=$(( $xcenter + $xw / 2 ))
#			y0=`div10 $(( $ycenter - 10 * $yh / 2 ))`; y1=$(( $ycenter + $yh / 2 ))
			x0=`div10 $(( $xcenter - 10 * $xw / 2 ))`; x1=$(( $x0 + $xw ))
			y0=`div10 $(( $ycenter - 10 * $yh / 2 ))`; y1=$(( $y0 + $yh ))
			[ $debug -ge 3 ] && echo "[dvd-slideshow:parse_window] x0=$x0 y0=$y0  x1=$x1 y1=$y1  xi=$xi yi=$yi"
		elif [ "$loc" == 'topleft' ] ; then
			x0=0; x1=$xw
			y0=0; y1=$yh
		elif [ "$loc" == 'middleleft' ] || [ "$loc" == 'left' ] ; then
			x0=0; x1=$xw
			y0=$ymiddle0; y1=$ymiddle1
		elif [ "$loc" == 'bottomleft' ] ; then
			x0=0; x1=$xw
			y0=$(( $new_image_height - $yh )) ; y1=$new_image_height
		elif [ "$loc" == 'topmiddle' ] || [ "$loc" == 'top' ] ; then
			x0=$xmiddle0; x1=$xmiddle1
			y0=0; y1=$yh
		elif [ "$loc" == 'middle' ] || [ "$loc" == 'center' ] ; then
			x0=$xmiddle0; x1=$xmiddle1
			y0=$ymiddle0; y1=$ymiddle1
		elif [ "$loc" == 'bottommiddle' ] || [ "$loc" == 'bottom' ] ; then
			x0=$xmiddle0; x1=$xmiddle1
			y0=$(( $new_image_height - $yh )) ; y1=$new_image_height
		elif [ "$loc" == 'topright' ] ; then
			x0=$(( $new_image_width - $xw )) ; x1=$new_image_width
			y0=0; y1=$yh
		elif [ "$loc" == 'middleright' ] || [ "$loc" == 'right' ] ; then
			x0=$(( $new_image_width - $xw )) ; x1=$new_image_width
			y0=$ymiddle0; y1=$ymiddle1
		elif [ "$loc" == 'bottomright' ] ; then
			x0=$(( $new_image_width - $xw )) ; x1=$new_image_width
			y0=$(( $new_image_height - $yh )) ; y1=$new_image_height
		else	
			myecho "[dvd-slideshow] Error: bad syntax in kenburns/crop location: $loc"
			cleanup; exit 1
		fi
	else  # check for original format with explicit start/end coordinates:
		## coordinate system is relative to the actual picture, unscaled, 
		## in square pixel frame!!!
		## we need to convert this to the buffered (dvd aspect ratio) 
		## and non-square pixel coordinate system!!!	
		x0=`echo "$1" | awk -F';' '{print $1}' | awk -F',' '{print $1}'`
		y0=`echo "$1" | awk -F';' '{print $1}' | awk -F',' '{print $2}'`
		x1=`echo "$1" | awk -F';' '{print $2}' | awk -F',' '{print $1}'`
		y1=`echo "$1" | awk -F';' '{print $2}' | awk -F',' '{print $2}'`

		# xi,yi already calculated
		# now, the size of the image frame should be new_image_width x new_image_height
		# This mode assumes the image is placed in the center of the dvd window to start.
		
		# width and height of area passed:
		xw=$(( ( $x1 - $x0 ) * $sq_pixel_multiplier / 1000 )) ; yh=$(( $y1 - $y0 ))

		## make sure the image crop coordinates are not outside the image:
		[ $xi -eq 0 ] && x0=$x0 || x0=$(( $x0 + $xi ))
		[ $xi -eq 0 ] && x1=$x1 || x1=$(( $x1 + $xi ))
		[ $yi -eq 0 ] && y0=$y0 || y0=$(( $y0 + $yi ))
		[ $yi -eq 0 ] && y1=$y1 || y1=$(( $y1 + $yi ))
	fi
	[ $debug -ge 2 ] && echo "[dvd-slideshow:parse_window] x0=$x0 y0=$y0  x1=$x1 y1=$y1  xi=$xi yi=$yi"
}

is_even ()
{
	# returns 0 or 1 depending on wether the number is even or not
	number=$1
	fraction=`expr $number % 2`
	if [ $fraction -eq 0 ] ; then
		echo "1"
	else
		echo "0"
	fi
}


todec000 ()
{
	factor_whole=$(( $1 / 1000 ))
	factor_dec=$(( $1 % 1000 ))
	if [ $factor_dec -lt 0 ] ; then
		factor_dec=$(( -1 * $factor_dec ))
	fi
	if [ ${#factor_dec} -eq 2 ] ; then
		factor_dec="0$factor_dec"
	elif [ ${#factor_dec} -eq 1 ] ; then
		factor_dec="00$factor_dec"
	elif [ ${#factor_dec} -eq 0 ] ; then
		factor_dec="000"
	fi
	echo "$factor_whole.$factor_dec"
}

div1000 ()
{
	# takes a number and divides by 1000, rounding appropriately
	number=$1
	whole=`expr $number / 1000`
	fraction=`expr $number % 1000`
	if [ $fraction -ge 500 ] ; then
		whole=$(( $whole + 1 ))  # round up
	fi
	echo $whole
}

div1000_2 ()
{
	# takes a number and divides by 1000, rounding to the nearest factor of 2
	number=$1
	whole=`expr $number / 2000`
	fraction=`expr $number % 2000`
	if [ $fraction -ge 1000 ] ; then
		whole=$(( 2* $whole + 2 ))  # round up
	else
		whole=$(( 2* $whole ))
	fi
	echo $whole
}

div1000_up ()
{
	# takes a number and divides by 1000, rounding up
	number=$1
	whole=`expr $number / 1000`
	fraction=`expr $number % 1000`
	if [ $fraction -ge 1 ] ; then
		whole=$(( $whole + 1 ))  # round up
	else
		whole=$(( $whole ))
	fi
	echo $whole
}

div10 ()
{
	# takes a number and divides by 10, rounding appropriately
	number=$1
	whole=`expr $number / 10`
	fraction=`expr $number % 10`
	if [ $fraction -ge 5 ] ; then
		whole=$(( $whole + 1 ))  # round up
	fi
	echo $whole
}

imagewidth ()  # IMAGEWIDTH
{
	it="`identify -format %w "$1"`"
	it="$(( $it * $sq_pixel_multiplier / 1000 ))"
	echo "$it"
}

imagewidth_sq ()  # IMAGEWIDTH_SQ
{
	it="`identify -format %w "$1"`"
	echo "$it"
}


imageheight ()
{
	it="`identify -format %h "$1"`"
	echo "$it"
}

crop_parameters () # CROP_PARAMETERS
{
	# converts the crop parameters reference in the full dvd aspect ratio
	# frame back to the actual crop parameters needed in the original 
	# image frame.
	#
	# the input coordinates are relative to the original image size, buffered out to
	# the output dvd aspect ratio
	#	
	# using the parameters x0,y0 ; x1,y1 ; xi,yi in memory (x1000)
	# output is just the crop parameters:
	# c_width, c_height xc0,yc0  (for the actual crop)
	# and for the corresponding composite command:
	# xci,yci for the location of the top left corner of the cropped image
	# relative to the output window.
	#
	# top left corner of dvd window is 0,0
	# top left corner of image is at xi,yi   from parse_window
	# top left corner of the cropped image is at x0,y0
	#
	# i.e., the "i" reference frame is in the unbuffered image (image alone)
	
	##############################################
	## figure out the size of the window scaled to the original image size:
	ratio=$(( 1000* $image_width / $image_height ))
	out_ratio=$(( 1000* $frame_width / $frame_height ))  # doesn't change during script
#	if [ "$ratio" -gt "$(( $out_ratio ))" ] ; then
#		# image width greater than output width at same scale
#		newwidth=$image_width
#		newheight=$(( $dvd_height * $image_width / $dvd_width ))
#	elif [ "$ratio" -le $(( $out_ratio )) ] ; then
#		# image height greater than output height at same scale 
#		newwidth=$(( $dvd_width * $image_height / $dvd_height ))
#		newheight=$image_height
#	fi
#	out_ratio=$(( 1000* $newwidth / $newheight ))  # this number is correct
	[ $debug -ge 3 ] && myecho "[dvd-slideshow:crop_parameters] input: x0=`todec000 $x0` y0=`todec000 $y0` x1=`todec000 $x1` y1=`todec000 $y1`     xi=$xi yi=$yi (dvd window)"
#	[ $debug -ge 3 ] && myecho "[dvd-slideshow:crop_parameters] width=$image_width height=$image_height new_width=$newwidth new_height=$newheight ratio=`todec000 $ratio` out_ratio=`todec000 $out_ratio`"

	##############################################
	## shift coordinate system to start at xi,yi: (all integers)
	## xi,yi should already include the border
	xi0=$(( $x0- 1000*$xi )); yi0=$(( $y0- 1000*$yi )) # already x1000
	xi1=$(( $x1- 1000*$xi )); yi1=$(( $y1- 1000*$yi )) # already x1000
	w=$(( $xi1 - $xi0 )) # already x1000
	h=$(( $yi1 - $yi0 ))	 # already x1000
#	out_ratio=$(( $w / $h )) ## should be same as before because coordinate system transformation preserves this.
#	[ $debug -ge 3 ] && myecho "[dvd-slideshow:crop_parameters] xi0,yi0=$xi0,$yi0 xi1,yi1=$xi1,$yi1   w=$w h=$h  ratio=$ratio out_ratio=$out_ratio"
	[ $debug -ge 3 ] && myecho "[dvd-slideshow:crop_parameters] xi0,yi0=`todec000 $xi0`,`todec000 $yi0` xi1,yi1=`todec000 $xi1`,`todec000 $yi1`   w=`todec000 $w` h=`todec000 $h`  ratio=`todec000 $ratio` out_ratio=`todec000 $out_ratio` (i=image ref frame)"

	##############################################
	## figure out where to crop the image:
	## (make sure the image crop coordinates are not outside the image)
	[ $xi0 -lt 0 ] && xc0=0 || xc0=$xi0 
	[ $xi1 -gt "$(( 1000 * $image_width ))" ] && xc1=$(( 1000 * $image_width )) || xc1=$xi1
	[ $yi0 -lt 0 ] && yc0=0 || yc0=$yi0
	[ $yi1 -gt "$(( 1000 * $image_height ))" ] && yc1=$(( 1000 * $image_height )) || yc1=$yi1
	c_width=$(( $xc1 - $xc0 )) ; c_height=$(( $yc1 - $yc0 )) # already x1000
	crop_ratio=$(( 1000 * $c_width / $c_height ))  
	[ $debug -ge 3 ] && myecho "[dvd-slideshow:crop_parameters] xc0,yc0=`todec000 $xc0`,`todec000 $yc0` xc1,yc1=`todec000 $xc1`,`todec000 $yc1`   c_width=`todec000 $c_width` c_height=`todec000 $c_height`   crop_ratio=$crop_ratio (crop params in image fr)"

	##############################################
	## where to put the top left corner of the cropped image relative to the background?
	deltax=$(( 1000 * 1000 * $frame_width / $c_width )); deltay=$(( 1000 * 1000 * $frame_height / $c_height ))
	## rescale % will be the smaller of the two deltas: 
	[ $deltax -lt $deltay ] && rescale=$deltax || rescale=$deltay # already x1000
# myecho "[dvd-slideshow:crop_parameters] deltax=$deltax deltay=$deltay rescale=$rescale xi0=$xi0 yi0=$yi0"
	if [ $xi0 -lt 0 ] ; then
		## left of cropped image is in the middle of the dvd window
#		xci=`div1000 $(( $rescale * -1 * $xi0 ))`
		xci=$(( $rescale * -1 * $xi0 / 1000 ))
		[ "$xci" -ge 1 ] && xci=$(( $xci - 1 ))
	else
		## left of cropped image should be at x=0 afterward
		xci=0
	fi
	if [ $yi0 -lt 0 ] ; then  ###*  rescale=deltax
		## top of cropped image is in the middle of the dvd window
#		yci=`div1000 $(( $rescale * -1 * $yi0 ))`
		yci=$(( $rescale * -1 * $yi0 / 1000 ))
		[ "$yci" -ge 1 ] && yci=$(( $yci - 1 ))
	else
		## top of cropped image should be at y=0 afterward
		yci=0
	fi
	[ $debug -ge 3 ] && myecho "[dvd-slideshow:crop_parameters] xci,yci=`todec000 $xci`,`todec000 $yci`  c_width,c_height=`todec000 $c_width`,`todec000 $c_height` (location of cropped image in dvd window)"

#		myecho "[dvd-slideshow:crop_parameters] predicted resized_width=$predicted_resized_width resized_height=$predicted_resized_height"
#	fi 

	c_width=`div1000 $(( $xc1 - $xc0 ))` ; c_height=`div1000 $(( $yc1 - $yc0 ))`

#	echo "[dvd-slideshow:crop_parameters] crop_ratio=$crop_ratio out_ratio=$out_ratio"
	if [ "$crop_ratio" -gt $out_ratio ] ; then
		# image width greater than output width at same scale
		resized_width=$(( 1000 * $frame_width ))
		resized_height=$(( 1000 * $c_height * $frame_width / $c_width ))
	elif [ "$crop_ratio" -lt $out_ratio ] ; then
		# image height greater than output height at same scale 
		resized_height=$(( 1000 * $frame_height ))
		resized_width=$(( 1000 * $c_width * $frame_height / $c_height ))
	else # crop_ratio = out_ratio.  good.
		resized_height=$(( 1000 * $frame_height ))
		resized_width=$(( 1000 * $frame_width ))
	fi
#	echo "predicted_resized_width=$( todec000 $resized_width ) predicted_resized_height=$( todec000 $resized_height )"
	predicted_resized_width=`div1000 $resized_width`
	predicted_resized_height=`div1000 $resized_height`
#	myecho "[dvd-slideshow:crop_parameters] resized_width=`todec000 $resized_width` resized_height=`todec000 $resized_height` diff=$diff"
#	myecho "[dvd-slideshow:crop_parameters] predicted resized_width=$predicted_resized_width resized_height=$predicted_resized_height"
	[ $debug -ge 3 ] && myecho "[dvd-slideshow:crop_parameters] output: xc0,yc0=$xc0,$yc0 xc1,yc1=$xc1,$yc1 c_width,c_height=$c_width,$c_height ratio=$crop_ratio $out_ratio  xci,yci=$xci,$yci"
	xc0_dec=`todec000 $xc0 | awk -F. '{print $2}'`
	yc0_dec=`todec000 $yc0 | awk -F. '{print $2}'`
	xc0_whole=$(( $xc0 / 1000 )); yc0_whole=$(( $yc0 / 1000 ))
#	xc0=`div1000 $xc0` ; yc0=`div1000 $yc0`  # rounding was causing problems... need to round down.
	xc0=$(( $xc0 / 1000 )) ; yc0=$(( $yc0 / 1000 ))
	xci=`div1000 $xci` ; yci=`div1000 $yci`  # rounding might cause problems.  watch this.
	## make sure xci + predicted_resized_width < dvd_width 
	## and yci + predicted_resized_height < dvd_height
	if [ $(( $yci + $predicted_resized_height )) -gt $frame_height ] ; then
		yci=$(( $yci - 1 ))
#		myecho "[dvd-slideshow:crop_parameters] Correcting yci - 1 "
	fi
	if [ $(( $xci + $predicted_resized_width )) -gt $frame_width ] ; then
		xci=$(( $xci - 1 ))
#		myecho "[dvd-slideshow:crop_parameters] Correcting xci - 1 "
	fi
#	w=`div1000 $w` ; h=`div1000 $h`
	[ $debug -ge 3 ] && myecho "[dvd-slideshow:crop_parameters] output: c_width,c_height=$c_width,$c_height ratio=$crop_ratio $out_ratio xc0,yc0=$xc0,$yc0 xci,yci=$xci,$yci"
	# used output is:
	# xc0,yc0 (coordinates of the top left corner of the image crop in the image frame)
	# c_width,c_height (crop width and height in the image frame)
	# xi0,yi0 (coordinates of where to put the top left corner of the image on the background)
}


mycrop ()
{
	# my crop function:  does all the cropping on the current image
	# using the parameters x0,y0 ; x1,y1 ; xi,yi in memory
	# output is just the crop parameters:
	# c_width, c_height xc0,yc0  (for the actual crop)
	# and:
	# xci,yci for the location of the top left corner of the cropped image
	# relative to the output window.
	# note that the c_width x c_height must maintain the correct aspect ratio,
	# so we need to round this appropriately so the image aspect ratio doesn't 
	# keep changing during the pan/zoom.

	## the input coordinates are relative to the original image size, buffered out to
	## the output frame aspect ratio
	
	## we need to convert the existing coordinates back to the actual image coordinates:
	## top left corner of dvd window is 0,0
	## top left corner of image is at xi,yi
	## top left corner of the cropped image is at x0,y0

	x_width=$(( $x1 - $x0 )) ; y_height=$(( $y1 - $y0 ))
	out_ratio=$(( 1000* $x_width / $y_height ))
	[ $debug -ge 3 ] && myecho "[dvd-slideshow:mycrop] mycrop input: x0=$x0 y0=$y0    x1=$x1 y1=$y1   xi=$xi yi=$yi (orig buffered image frame)"

	## figure out the size of the window scaled to the original image size:
	ratio=$(( 1000* $image_width / $image_height ))
	out_ratio=$(( 1000* $frame_width / $frame_height ))
	if [ "$ratio" -gt "$(( $out_ratio ))" ] ; then
		# image width greater than output width at same scale
		newwidth=$image_width
		newheight=$(( $frame_height * $image_width / $frame_width ))
	elif [ "$ratio" -le $(( $out_ratio )) ] ; then
		# image height greater than output height at same scale 
		newwidth=$(( $frame_width * $image_height / $frame_height ))
		newheight=$image_height
	fi
	out_ratio=$(( 1000* $newwidth / $newheight ))  # this number is correct
	[ $debug -ge 3 ] && myecho "[dvd-slideshow] frame_width=$newwidth frame_height=$newheight ratio=$out_ratio"

	## shift coordinate system to start at xi,yi:
	xi0=$(( $x0-$xi )); yi0=$(( $y0-$yi )) 
	xi1=$(( $x1-$xi )); yi1=$(( $y1-$yi )) 
	w=$(( $xi1 - $xi0 ))
	h=$(( $yi1 - $yi0 ))	
	out_ratio=$(( 1000* $w / $h )) ## should be same as before because coordinate system transformation preserves this.
	[ $debug -ge 3 ] && myecho "[dvd-slideshow:mycrop] image crop coordinates=$xi0,$yi0 ; $xi1,$yi1 w=$w h=$h ratio=$out_ratio"

	## make sure the image crop coordinates are not outside the image:
	[ $xi0 -lt 0 ] && xc0=0 || xc0=$xi0 
	[ $xi1 -gt $image_width ] && xc1=$image_width || xc1=$xi1
	[ $yi0 -lt 0 ] && yc0=0 || yc0=$yi0
	[ $yi1 -gt $image_height ] && yc1=$image_height || yc1=$yi1
	c_width=$(( $xc1 - $xc0 )) ; c_height=$(( $yc1 - $yc0 ))
	out_ratio=$(( 1000* $c_width / $c_height )) ## 
	[ $debug -ge 3 ] && myecho "[dvd-slideshow:mycrop] xc0=$xc0 yc0=$yc0 xc1=$xc1 yc1=$yc1 w=$w h=$h"

	## where to put the top left corner of the cropped image relative to the background?
	deltax=$(( 10000* $frame_width / $c_width )); deltay=$(( 10000* $frame_height / $c_height ))
	## rescale % will be the smaller of the two deltas:  10000 is to retain the resolution until dividing.
	[ $deltax -lt $deltay ] && rescale=$deltax || rescale=$deltay
	if [ $xi0 -lt 0 ] ; then
		## left of cropped image is in the middle of the dvd window
		xci=`div10 $(( $rescale * -1 * $xi0 / 1000 ))`
	else
		## left of cropped image should be at x=0 afterward
		xci=0
	fi
	if [ $yi0 -lt 0 ] ; then
		## top of cropped image is in the middle of the dvd window
		yci=`div10 $(( $rescale * -1 * $yi0 / 1000 ))`
	else
		## top of cropped image should be at y=0 afterward
		yci=0
	fi
	[ $debug -ge 3 ] && myecho "[dvd-slideshow:mycrop] xci=$xci yci=$yci"
}

kenburns ()  # KENBURNS
# Kenburns $window_start $window_end $file $total_frames $startframe $lastframe bg [$char]
{
		local l_window_start="$1"
		local l_window_end="$2"
		local l_file="$3"
		local l_frames="$4"
		lastbar=0 # required for progressbar to set back to zero
		[ -z "$5" ] && local l_startframe="1" || local l_startframe="$5"
		[ -z "$6" ] && local l_endframe="$l_frames" || local l_endframe="$6"
		[ -z "$7" ] && local bg="$normal_bg" || local bg="$7"
		[ -z "$8" ] && local c='#' || local c="$8"
		if [ "$bg" == "$transparent_bg" ] ; then
			local suffix='png'
		else
			local suffix='ppm'
		fi
		image_width="`imagewidth "$l_file"`"
		image_height="`imageheight "$l_file"`"
		parse_window "$l_window_start" "$l_file"
		xs0=$x0 ; ys0=$y0 ; xs1=$x1 ; ys1=$y1
		if [ -z $x0 ] || [ -z $y0 ] || [ -z $x1 ] || [ -z $y1 ] ; then
			myecho "[dvd-slideshow:kenburns] Error: No starting position found for kenburns effect"	
			myecho "[dvd-slideshow:kenburns] Example: "
			myecho "[dvd-slideshow:kenburns] image.jpg:duration:subtitle:kenburns:70%;topleft;75%;bottomright"	
			cleanup; exit 1
		fi
		parse_window "$l_window_end" "$l_file"
		xe0=$x0 ; ye0=$y0 ; xe1=$x1 ; ye1=$y1
		if [ -z $x0 ] || [ -z $y0 ] || [ -z $x1 ] || [ -z $y1 ] ; then
			myecho "[dvd-slideshow:kenburns] Error: No ending position found for kenburns effect"	
			myecho "[dvd-slideshow:kenburns] Example: "
			myecho "[dvd-slideshow:kenburns] image.jpg:duration:subtitle:kenburns:70%;topleft;75%;bottomright"	
			cleanup; exit 1
		fi
		if [ $xs0 -eq $xe0 ] && [ $ys0 -eq $ye0 ] && [ $xs1 -eq $xe1 ] && [ $ys1 -eq $ye1 ] ; then
			# start and end are the same!
			myecho "[dvd-slideshow:kenburns] WARNING: Start and end of kenburns effect are the same!"	
			myecho "[dvd-slideshow:kenburns] Use crop and it will be MUCH faster!"
		fi

		#### now we have the parameters set up.  The coordinate system is relative to the 
		#### ORIGINAL image size, buffered out to the full DVD frame:
		# xi,yi   xw,yh  xs0,ys0  xs1,ys1  xe0,ye0  xe1,ye1

		s_width=$(( $xs1 - $xs0 )) ; s_height=$(( $ys1 - $ys0 ))
		e_width=$(( $xe1 - $xe0 )) ; e_height=$(( $ye1 - $ye0 ))
		[ $debug -ge 2 ] && myecho "[dvd-slideshow:kenburns] Coordinate system is original image size buffered out to dvd aspect ratio"
		[ $debug -ge 2 ] && myecho "[dvd-slideshow:kenburns] and then rescaled to non-square pixels"
		[ $debug -ge 2 ] && myecho "[dvd-slideshow:kenburns] Start: width=$s_width height=$s_height  $xs0,$ys0 : $xs1,$ys1"
		[ $debug -ge 2 ] && myecho "[dvd-slideshow:kenburns] End:   width=$e_width height=$e_height  $xe0,$ye0 : $xe1,$ye1"
		[ $debug -ge 2 ] && myecho "[dvd-slideshow:kenburns] Image top left corner:   xi=$xi yi=$yi"

		##################################################################
		## so if we're using only 50% of the image, we can pre-crop the image before the
		## main loop to save some processing time...
		## get smallest size of image during effect to know how to rescale:
                min_width=`min $s_width $e_width`
                min_height=`min $s_height $e_height`
		xc0=`min $xs0 $xe0`; xc1=`max $xs1 $xe1`	
		yc0=`min $ys0 $ye0`; yc1=`max $ys1 $ye1`	
		## (make sure the image crop coordinates are not outside the image)
		[ $xc0 -lt $xi ] && xc0=0 || xc0=$(( $xc0 - $xi ))
		[ $yc0 -lt $yi ] && yc0=0 || yc0=$(( $yc0 - $yi ))
		[ $xc1 -gt $(( $xi + $image_width )) ] && xc1=$image_width || xc1=$(( $xc1 - $xi ))
		[ $yc1 -gt $(( $yi + $image_height )) ] && yc1=$image_height || yc1=$(( $yc1 - $yi ))
		c_width=$(( $xc1 - $xc0 )) ; c_height=$(( $yc1 - $yc0 ))
                [ $debug -ge 2 ] && myecho "[dvd-slideshow:kenburns] Smallest window during kenburns is $min_width x $min_height"
		[ $debug -ge 2 ] && myecho "[dvd-slideshow:kenburns] Pan/zoom uses $c_width x $c_height of original $image_width x $image_height image"
		did_resize=0

		convert "$l_file" -resize "$sq_to_dvd_pixels" +repage $sharpen -type TrueColor -depth 8 "$tmpdir"/temp_slideshow_image_scaled.mpc

		############################ end crop/resize large images

		## adjust step size: ##############################
		if [ "$low_quality" -eq 1 ] ; then
			stepsize=3
			interp=0
		elif [ "$high_quality" -eq 1 ] ; then
			stepsize=1
			interp=1
		else
			stepsize=1
			interp=0  # fix this for now?
		fi
#		echo 'x0,y0,x1,y1,xcenter,ycenter,xwidth,yheight,xc0,yc0,c_width,c_height' > kenburns_coordinates.csv
#		echo 'xc0,yc0,c_width,c_height,xci,yci,iwn,ihn,predicted_resized_width,predicted_resized_height,xc0_dec,yc0_dec' > kenburns_coordinates.csv
#		echo 'xc0,yc0,c_width,c_height,xci,yci,predicted_resized_width,predicted_resized_height' > kenburns_coordinates.csv
#echo "xs0=$xs0 xe0=$xe0    ys0=$ys0 ye0=$ye0"
#echo "xs1=$xs1 xe1=$xe1    ys1=$ys1 ye1=$ye1"
#		if [ $xe0 -gt $xs0 ] ; then
			xvelocity0=$(( 1000 * ($xe0-$xs0)*($xe0-$xs0) / $l_frames ))
			xvelocity1=$(( 1000 * ($xe1-$xs1)*($xe1-$xs1) / $l_frames ))
			xvelocity=$(( ( $xvelocity0 + $xvelocity1 ) / 1000 ))
#echo "xvelocity0=$xvelocity0  xvelocity1=$xvelocity1"
#		else
#			xvelocity=$(( 1000 * ($xs0-$xe0) / $l_frames ))
#		fi
#		if [ $ye0 -gt $ys0 ] ; then
			yvelocity0=$(( 1000 * ($ye0-$ys0)*($ye0-$ys0) / $l_frames ))
			yvelocity1=$(( 1000 * ($ye1-$ys1)*($ye1-$ys1) / $l_frames ))
			yvelocity=$(( ( $yvelocity0 + $yvelocity1 ) / 1000 ))
#echo "yvelocity0=$yvelocity0  yvelocity1=$yvelocity1"
#		else
#			yvelocity=$(( 1000 * ($ys0-$ye0) / $l_frames ))
#		fi
		if [ "$interp" -eq 1 ] && [ "$xvelocity" -eq 0 ] && [ "$yvelocity" -lt 4000 ] ; then
			[ $debug -ge 1 ] && echo "[dvd-slideshow:kenburns] Using interpolation. Velocity=$xvelocity $yvelocity"
		elif [ "$interp" -eq 1 ] && [ "$yvelocity" -eq 0 ] && [ "$xvelocity" -lt 4000 ] ; then
			[ $debug -ge 1 ] && echo "[dvd-slideshow:kenburns] Using interpolation. Velocity=$xvelocity $yvelocity"
		elif [ "$interp" -eq 1 ] && [ "$xvelocity" -lt 5000 -a "$yvelocity" -lt 4000 ] ; then
			[ $debug -ge 1 ] && echo "[dvd-slideshow:kenburns] Using interpolation. Velocity=$xvelocity $yvelocity"
		elif [ "$interp" -eq 1 ] ; then
			[ $debug -ge 1 ] && echo "[dvd-slideshow:kenburns] Disabling high-quality mode for fast effect. Velocity=$xvelocity $yvelocity"
			interp=0
		fi
		
		## smooth start and end parameters:
		smoothing=1  # (old method before 0.8.0)
		if [ "$kenburns_acceleration" == '0' ] ; then
			# do not use smoothing, or set it to a very small number
			F_time=0  # seconds for sinusoidal start
			F1=1
			D1x0=0; D1y0=0; D1x1=0; D1y1=0 # distance gone so far
		elif [ $( echo "$kenburns_acceleration" | awk -F% '{print NF}' ) -gt 1 ] ; then
#			myecho "using kb percent syntax"
			kb_acceleration_percent=$( echo "$kenburns_acceleration" | awk -F% '{print $1}' )
			F1=$(( $l_frames * $kb_acceleration_percent / 100 ))
		else
			F1=$( echo "scale=0; $kenburns_acceleration * $frames_per_ms / 1000" | bc )
			F1=$( printf %2.0f $F1 )
		fi
		# make sure the acceleration time is shorter than half of the full kenburns time:
		if [ "$F1" -gt "$(( $l_frames / 2 ))" ] ; then
			myecho "[dvd-slideshow] Warning: kenburns acceleration time is longer than kenburns time"
			myecho "[dvd-slideshow]		 Setting acceleration time to $F1 frames"
			F1=$(( $l_frames / 2 ))
		fi
		F2=$(( $l_frames - $F1 ))	
		V0x=$( echo "scale=9; 2 * ( $xe0 - $xs0 ) / ( $l_frames + $F2 - $F1 )" | bc ) 
		V0y=$( echo "scale=9; 2 * ( $ye0 - $ys0 ) / ( $l_frames + $F2 - $F1 )" | bc )
		V1x=$( echo "scale=9; 2 * ( $xe1 - $xs1 ) / ( $l_frames + $F2 - $F1 )" | bc ) 
		V1y=$( echo "scale=9; 2 * ( $ye1 - $ys1 ) / ( $l_frames + $F2 - $F1 )" | bc )
#		echo "F1=$F1 F2=$F2 V0x=$V0x V0y=$V0y"
		pi='3.14159265'
		## start loop for kenburns effect: #################################
		echo -n  "[dvd-slideshow]"
		for (( fr=l_startframe ; fr<=l_endframe ; fr=fr+stepsize )) ; do
#			echo "fr=$fr startframe=$l_startframe endframe=$l_endframe"
			dj=`addzeros $fr`
			if [ $fr -le $F1 ] && [ $smoothing -eq 1 ] ; then   # inputs are relatively simple:  make function?
				# region 1
				x0=$( echo "scale=3; 1000* $xs0 + 1000* $V0x/2 *($fr - $F1/$pi *s($pi*$fr/$F1))" | bc -l )
				y0=$( echo "scale=3; 1000* $ys0 + 1000* $V0y/2 *($fr - $F1/$pi *s($pi*$fr/$F1))" | bc -l )
				x1=$( echo "scale=3; 1000* $xs1 + 1000* $V1x/2 *($fr - $F1/$pi *s($pi*$fr/$F1))" | bc -l )
				y1=$( echo "scale=3; 1000* $ys1 + 1000* $V1y/2 *($fr - $F1/$pi *s($pi*$fr/$F1))" | bc -l )
				D1x0=$x0; D1y0=$y0; D1x1=$x1; D1y1=$y1 # distance gone so far
				D2x0=$x0 ; D2y0=$y0 ; D2x1=$x1 ; D2y1=$y1  # (in case we never get to region2)
				## Fix numbers without leading zeros:
				it=`printf %3f "$x0" | awk -F. '{print $1}'` ; [ -z "$it" ] && x0_whole=0 || x0_whole="$it"
				it=`printf %3f "$y0" | awk -F. '{print $1}'` ; [ -z "$it" ] && y0_whole=0 || y0_whole="$it"
				it=`printf %3f "$x1" | awk -F. '{print $1}'` ; [ -z "$it" ] && x1_whole=0 || x1_whole="$it"
				it=`printf %3f "$y1" | awk -F. '{print $1}'` ; [ -z "$it" ] && y1_whole=0 || y1_whole="$it"
				x0_dec=$( echo $( printf %3.3f $( echo "scale=3; $x0 / 1000" | bc ) ) | awk -F. '{print "0."$2}')
				y0_dec=$( echo $( printf %3.3f $( echo "scale=3; $y0 / 1000" | bc ) ) | awk -F. '{print "0."$2}')
				x1_dec=$( echo $( printf %3.3f $( echo "scale=3; $x1 / 1000" | bc ) ) | awk -F. '{print "0."$2}')
				y1_dec=$( echo $( printf %3.3f $( echo "scale=3; $y1 / 1000" | bc ) ) | awk -F. '{print "0."$2}')
				x0=$x0_whole ; y0=$y0_whole
				x1=$x1_whole ; y1=$y1_whole
				## now, round the results for normal mode:
				[ $debug -ge 2 ] && myecho "[dvd-slideshow:kenburns] $fr x0=$x0_whole.$x0_dec y0=$y0_whole.$y0_dec x0=$x0 y0=$y0 region 1"
			elif [ $fr -ge $(( $F2 + 1 )) ] && [ $smoothing -eq 1 ] ; then
				# region 3
#				echo "D2x0=$D2x0 V0x=$V0x fr=$fr F2=$F2 l_frames=$l_frames pi=$pi"
				x0=$( echo "scale=3; $D2x0 + 1000* $V0x/2 *( ($fr-$F2) + ($l_frames-$F2)/$pi*s(($fr-$F2)*$pi/($l_frames-$F2)) )" | bc -l )
				y0=$( echo "scale=3; $D2y0 + 1000* $V0y/2 *( ($fr-$F2) + ($l_frames-$F2)/$pi*s(($fr-$F2)*$pi/($l_frames-$F2)) )" | bc -l )
				x1=$( echo "scale=3; $D2x1 + 1000* $V1x/2 *( ($fr-$F2) + ($l_frames-$F2)/$pi*s(($fr-$F2)*$pi/($l_frames-$F2)) )" | bc -l )
				y1=$( echo "scale=3; $D2y1 + 1000* $V1y/2 *( ($fr-$F2) + ($l_frames-$F2)/$pi*s(($fr-$F2)*$pi/($l_frames-$F2)) )" | bc -l )
				[ $debug -ge 2 ] && myecho "[dvd-slideshow:kenburns] $fr x0=$x0 y0=$y0 region 3"
				x0_dec=$( echo $( printf %3.3f $( echo "scale=3; $x0 / 1000" | bc ) ) | awk -F. '{print "0."$2}')
				y0_dec=$( echo $( printf %3.3f $( echo "scale=3; $y0 / 1000" | bc ) ) | awk -F. '{print "0."$2}')
				x1_dec=$( echo $( printf %3.3f $( echo "scale=3; $x1 / 1000" | bc ) ) | awk -F. '{print "0."$2}')
				y1_dec=$( echo $( printf %3.3f $( echo "scale=3; $y1 / 1000" | bc ) ) | awk -F. '{print "0."$2}')
				## Fix numbers without leading zeros:
				it=`printf %3f "$x0" | awk -F. '{print $1}'` ; [ -z "$it" ] && x0_whole=0 || x0_whole="$it"
				it=`printf %3f "$y0" | awk -F. '{print $1}'` ; [ -z "$it" ] && y0_whole=0 || y0_whole="$it"
				it=`printf %3f "$x1" | awk -F. '{print $1}'` ; [ -z "$it" ] && x1_whole=0 || x1_whole="$it"
				it=`printf %3f "$y1" | awk -F. '{print $1}'` ; [ -z "$it" ] && y1_whole=0 || y1_whole="$it"
				x0=$x0_whole ; y0=$y0_whole
				x1=$x1_whole ; y1=$y1_whole
			elif [ $smoothing -eq 1 ] ; then
				# middle region 2
				x0=$( echo "scale=3; $D1x0 + 1000* $V0x*($fr-$F1)" | bc )
				y0=$( echo "scale=3; $D1y0 + 1000* $V0y*($fr-$F1)" | bc )
				x1=$( echo "scale=3; $D1x1 + 1000* $V1x*($fr-$F1)" | bc )
				y1=$( echo "scale=3; $D1y1 + 1000* $V1y*($fr-$F1)" | bc )
				D2x0=$x0 ; D2y0=$y0 ; D2x1=$x1 ; D2y1=$y1  # distance gone so far
				[ $debug -ge 2 ] && myecho "[dvd-slideshow:kenburns] $fr x0=$x0 y0=$y0 region 2"
				x0_dec=$( echo $( printf %3.3f $( echo "scale=3; $x0 / 1000" | bc ) ) | awk -F. '{print "0."$2}')
				y0_dec=$( echo $( printf %3.3f $( echo "scale=3; $y0 / 1000" | bc ) ) | awk -F. '{print "0."$2}')
				x1_dec=$( echo $( printf %3.3f $( echo "scale=3; $x1 / 1000" | bc ) ) | awk -F. '{print "0."$2}')
				y1_dec=$( echo $( printf %3.3f $( echo "scale=3; $y1 / 1000" | bc ) ) | awk -F. '{print "0."$2}')

				## Fix numbers without leading zeros:
				it=`printf %3f "$x0" | awk -F. '{print $1}'` ; [ -z "$it" ] && x0_whole=0 || x0_whole="$it"
				it=`printf %3f "$y0" | awk -F. '{print $1}'` ; [ -z "$it" ] && y0_whole=0 || y0_whole="$it"
				it=`printf %3f "$x1" | awk -F. '{print $1}'` ; [ -z "$it" ] && x1_whole=0 || x1_whole="$it"
				it=`printf %3f "$y1" | awk -F. '{print $1}'` ; [ -z "$it" ] && y1_whole=0 || y1_whole="$it"
				x0=$x0_whole ; y0=$y0_whole
				x1=$x1_whole ; y1=$y1_whole
			else
				echo "old method"
				## old method:
				if [ "$s_height" -eq "$e_height" ] ; then
					logfactor=$( echo "scale=3; 1000 * $fr / $l_frames" | bc )
				else
					logfactor=$( echo "l( 1- $fr / $l_frames * ( 1 - $s_height / $e_height ) ) / l( $s_height / $e_height) * 1000 " | bc -l )
				fi
				[ -z `echo $logfactor | awk -F. '{print $1}'` ] && logfactor=0$logfactor
	#			frl_frames_linear=$(( 1000 * $fr / $l_frames ))
		                x0=$( echo "scale=3; 1000 * $xs0 + ($xe0-$xs0) * $logfactor" | bc )
		                y0=$( echo "scale=3; 1000 * $ys0 + ($ye0-$ys0) * $logfactor" | bc )
		                x1=$( echo "scale=3; 1000 * $xs1 + ($xe1-$xs1) * $logfactor" | bc )
		                y1=$( echo "scale=3; 1000 * $ys1 + ($ye1-$ys1) * $logfactor" | bc )
		                ## need to round the numbers for bash:
		                ## these are the "whole" integer portion of the number:
		                it=`printf %3f "$x0" | awk -F. '{print $1}'` ; [ -z "$it" ] && x0=0 || x0="$it"
		                it=`printf %3f "$y0" | awk -F. '{print $1}'` ; [ -z "$it" ] && y0=0 || y0="$it"
		                it=`printf %3f "$x1" | awk -F. '{print $1}'` ; [ -z "$it" ] && x1=0 || x1="$it"
		                it=`printf %3f "$y1" | awk -F. '{print $1}'` ; [ -z "$it" ] && y1=0 || y1="$it"
			fi

#			[ "$x1" -eq 0 ] && x1="+0"
#			[ "$y1" -eq 0 ] && y1="+0"
#			[ "$x1" -gt 0 ] && x1="+$x1"
#			[ "$y1" -gt 0 ] && y1="+$y1"

###########################

#			myecho "x0=$x0 y0=$y0 x1=$x1 y1=$y1 logfactor=$logfactor"
#			myecho "x0=$x0 y0=$y0 x1=$x1 y1=$y1 "
			## now optionally do convolution if high-quality is enabled:
			if [ "$interp" -eq 1 ] ; then
#				myecho "$fr x0=$x0 x0_dec=$x0_dec y0=$y0 y0_dec=$y0_dec logfactor=$logfactor"
				## now, we're going to calculate the following parameters:
				# calculate subpixel-averaging weights:
	                        Afactor=$( echo "scale=3; 100*(1-$x0_dec)*(1-$y0_dec)" | bc )
	                        Bfactor=$( echo "scale=3; 100*($x0_dec)*(1-$y0_dec)" | bc )
	                        Cfactor=$( echo "scale=3; 100*(1-$x0_dec)*($y0_dec)" | bc )
	                        Dfactor=$( echo "scale=3; 100*($x0_dec)*($y0_dec)" | bc )
	                        Afactor=`printf %3.0f $Afactor | tr -d \[:blank:\]`
	                        Bfactor=`printf %3.0f $Bfactor | tr -d \[:blank:\]`
	                        Cfactor=`printf %3.0f $Cfactor | tr -d \[:blank:\]`
	                        Dfactor=`printf %3.0f $Dfactor | tr -d \[:blank:\]`
				convolve="-convolve 0,0,0,0,$Afactor,$Bfactor,0,$Cfactor,$Dfactor"
	                        [ "$debug" -ge 2 ] && myecho "[dvd-slideshow:kenburns] $fr Af=$Afactor Bf=$Bfactor Cf=$Cfactor Df=$Dfactor"
			else
				convolve="-filter cubic"
			fi

			crop_parameters # figure out final crop parameters  
#			myecho "$fr x0=$x0 x0_dec=$x0_dec y0=$y0 y0_dec=$y0_dec logfactor=$logfactor"
#			myecho "$fr x0=$x0 x0_dec=$x0_dec y0=$y0 y0_dec=$y0_dec "
			# outputs correct predicted_resized_width and predicted_resized_height

#			echo '$xc0,$yc0,$c_width,$c_height,$xci,$yci,$iwn,$ihn,$predicted_resized_width,$predicted_resized_height,$xc0_dec,$yc0_dec' >> kenburns_coordinates.csv
#			echo "$xc0,$yc0,$c_width,$c_height,$xci,$yci,$predicted_resized_width,$predicted_resized_height" >> kenburns_coordinates.csv

			[ $debug -ge 2 ] && myecho "[dvd-slideshow:kenburns] $fr xc0,yc0=$xc0_whole.$xc0_dec,$yc0_whole.$yc0_dec cw,ch=$c_width,$c_height xci,yci=$xci,$yci"
#			[ $debug -ge 2 ] && myecho "[dvd-slideshow:kenburns] $fr xc0,yc0=$xc0,$yc0 cw,ch=$c_width,$c_height xci,yci=$xci,$yci"
#			i_width=$predicted_resized_width; i_height=$predicted_resized_height

			delta_width=$(( $dvd_width - $predicted_resized_width ))
			delta_height=$(( $dvd_height - $predicted_resized_height ))
			[ $debug -ge 2 ] && myecho "[dvd-slideshow:kenburns] frame_width=$frame_width frame_height=$frame_height"
			[ $debug -ge 2 ] && myecho "[dvd-slideshow:kenburns] predicted_resized_width=$predicted_resized_width predicted_resized_height=$predicted_resized_height"
			[ $debug -ge 2 ] && myecho "[dvd-slideshow:kenburns] delta_width=$delta_width delta_height=$delta_height"
			if [ $delta_width -le 1 ] && [ $delta_height -le 1 ] && [ "$frame_border" -eq 0 ] ; then
#				echo "[dvd-slideshow:kenburns: delta_width=$delta_width delta_height=$delta_height"
				# force the output size to be exact:  no composite needed!
				if [ "$smp" -eq 1 ] ; then
					[ $debug -ge 3 ] && echo "deltawh<1 smp=1"
					(convert "$tmpdir"/temp_slideshow_image_scaled.mpc -crop "$c_width"x"$c_height"+"$xc0"+"$yc0" +repage -type TrueColor -depth 8 $convolve -resize "$dvd_width"x"$dvd_height"! "$tmpdir"/fade_"$dj.$suffix"  ; extracopies $fr $l_frames $suffix ) &
				elif [ "$smp" -eq 0 ] ; then
					[ $debug -ge 3 ] && echo "deltawh<1 smp=0"
					convert "$tmpdir"/temp_slideshow_image_scaled.mpc -crop "$c_width"x"$c_height"+"$xc0"+"$yc0" +repage -type TrueColor -depth 8 $convolve -resize "$dvd_width"x"$dvd_height"! "$tmpdir/fade_$dj.$suffix"  ; extracopies $fr $l_frames $suffix
				fi
			elif [ $bgfile == 'black' ] ; then
				# calculate border size for possible speed improvement:
				# splice in black background if we can for better speed!
				# split the difference between the two sides. If odd, add extra
				# to bottom right?
				left=$(( $xci + $frame_border )); right=$(( $delta_width - $left ))
				[ "$right" -lt 0 ] && left=$(( $left + $right )) 
				[ "$right" -lt 0 ] && right=0
				top=$(( $yci + $frame_border )) ; bottom=$(( $delta_height - $top ))
				[ "$bottom" -lt 0 ] && top=$(( $top + $bottom )) 
				[ "$bottom" -lt 0 ] && bottom=0
	                        [ $debug -ge 2 ] && myecho "[dvd-slideshow:kenburns] left=$left right=$right top=$top bottom=$bottom delta_w=$delta_width delta_h=$delta_height"
#				if [ "$smp" -eq 1 ] ; then
					[ $debug -ge 3 ] && echo "deltawh>1 bg=black"
					convert "$tmpdir"/temp_slideshow_image_scaled.mpc -crop "$c_width"x"$c_height"+"$xc0"+"$yc0" +repage -type TrueColor -depth 8 $convolve -resize "$frame_width"x"$frame_height" "$tmpdir"/mytemp.$suffix 
					# now, get size of resized image because of roundoff errors:
					# need to get this correct in the future so we can run this in smp mode!
					resized_width=$( imagewidth_sq "$tmpdir"/mytemp.$suffix )
					resized_height=$( imageheight "$tmpdir"/mytemp.$suffix )
#					if [ "$resized_width" != "$predicted_resized_width" ] || [ "$resized_height" != "$predicted_resized_height" ] ; then
#						echo "resized_width=$resized_width : $predicted_resized_width resized_height=$resized_height : $predicted_resized_height"
#					fi
					delta_width=$(( $dvd_width - $resized_width ))
					delta_height=$(( $dvd_height - $resized_height ))
					left=$(( $xci + $frame_border )); right=$(( $delta_width - $left ))
					top=$(( $yci + $frame_border )) ; bottom=$(( $delta_height - $top ))
	                        	[ $debug -ge 3 ] && myecho "[dvd-slideshow:kenburns] left=$left right=$right top=$top bottom=$bottom delta_w=$delta_width delta_h=$delta_height"
					[ "$right" -lt 0 ] && left=$(( $left + $right )) 
					[ "$right" -lt 0 ] && right=0
					[ "$bottom" -lt 0 ] && top=$(( $top + $bottom )) 
					[ "$bottom" -lt 0 ] && bottom=0
	                        	[ $debug -ge 3 ] && myecho "[dvd-slideshow:kenburns] left=$left right=$right top=$top bottom=$bottom delta_w=$delta_width delta_h=$delta_height"
					convert "$tmpdir"/mytemp.$suffix -background black -splice "$right"x"$bottom"+$resized_width+$resized_height -splice "$left"x"$top" +repage -type TrueColor -depth 8 "$tmpdir/fade_$dj.$suffix" ; rm "$tmpdir"/mytemp.$suffix ; extracopies $fr $l_frames $suffix

					# works with imagemagick > 6.0.6  (convert "$tmpdir/temp_slideshow_image_scaled.mpc" -crop "$c_width"x"$c_height"+$xc0+$yc0 +repage -resize "$dvd_width"x"$dvd_height" -bordercolor black -compose src-over -border 0 -background black -splice "$right"x"$bottom"+$i_width+$i_height -splice "$left"x"$top" -type TrueColor -depth 8 "$tmpdir/fade_$dj.ppm" ; extracopies $fr $l_frames )
#				fi
			else   # need to composite over background image:
				if [ "$smp" -eq 1 ] ; then
					[ $debug -ge 3 ] && echo "deltawh>1 bg=image smp=1"
					(convert "$tmpdir"/temp_slideshow_image_scaled.mpc -crop "$c_width"x"$c_height"+"$xc0"+"$yc0" +repage -type TrueColor -depth 8 $convolve -resize "$frame_width"x"$frame_height" miff:- | composite -compose src-over -geometry "+$(( $xci + $frame_border ))+$(( $yci + $frame_border ))" -type TrueColor -depth 8 - "$normal_bg" "$tmpdir/fade_$dj.$suffix" ; extracopies $fr $l_frames $suffix ) & 
				else
					[ $debug -ge 3 ] && echo "deltawh>1 bg=image smp=0"
					(convert "$tmpdir"/temp_slideshow_image_scaled.mpc -crop "$c_width"x"$c_height"+"$xc0"+"$yc0" +repage -type TrueColor -depth 8 $convolve -resize "$frame_width"x"$frame_height" miff:- | composite -compose src-over -geometry "+$(( $xci + $frame_border ))+$(( $yci + $frame_border ))" -type TrueColor -depth 8 - "$normal_bg" "$tmpdir/fade_$dj.$suffix" ; extracopies $fr $l_frames $suffix ) 
				fi
			fi
# this next line only works for non-smp! (since file must exist first)
#			[ $debug -ge 2 ] && echo "width=`imagewidth_sq "$tmpdir/fade_$dj.$suffix"` height=`imageheight "$tmpdir/fade_$dj.$suffix"`"
			progressbar $(( $fr - $l_startframe +1 )) $(( $l_endframe - $l_startframe + 1 )) "$c"
		done
		[ $debug -ge 2 ] && myecho "[dvd-slideshow:kenburns] waiting for files suffix=$suffix end=$dj start=$l_startframe"
		waitforfiles "$tmpdir/fade" $suffix $dj $l_startframe
		finish_progressbar $(( $fr - $l_startframe +1 )) $(( $l_endframe - $l_startframe + 1 )) "$c"
}

wavlength ()
# wavlength $file 
# returns song length in ms
{
		sox "$1" -e stat 2> "$tmpdir"/trash.txt 
		song_length=`cat "$tmpdir"/trash.txt | grep 'Length (seconds):' | awk -F: '{print $2}' | tr -d \[:blank:\]`
		song_length_seconds=`echo $song_length | awk -F. '{print $1}'`
		if [ -z "$song_length_seconds" ] ; then song_length_seconds=0 ; fi
		song_length_ms=`echo $song_length | awk -F. '{printf ("%3.3f",$0)}' | awk -F. '{print $2}'`
		## make sure we have two decimal places?
		if [ -z "$song_length_ms" ] ; then song_length_ms=0 ; fi
		song_length=$( echo "scale=0; 1000 * $song_length_seconds + $song_length_ms" | bc )
		rm "$tmpdir"/trash.txt
		echo "$song_length"
}

rawlength ()
{
		sox -t raw -r $audio_sample_rate -w -s -c 2 "$1" -e stat 2> "$tmpdir"/trash.txt 
		song_length=`cat "$tmpdir"/trash.txt | grep 'Length (seconds):' | awk -F: '{print $2}' | tr -d \[:blank:\]`
		song_length_seconds=`echo $song_length | awk -F. '{print $1}'`
		if [ -z "$song_length_seconds" ] ; then song_length_seconds=0 ; fi
		song_length_ms=`echo $song_length | awk -F. '{printf ("%3.3f",$0)}' | awk -F. '{print $2}'`
		## make sure we have two decimal places?
		if [ -z "$song_length_ms" ] ; then song_length_ms=0 ; fi
		song_length=$( echo "scale=0; 1000 * $song_length_seconds + $song_length_ms" | bc )
		rm "$tmpdir"/trash.txt
		echo "$song_length"
}

progressbar ()
# progressbar $fr $frames $character #finish?
{
	## display progress bar as frame $fr progresses to $frames
	local fr=$1 ; local frames=$2
	[ -z "$3" ] && local c='#' || local c="$3"
	[ -z "$4" ] && local finish=0 || local finish="$4"
	local thisbar=$(( $fr * 59 / $frames  ))
#echo "finish=$finish thisbar=$thisbar"
#	echo "fr=$fr frames=$frames delta=$delta"
	if [ "$finish" -eq 0 ] && [ "$thisbar" -gt "$lastbar" ] ; then
		delta=$(( $thisbar - $lastbar ))
#	echo "finish=$finish fr=$fr frames=$frames delta=$delta"
		if [ "$delta" -eq 1 ] ; then 
			echo -n "$c"
		elif [ "$delta" -eq 2 ] ; then
			echo -n "$c$c"
		elif [ "$delta" -eq 3 ] ; then
			echo -n "$c$c$c"
		elif [ "$delta" -eq 4 ] ; then
			echo -n "$c$c$c$c"
		elif [ "$delta" -eq 5 ] ; then
			echo -n "$c$c$c$c$c"
		elif [ "$delta" -eq 6 ] ; then
			echo -n "$c$c$c$c$c$c"
		elif [ "$delta" -eq 7 ] ; then
			echo -n "$c$c$c$c$c$c$c"
		elif [ "$delta" -eq 8 ] ; then
			echo -n "$c$c$c$c$c$c$c$c"
		elif [ "$delta" -eq 9 ] ; then
			echo -n "$c$c$c$c$c$c$c$c$c"
		else 
			echo -n "$c$c$c$c$c$c$c$c$c$c"
		fi
		lastbar="$thisbar"
	elif [ "$finish" -eq 1 ] && [ "$thisbar" -le 60 ] ; then
		delta=$(( 60 - $thisbar ))
#	echo "finish=$finish fr=$fr frames=$frames delta=$delta"
		if [ "$delta" -le 0 ] ; then 
			echo ""
		elif [ "$delta" -eq 1 ] ; then 
			echo "$c"
		elif [ "$delta" -eq 2 ] ; then
			echo "$c$c"
		elif [ "$delta" -eq 3 ] ; then
			echo "$c$c$c"
		elif [ "$delta" -eq 4 ] ; then
			echo "$c$c$c$c"
		elif [ "$delta" -eq 5 ] ; then
			echo "$c$c$c$c$c"
		elif [ "$delta" -eq 6 ] ; then
			echo "$c$c$c$c$c$c"
		elif [ "$delta" -eq 7 ] ; then
			echo "$c$c$c$c$c$c$c"
		elif [ "$delta" -eq 8 ] ; then
			echo "$c$c$c$c$c$c$c$c"
		elif [ "$delta" -eq 9 ] ; then
			echo "$c$c$c$c$c$c$c$c$c"
		else 
			echo "$c$c$c$c$c$c$c$c$c$c"
		fi
		logecho "[dvd-slideshow]############################################################"
	fi
}

finish_progressbar ()
# finish_progressbar  $fr $frames $char
{
	local fr=$1 ; local frames=$2
	if [ -z "$3" ] ; then
		local c='#'
	else
		local c="$3"
	fi
	local thisbar=$(( $fr * 59 / $frames  ))
	if [ "$thisbar" -lt 60 ] ; then
		delta=$(( 60 - $thisbar ))
		if [ "$delta" -eq 1 ] ; then 
			echo "$c"
		elif [ "$delta" -eq 2 ] ; then
			echo "$c$c"
		elif [ "$delta" -eq 3 ] ; then
			echo "$c$c$c"
		elif [ "$delta" -eq 4 ] ; then
			echo "$c$c$c$c"
		elif [ "$delta" -eq 5 ] ; then
			echo "$c$c$c$c$c"
		elif [ "$delta" -eq 6 ] ; then
			echo "$c$c$c$c$c$c"
		elif [ "$delta" -eq 7 ] ; then
			echo "$c$c$c$c$c$c$c"
		elif [ "$delta" -eq 8 ] ; then
			echo "$c$c$c$c$c$c$c$c"
		elif [ "$delta" -eq 9 ] ; then
			echo "$c$c$c$c$c$c$c$c$c"
		else 
			echo "$c$c$c$c$c$c$c$c$c$c"
		fi
	else
		echo ""
	fi
	logecho "[dvd-slideshow]############################################################"
}

set_system_variables ()
{
	## check for config variables: only specified once per slideshow
	config=`echo "$1" | cut -d= -f1 | tr -d \[:blank:\]`
	config2=`echo "$1" | tr '\t' ' ' | tr -d '\047' | tr -d '\042' | cut -d= -f2 | awk -F' #' '{print $1}' | tr -d \[:blank:\]`
#	config2=`echo "$1" | cut -d= -f2 | awk -F' #' '{print $1}' | tr -d \[:blank:\]`
	[ -n "$2" -a "$2" == 1 ] && noecho=1 || noecho=0
	## check for global configuration variables:
	case "$config" in 
		pal) pal="$config2" ; [ "$noecho" -eq 0 ] && echo "pal=$pal" ;;
		ac3) ac3="$config2" ; [ "$noecho" -eq 0 ] && echo "ac3=$ac3" ;;
		copy) copy="$config2" ; [ "$noecho" -eq 0 ] && echo "copy=$copy" ;;
		autocrop) autocrop="$config2" ; [ "$noecho" -eq 0 ] && echo "autocrop=$autocrop" ;;
		high_quality) high_quality="$config2" ; [ "$noecho" -eq 0 ] && echo "high_quality=$high_quality" ;;
		title_font) title_font="$config2" ; [ "$noecho" -eq 0 ] && echo "title_font=$title_font" ;; 
		# subtitle
		subtitle_type) subtitle_type="$config2" ; [ "$noecho" -eq 0 ] && echo "subtitle_type=$subtitle_type" ;;
		theme) theme="$config2" ; [ "$noecho" -eq 0 ] && echo "theme=$theme" ;; 
		high_quality) high_quality="$config2" ; [ "$noecho" -eq 0 ] && echo "high_quality=$high_quality" ;;  #
	esac
}

set_theme ()
{
	## check for config variables: only specified once per slideshow
	config=`echo "$1" | cut -d= -f1 | tr -d \[:blank:\]`
	config2=`echo "$1" | tr '\t' ' ' | tr -d '\047' | tr -d '\042' | cut -d= -f2 | awk -F' #' '{print $1}' | tr -d \[:blank:\]`
#	config2=`echo "$1" | cut -d= -f2 | awk -F' #' '{print $1}' | tr -d \[:blank:\]`
	[ -n "$2" -a "$2" == 1 ] && local noecho=1 || local noecho=0
	## check for global configuration variables:
	case "$config" in 
		theme) theme="$config2" ; [ "$noecho" -eq 0 ] && echo "$theme" ;;
	esac
}

duration2frames ()
# duration2frames $time_added_ms
{
	## calculate the time point that we're at:
	local current_time=$1
	# calculate current time and frame before adding this extra rendered time:

	local this_start_time=$total_slideshow_time # before adding current rendered time
	local this_start_frame=$total_slideshow_frames

	local total_slideshow_time=$(( $total_slideshow_time + $current_time ))
	local time_to_render=$(( $total_slideshow_time - $this_start_time ))
	local total_slideshow_frames=`div1000 $(( $frames_per_ms * $total_slideshow_time / 1000 ))`
	local frames=$(( $total_slideshow_frames - $this_start_frame ))
	echo "$frames"
}

set_end_frame_time ()
# set_end_frame_time $time_added_ms
{
	## calculate the time point that we're at:
	local current_time=$1
	# calculate current time and frame before adding this extra rendered time:

	this_start_time=$total_slideshow_time # before adding current rendered time
#	echo "this_start_time=$this_start_time"
	this_start_frame=$total_slideshow_frames
#	echo "this_start_frame=$this_start_frame"

#	echo "total_slideshow_time=$total_slideshow_time"
	total_slideshow_time=$(( $total_slideshow_time + $current_time ))
#	echo "total_slideshow_time=$total_slideshow_time"
	time_to_render=$(( $total_slideshow_time - $this_start_time ))
#	echo "time_to_render=$time_to_render"
#	echo "frames_per_ms=$frames_per_ms"
	total_slideshow_frames=`div1000 $(( $frames_per_ms * $total_slideshow_time / 1000 ))`
#	echo "total_slideshow_frames=$total_slideshow_frames"
	frames_to_render=$(( $total_slideshow_frames - $this_start_frame ))
#	frames=$frames_to_render
#	echo "frames_to_render=$frames_to_render"

	slide_end_time=$total_slideshow_time  ## in thousandths of a second
#	echo "slide_end_time=$slide_end_time  duration=${duration[$i]} "
	slide_end_frame="$total_slideshow_frames"
#	echo "slide_end_frame=$slide_end_frame"
	slide_end_hms=`hms $slide_end_time`
}

end_frame_info ()
# end_frame_info $frames
{
	## calculate the time point that we're at:
	total_slideshow_frames=$(( $total_slideshow_frames + $1 ))
	slide_end_frame="$total_slideshow_frames"
	slide_end_time=$(( $slide_end_frame * 1000 * 1000 / $frames_per_ms ))  ## in thousandths of a second
	slide_end_hms=`hms "$slide_end_time"`
}

truncate_filename ()
{
	# truncate filenames so they're not longer than 40 characters:
	local length="${#1}"
	if [ $length -gt 40 ] ; then
		local pos=$(( $length - 40 ))
		echo "...${1:$pos}"
	else
		echo "$1"
	fi
}

create_slide ()
# create_slide $file $outfile $transparent
# does autocropping and compositing over background if required
{
	local file="$1"
	if [ -n "$2" ] ; then
		local output_file="$2"
	else
		local output_file="$tmpdir/slide_$i.ppm"
	fi
	if [ -n "$3" ] && [ -f "$3" ] ; then
		local bg="$3"
	else
		local bg="$tmpdir"/slideshow_background.ppm
	fi
	check_rm "$output_file"
	checkforautocrop "$file"	
	if [ "$do_autocrop_h" -eq 1 ] ; then
		convert "$file" -resize "$sq_to_dvd_pixels" -resize "$frame_width"x -type TrueColor -depth 8 -gravity center -crop "$frame_width"x"$frame_height"'+0!+0!' $sharpen +repage miff:- | composite -compose src-over -gravity center -type TrueColor -depth 8 - "$bg" "$output_file"
	elif [ "$do_autocrop_w" -eq 1 ] ; then
		convert "$file" -resize "$sq_to_dvd_pixels" -resize x"$frame_height" -type TrueColor -depth 8 -gravity center -crop "$frame_width"x"$frame_height"'+0!+0!' $sharpen +repage miff:- | composite -compose src-over -gravity center -type TrueColor -depth 8 - "$bg" "$output_file"
	else
		convert "$file" -resize "$sq_to_dvd_pixels" -resize "$frame_width"x"$frame_height" -type TrueColor -depth 8 $sharpen miff:- | composite -compose src-over -gravity center -type TrueColor -depth 8 - "$bg" "$output_file"
	fi
}


scroll ()  # SCROLL
# scroll $direction $file $bg $total_frames [$startframe] [$lastframe] [$char]
{
	local l_direction="$1"
	local l_file="$2"
	local l_bg="$3"
	local l_frames="$4"
	lastbar=0 # required for progressbar to set back to zero
	[ -z "$5" ] && local l_startframe="1" || local l_startframe="$5"
	[ -z "$6" ] && local l_endframe="$l_frames" || local l_endframe="$6"
	[ -z "$7" ] && local c='#' || local c="$7"
	if [ "$3" == "$transparent_bg" ] ; then
		local suffix='png'
	else
		local suffix='ppm'
	fi
	image_width="`imagewidth "$l_file"`"
	image_height="`imageheight "$l_file"`"
	## calculate frame size after adding black side bars for portrait pictures:
	if [ $image_width -gt $image_height ] ; then
		# landscape:  (for scroll left/right)
		convert "$l_file" -resize "$sq_to_dvd_pixels" -resize x"$frame_height" +repage $sharpen -type TrueColor -depth 8 "$tmpdir"/temp_slideshow_image_scaled.mpc		
	else
		# portrait:  (for scroll up/down )
		convert "$l_file" -resize "$sq_to_dvd_pixels" -resize "$frame_width" +repage $sharpen -type TrueColor -depth 8 "$tmpdir"/temp_slideshow_image_scaled.mpc		
	fi

	# now the image is scaled so the height is correct
	image_width="`imagewidth_sq "$tmpdir/temp_slideshow_image_scaled.mpc"`" # already non-suqare pixels
	image_height="`imageheight "$tmpdir/temp_slideshow_image_scaled.mpc"`"
	[ "$debug" -ge 2 ] && myecho "[dvd-slideshow:scroll] Temp image_width=$image_width image_height=$image_height"
	## these are the crop parameters that will be used to crop the temp image:
	if [ "$l_direction" == 'right' ] ; then
#		myecho "[dvd-slideshow] Doing scroll right effect"
		xs0=0 ; ys0=0 # scroll right
		xe0=$(( $image_width - $frame_width )) ; ye0=0
	elif [ "$l_direction" == 'left' ] ; then
#		myecho "[dvd-slideshow] Doing scroll left effect"
		xs0=$(( $image_width - $frame_width )) ; ys0=0
		xe0=0 ; ye0=0 # scroll left
	elif [ "$l_direction" == 'up' ] ; then
#		myecho "[dvd-slideshow] Doing scroll up effect"
		xs0=0 ; ys0=$(( $image_height - $frame_height )) 
		xe0=0 ; ye0=0 # scroll up
	elif [ "$l_direction" == 'down' ] ; then
#		myecho "[dvd-slideshow] Doing scroll down effect"
		xs0=0 ; ys0=0 # scroll down
		xe0=0 ; ye0=$(( $image_height - $frame_height )) 
	else
		myecho "[dvd-slideshow:scroll] ERROR: bad effect parameters $l_direction"
		cleanup; exit 1
	fi
	[ "$debug" -ge 2 ] && myecho "[dvd-slideshow:scroll] params=$xs0,$ys0 ; $xe0,$ye0"
	if [ "$low_quality" -eq 1 ] ; then
		stepsize=3; interp=0
	elif [ "$high_quality" -eq 1 ] ; then
		stepsize=1; interp=1
	else
#		[ "$l_frames" -lt 45 ] && stepsize=1 || stepsize=2 
		stepsize=1; interp=0
	fi

	xvelocity=$(( 1000 * ($xe0-$xs0) / $l_frames ))
	yvelocity=$(( 1000 * ($ye0-$ys0) / $l_frames ))
	[ $debug -ge 2 ] && myecho "[dvd-slideshow] xVelocity=$xvelocity yVelocity=$yvelocity interp=$interp"
	if [ "$interp" -eq 1 ] && [ "$yvelocity" -eq 0 ] && [ "$xvelocity" -lt 4000 ] ; then
		[ $debug -ge 1 ] && myecho "[dvd-slideshow:scroll] Using interpolation. xVelocity=$xvelocity"
	elif [ "$interp" -eq 1 ] && [ "$xvelocity" -eq 0 ] && [ "$yvelocity" -lt 4000 ] ; then
		[ $debug -ge 1 ] && myecho "[dvd-slideshow:scroll] Using interpolation. yVelocity=$yvelocity"
	elif [ "$interp" -eq 1 ] ; then
		[ $debug -ge 1 ] && myecho "[dvd-slideshow:scroll] No need to use high-quality mode for a fast scroll... disabling -H"
		interp=0
	fi
	## smooth start and end parameters:
	F1=$(( $l_frames * 10 / 100 ))  # 10 percent smoothing
	F2=$(( $l_frames - $F1 ))	
	V0x=$( echo "scale=9; 2 * ( $xe0 - $xs0 ) / ( $l_frames + $F2 - $F1 -2 )" | bc )  # hack -2 to make it fit better?
	V0y=$( echo "scale=9; 2 * ( $ye0 - $ys0 ) / ( $l_frames + $F2 - $F1 -2 )" | bc )
	pi='3.14159265'
#	end_frame_info $rendered_frames
	[ $debug -ge 1 ] &&  myecho "[dvd-slideshow] end_frame_number=$slide_end_frame end_time=$slide_end_hms"
	echo -n "[dvd-slideshow]"
	lastbar=0 # required for progressbar
	for (( fr=l_startframe ; fr<=l_endframe ; fr=fr+stepsize )) ; do
		dj=`addzeros $fr`
		progressbar $(( $fr - $l_startframe +1 )) $(( $l_endframe - $l_startframe + 1 )) "$c"
		if [ "$interp" -eq 1 ] ; then
			x0=$( echo "scale=3; $xs0 + ($xe0-$xs0)* $fr / $l_frames" | bc )
			y0=$( echo "scale=3; $ys0 + ($ye0-$ys0)* $fr / $l_frames" | bc )
			x0_dec=`printf %3.3f $x0 | awk -F. '{print "0."$2}'`; 
			y0_dec=`printf %3.3f $y0 | awk -F. '{print "0."$2}'`;
			## Fix numbers without leading zeros:
			it=`echo "$x0" | awk -F. '{print $1}'` ; [ -z "$it" ] && x0_whole=0 || x0_whole="$it"
			it=`echo "$y0" | awk -F. '{print $1}'` ; [ -z "$it" ] && y0_whole=0 || y0_whole="$it"
			# calculate subpixel-averaging weights:
                        Afactor=$( echo "scale=3; 100*(1-$x0_dec)*(1-$y0_dec)" | bc )
                        Bfactor=$( echo "scale=3; 100*($x0_dec)*(1-$y0_dec)" | bc )
                        Cfactor=$( echo "scale=3; 100*(1-$x0_dec)*($y0_dec)" | bc )
                        Dfactor=$( echo "scale=3; 100*($x0_dec)*($y0_dec)" | bc )
	                Afactor=`printf %3.0f $Afactor | tr -d \[:blank:\]`
	                Bfactor=`printf %3.0f $Bfactor | tr -d \[:blank:\]`
	                Cfactor=`printf %3.0f $Cfactor | tr -d \[:blank:\]`
	                Dfactor=`printf %3.0f $Dfactor | tr -d \[:blank:\]`
			convolve="-convolve 0,0,0,0,$Afactor,$Bfactor,0,$Cfactor,$Dfactor"
			[ $debug -ge 3 ] && myecho "[dvd-slideshow:scroll] x0=$x0 y0=$y0 Af=$Afactor Bf=$Bfactor Cf=$Cfactor Df=$Dfactor"
		else
			# no interpolation
			if [ $fr -le $F1 ] ; then
				# region 1
				x0=$( echo "scale=3; $xs0 + $V0x/2 *($fr - $F1/$pi *s($pi*$fr/$F1))" | bc -l )
				y0=$( echo "scale=3; $ys0 + $V0y/2 *($fr - $F1/$pi *s($pi*$fr/$F1))" | bc -l )
				[ $debug -ge 3 ] && myecho "[dvd-slideshow:scroll] $fr x0=$x0 y0=$y0 region 1"
				D1x=$x0; D1y=$y0
				x0_dec=`printf %3.3f $x0 | awk -F. '{print "0."$2}'`; 
				y0_dec=`printf %3.3f $y0 | awk -F. '{print "0."$2}'`;
				## Fix numbers without leading zeros:
				it=`echo "$x0" | awk -F. '{print $1}'` ; [ -z "$it" ] && x0_whole=0 || x0_whole="$it"
				it=`echo "$y0" | awk -F. '{print $1}'` ; [ -z "$it" ] && y0_whole=0 || y0_whole="$it"
				x0=$x0_whole ; y0=$y0_whole
			elif [ $fr -ge $F2 ] ; then
				# region 3
				x0=$( echo "scale=3; $D2x + $V0x/2 *( ($fr-$F2) + ($l_frames-$F2)/$pi*s(($fr-$F2)*$pi/($l_frames-$F2)) )" | bc -l )
				y0=$( echo "scale=3; $D2y + $V0y/2 *( ($fr-$F2) + ($l_frames-$F2)/$pi*s(($fr-$F2)*$pi/($l_frames-$F2)) )" | bc -l )
				[ $debug -ge 3 ] && myecho "[dvd-slideshow:scroll] $fr x0=$x0 y0=$y0 region 3"
				x0_dec=`printf %3.3f $x0 | awk -F. '{print "0."$2}'`; 
				y0_dec=`printf %3.3f $y0 | awk -F. '{print "0."$2}'`;
				## Fix numbers without leading zeros:
				it=`echo "$x0" | awk -F. '{print $1}'` ; [ -z "$it" ] && x0_whole=0 || x0_whole="$it"
				it=`echo "$y0" | awk -F. '{print $1}'` ; [ -z "$it" ] && y0_whole=0 || y0_whole="$it"
				x0=$x0_whole ; y0=$y0_whole
			else
				# middle region 2
#				x0=`div10 $(( 10 * $xs0 + $V0x * 10 * $fr ))`
#				y0=`div10 $(( 10 * $ys0 + $V0y * 10 * $fr ))`
				x0=$( echo "scale=3; $D1x + $V0x*($fr-$F1)" | bc )
				y0=$( echo "scale=3; $D1y + $V0y*($fr-$F1)" | bc )
				D2x=$x0 ; D2y=$y0
				[ $debug -ge 3 ] && myecho "[dvd-slideshow:scroll] $fr x0=$x0 y0=$y0 region 2"
				x0_dec=`printf %3.3f $x0 | awk -F. '{print "0."$2}'`; 
				y0_dec=`printf %3.3f $y0 | awk -F. '{print "0."$2}'`;
				## Fix numbers without leading zeros:
				it=`echo "$x0" | awk -F. '{print $1}'` ; [ -z "$it" ] && x0_whole=0 || x0_whole="$it"
				it=`echo "$y0" | awk -F. '{print $1}'` ; [ -z "$it" ] && y0_whole=0 || y0_whole="$it"
				x0=$x0_whole ; y0=$y0_whole
			fi
			convolve=""
		fi
		it="${effect1_params[$i]}"
		if [ "$interp" -eq 1 ] ; then
			if [ "$smp" -eq 1 ] ; then
				if [ "$frame_border" -eq 0 ] ; then
			    	convert "$tmpdir"/temp_slideshow_image_scaled.mpc -crop "$frame_width"x"$frame_height"+"$x0_whole"+"$y0_whole" $convolve +repage -type TrueColor -depth 8 "$tmpdir/fade_$dj.$suffix" &
				else
			    	(convert "$tmpdir"/temp_slideshow_image_scaled.mpc -crop "$frame_width"x"$frame_height"+"$x0_whole"+"$y0_whole" $convolve +repage -type TrueColor -depth 8 miff:- | composite -compose src-over -geometry "+$frame_border+$frame_border" -type TrueColor -depth 8 - "$normal_bg" "$tmpdir/fade_$dj.$suffix") &
				fi
			else
				if [ "$frame_border" -eq 0 ] ; then
			    	convert "$tmpdir"/temp_slideshow_image_scaled.mpc -crop "$frame_width"x"$frame_height"+"$x0_whole"+"$y0_whole" $convolve +repage -type TrueColor -depth 8 "$tmpdir/fade_$dj.$suffix"
				else
			    	convert "$tmpdir"/temp_slideshow_image_scaled.mpc -crop "$frame_width"x"$frame_height"+"$x0_whole"+"$y0_whole" $convolve +repage -type TrueColor -depth 8 miff:- | composite -compose src-over -geometry "+$frame_border+$frame_border" -type TrueColor -depth 8 - "$normal_bg" "$tmpdir/fade_$dj.$suffix" 
				fi
			fi
		else
			[ $debug -ge 3 ] && echo "[dvd-slideshow:scroll] $dj crop:$frame_width"x"$frame_height"+"$x0"+"$y0 composite: +$frame_border"+"$frame_border"
			if [ "$smp" -eq 1 ] ; then
				if [ "$frame_border" -eq 0 ] ; then
				(convert "$tmpdir/temp_slideshow_image_scaled.mpc" -crop "$frame_width"x"$frame_height"+$x0+$y0 +repage -type TrueColor -depth 8 "$tmpdir/fade_$dj.$suffix" ; extracopies $fr $l_frames) &
				else
				(convert "$tmpdir/temp_slideshow_image_scaled.mpc" -crop "$frame_width"x"$frame_height"+$x0+$y0 +repage -type TrueColor -depth 8  miff:- | composite -compose src-over -geometry "+$frame_border+$frame_border" -type TrueColor -depth 8 - "$normal_bg" "$tmpdir/fade_$dj.$suffix" ; extracopies $fr $l_frames) &
				fi
			else
				if [ "$frame_border" -eq 0 ] ; then
				(convert "$tmpdir/temp_slideshow_image_scaled.mpc" -crop "$frame_width"x"$frame_height"+$x0+$y0 +repage -type TrueColor -depth 8 "$tmpdir/fade_$dj.$suffix" ; extracopies $fr $l_frames)
				else
				(convert "$tmpdir/temp_slideshow_image_scaled.mpc" -crop "$frame_width"x"$frame_height"+$x0+$y0 +repage -type TrueColor -depth 8  miff:- | composite -compose src-over -geometry "+$frame_border+$frame_border" -type TrueColor -depth 8 - "$normal_bg" "$tmpdir/fade_$dj.$suffix" ; extracopies $fr $l_frames)
				fi
			fi
		fi
	done
	waitforfiles "$tmpdir/fade" $suffix $dj $l_startframe
	finish_progressbar $(( $fr - $l_startframe +1 )) $(( $l_endframe - $l_startframe + 1 )) "$c"
}

full_path ()   # from Shea Martin
{
if [ -f "$1" ]; then
        DIR="$(dirname "$1")"
        DIR=$(cd "$DIR" && pwd)
        FILE="$(basename $1)"
        RSLT=$?
        echo "$DIR/$FILE"
        return $RSLT
elif [ -d "$1" ]; then
        cd "$DIR" && pwd && cd $OLDPWD
        return $?
else
        echo "unknown file: $1"
        return 1
fi
}

set_variables ()   # SET_VARIABLES
{
	## check for config variables:
	config1=`echo "$1" | cut -d= -f1 | tr -d \[:blank:\]`
	config2=`echo "$1" | tr '\t' ' ' | cut -d= -f2 | tr -d '\047' | tr -d '\042' | awk -F' #' '{print $1}' | tr -d \[:blank:\]`
	[ -n "$2" -a "$2" == 1 ] && noecho=1 || noecho=0
	## check for global configuration variables:
	case "$config1" in 
		debug) debug="$config2" ; [ "$noecho" -eq 0 ] && echo "debug=$debug" ;;
		# title
		title_font_size) title_font_size="$config2" ; [ "$noecho" -eq 0 ] && echo "title_font_size=$title_font_size" ;;
		title_font_color) title_font_color="$config2" ; [ "$noecho" -eq 0 ] && echo "title_font_color=$title_font_color" ;;
		# top title
		toptitle_font_size) toptitle_font_size="$config2" ; [ "$noecho" -eq 0 ] && echo "toptitle_font_size=$toptitle_font_size" ;;
		toptitle_font_color) toptitle_font_color="$config2" ; [ "$noecho" -eq 0 ] && echo "toptitle_font_color=$toptitle_font_color" ;;
		toptitle_bar_height) toptitle_bar_height="$config2" ; [ "$noecho" -eq 0 ] && echo "toptitle_bar_height=$toptitle_bar_height" ;;
		toptitle_text_location_x) toptitle_text_location_x="$config2" ; [ "$noecho" -eq 0 ] && echo "toptitle_text_location_x=$toptitle_text_location_x" ;;
		toptitle_text_location_y) toptitle_text_location_y="$config2" ; [ "$noecho" -eq 0 ] && echo "toptitle_text_location_y=$toptitle_text_location_y" ;;
		# bottom title
		bottomtitle_font_size) bottomtitle_font_size="$config2" ; [ "$noecho" -eq 0 ] && echo "bottomtitle_font_size=$bottomtitle_font_size" ;;
		bottomtitle_font_color) bottomtitle_font_color="$config2" ; [ "$noecho" -eq 0 ] && echo "bottomtitle_font_color=$bottomtitle_font_color" ;;
		bottomtitle_bar_location_y) bottomtitle_bar_location_y="$config2" ; [ "$noecho" -eq 0 ] && echo "bottomtitle_bar_location_y=$bottomtitle_bar_location_y" ;;
		bottomtitle_bar_height) bottomtitle_bar_height="$config2" ; [ "$noecho" -eq 0 ] && echo "bottomtitle_bar_height=$bottomtitle_bar_height" ;;
		bottomtitle_text_location_x) bottomtitle_text_location_x="$config2" ; [ "$noecho" -eq 0 ] && echo "bottomtitle_text_location_x=$bottomtitle_text_location_x" ;;
		bottomtitle_text_location_y) bottomtitle_text_location_y="$config2" ; [ "$noecho" -eq 0 ] && echo "bottomtitle_text_location_y=$bottomtitle_text_location_y" ;;
		border) border="$config2" ; frame_border=$border ; frame_width=$(( $dvd_width - 2 * $frame_border )); frame_height=$(( $dvd_height - 2 * $frame_border )) ; [ "$noecho" -eq 0 ] && echo "border=$border" ;;
		sharpen) sharpen="$config2" ; [ "$noecho" -eq 0 ] && echo "sharpen=$sharpen" ;;
		kenburns_acceleration) kenburns_acceleration="$config2" ; [ "$noecho" -eq 0 ] && echo "kenburns_acceleration=$kenburns_acceleration" ;;
		subtitle_font) subtitle_font="$config2" ; [ "$noecho" -eq 0 ] && echo "subtitle_font=$subtitle_font" ;;
		subtitle_font_size) subtitle_font_size="$config2" ; [ "$noecho" -eq 0 ] && echo "subtitle_font_size=$subtitle_font_size" ;;
		subtitle_color) subtitle_color="$config2" ; [ "$noecho" -eq 0 ] && echo "subtitle_color=$subtitle_color" ;;
		subtitle_outline_color) subtitle_outline_color="$config2" ; [ "$noecho" -eq 0 ] && echo "subtitle_outline_color=$subtitle_outline_color" ;;
		subtitle_location) subtitle_location="$config2" ; [ "$noecho" -eq 0 ] && echo "subtitle_location=$subtitle_location" ;;
	esac
}

print_themes ()  # print the names of the built-in themes and quit
{
# check in default theme directory:
if [ -d "$themedir" ] ; then
#	find "$tmpdir" -name "fade*.ppm" -type f -print0 | xargs -0 rm
	echo "[dvd-slideshow] Found built-in themes:"
	find "$themedir" -maxdepth 2 -name "*.theme" -type f -print0 | xargs -0 ls
#	echo "[dvd-slideshow] $themes"
        exit 0
else
	echo "[dvd-slideshow] Themes directory not found: $themedir"
	exit 0
fi
}

read_theme ()
# read_theme $theme
{
local theme=$1
[ -n "$2" -a "$2" == 1 ] && local noecho=1 || local noecho=0
## read in theme file if it exists:
if [ -n "$theme" ] ; then
        # check if directory
        if [ -d "$theme" ] ; then
                themedir="$theme"
                themefile="`ls -1 "$theme"/*.theme | tail -n 1`"
                [ "$noecho" == '0' ] && myecho "[dvd-slideshow] Using theme $(truncate_filename "$theme")"
        elif [ -f "$theme" ] ; then
                themefile="`full_path "$theme"`"
                themedir="`dirname "$theme"`"
                [ "$noecho" == '0' ] && myecho "[dvd-slideshow] Using theme $(truncate_filename "$theme")"
        else
                # check in default theme directory:
                if [ -d "$themedir"/"$theme" ] ; then
                        themedir="$themedir"/"$theme"
                        themefile="`ls -1 "$themedir"/*.theme | tail -n 1`"
                	[ "$noecho" == '0' ] && myecho "[dvd-slideshow] Using theme file $theme"
                else
                        [ "$noecho" == '0' ] && myecho "[dvd-slideshow] ERROR!  Bad theme name (not found)"
                        exit 1
                fi
        fi
        [ "$noecho" == '0' ] && myecho "[dvd-slideshow] Reading theme file..."
	local thisline=0
	while read thisline
        do
	  set_system_variables "${thisline}" 1
	  it=`set_system_variables "${thisline}" 0`
	  if [ -n "$it" ] ; then
		[ "$noecho" == '0' ] && myecho "[dvd-slideshow] Set system variable $it"
		continue
	  fi

	  set_variables "${thisline}" 1
	  it=`set_variables "${thisline}" 0`
	  if [ -n "$it" ] ; then
		[ "$noecho" == '0' ] && myecho "[dvd-slideshow] Set variable $it"
		continue
	  fi
        done < "$themefile"
	if [ -n "$title_font" ] ; then
	        if [ ! -f "$title_font" ] ; then
	                title_font="$themedir"/"$title_font"
	                if [ ! -f "$title_font" ] ; then
	                        echo "Error:  bad title_font filename in theme"
	                fi
	        fi
	fi
	if [ -n "$subtitle_font" ] ; then
	        if [ ! -f "$subtitle_font" ] ; then
	                subtitle_font="$themedir"/"$subtitle_font"
	                if [ ! -f "$subtitle_font" ] ; then
	                        echo "Error:  bad subtitle_font filename in theme"
	                fi
	        fi
	fi
fi
}

subtitle ()  # SUBTITLE
{
	# $1 = the subtitle passed
	# $2 = index to append to subtitle_$i.png
	# $3 = color
	# output is $tmpdir/subtitle_$i.png
	## fix any special characters:
	local index="$2"
	transparent_color="ff0101"
	if [ -z "$3" ] ; then	
		local bg_color="$transparent_color"
	else
		local bg_color="transparent"
	fi
	local mysubtitle="$( echo "$1" | sed -e 's/"/\\\\"/g' | sed -e 's/\!/\\\!/g')"
	## check to see if we find any user-specified breaks \n
	it=`echo "$mysubtitle" | awk -F'\\' '{print $2}' | cut -c 1`
	if [ "$it" == 'n' ] ; then
		logecho "[dvd-slideshow] Found \\n in subtitle"
		# user entered a \n to force line wraps
		# break lines at line wraps
		subtitle_line1=`echo "$mysubtitle" | awk -F'\\' '{print $1}'`
		subtitle_line2=`echo "$mysubtitle" | awk -F'\\' '{print $2}' | cut -c 2-`
	else	# no forced line wraps.  Check for long lines:	
		## make the subtitle break up into up to 4 different lines?
		font_width=15  # actually it's 14.4, but this should give us some margin
		characters="${#mysubtitle}"
		line_width=$(( $font_width * $characters ))
		if [ "$line_width" -gt "$dvd_width" ] ; then # $dvd_width=720
			## need to split the line:
			characters2=$(( $characters / 2 + 1))
			# try cutting in the middle:
			subtitle_line1="${mysubtitle:0:$characters2}"
			subtitle_line2="${mysubtitle:$characters2:$characters2}" 
			# now re-join a potential broken word:
			if [ "${mysubtitle:$characters2:1}" != ' ' ] ; then	
				# break occurred in the middle of a word. re-join the word:
				wordend=`echo "$subtitle_line2" | awk '{print $1}'`
				wordend_length=${#wordend}
				subtitle_line1="$subtitle_line1$wordend"
				subtitle_line2="${subtitle_line2:$wordend_length}"
			fi
			[ $debug -ge 1 ] && myecho "[dvd-slideshow] Splitting long subtitle... New values:"
			[ $debug -ge 1 ] && myecho "[dvd-slideshow]  Line1=$subtitle_line1"
			[ $debug -ge 1 ] && myecho "[dvd-slideshow]  Line2=$subtitle_line2"
		else
			subtitle_line1=""
			subtitle_line2="$mysubtitle"
		fi
	fi	
#	myecho "[dvd-slideshow] $index subtitle_line1=$subtitle_line1 subtitle_line2=$subtitle_line2"
	
	## render subtitles, if necessary:
	## let dvd-slideshow render its own subtitles:
	subtitle_line1=`echo "$subtitle_line1" | sed -e 's/\\\!/\!/g' `
	subtitle_line2=`echo "$subtitle_line2" | sed -e 's/\\\!/\!/g' `
#	echo "[dvd-slideshow]  Line1=$subtitle_line1"
#	echo "[dvd-slideshow]  Line2=$subtitle_line2"
	if [ "$subtitle_location" == 'top' ] ; then
		gravity="North"
	elif [ "$subtitle_location" == 'bottom' ] ; then
		gravity="South"
	else 
		gravity="South"
	fi
	f_subtitle_font_size=$(( $subtitle_font_size * $dvd_height / 480 ))
	if [ "$subtitle_type" == 'render' ] ; then
#	       	echo convert -size $dvd_width"x"$dvd_height xc:transparent -font "$subtitle_font" -pointsize "$f_subtitle_font_size" -gravity $gravity -fill "$subtitle_color" -stroke "$subtitle_outline_color" -strokewidth 3 -draw "text 0,105 \"$subtitle_line1\"" -draw "text 0,75 \"$subtitle_line2\"" -stroke none -draw "text 0,105 \"$subtitle_line1\"" -draw "text 0,75 \"$subtitle_line2\"" -quality 100 "$tmpdir/subtitle_$index.png"
	       	convert -size $dvd_width"x"$dvd_height xc:transparent -font "$subtitle_font" -pointsize "$f_subtitle_font_size" -gravity $gravity -fill "$subtitle_color" -stroke "$subtitle_outline_color" -strokewidth 3 -draw "text 0,105 \"$subtitle_line1\"" -draw "text 0,75 \"$subtitle_line2\"" -stroke none -draw "text 0,105 \"$subtitle_line1\"" -draw "text 0,75 \"$subtitle_line2\"" -quality 100 "$tmpdir/subtitle_$index.png"
	else
       		convert -size $dvd_width"x"$dvd_height xc:'#'$bg_color -font "$subtitle_font" -pointsize "$f_subtitle_font_size" -gravity $gravity -fill "$subtitle_color" -stroke "$subtitle_outline_color" -strokewidth 3 -colors 3 +antialias -draw "text 0,105 \"$subtitle_line1\"" -draw "text 0,75 \"$subtitle_line2\"" -stroke none -draw "text 0,105 \"$subtitle_line1\"" -draw "text 0,75 \"$subtitle_line2\"" -quality 100 "$tmpdir/subtitle_$index.png"
	fi
}

############################################# End of functions

if [ "$print_themes" -eq 1 ] ; then
	print_themes
	exit 0
fi

## check that input files and directories exist:
if [ -z "$input_txtfile" ] ; then
	input_txtfile="$1"
fi
if [ ! -f "$input_txtfile" ] ; then
	echo "[dvd-slideshow] ERROR: Input file $input_txtfile does not exist."
	exit 1
fi

# make sure a slideshow name was given:
if [ -z "$slideshow_name" ] ; then
	slideshow_name="`basename "$input_txtfile" .txt`"
#	echo "[dvd-slideshow] ERROR:  You must specify a slideshow name with -n <slideshow name>"
	echo "[dvd-slideshow] Using default slideshow name: $slideshow_name"
#	exit 1
fi

# verity output directory exists:
if [ -z "$outdir" ] ; then
	if [ -w "`pwd`" ] ; then
		echo "[dvd-slideshow] Output directory not specified."
		echo "[dvd-slideshow] Using `pwd`"
		outdir="`pwd`"
	else
		echo '[dvd-slideshow] ERROR: Output directory not specified.'
		exit 0
	fi
fi

## make sure output directory can be written to:
if [ ! -w "$outdir" ] ; then
	echo "[dvd-slideshow] Creating output directory $outdir"
	mkdir -p "$outdir"
	if [ ! -w "$outdir" ] ; then
		echo "[dvd-slideshow] ERROR: Output directory is not writeable!"
		exit 1
	fi
fi
	
tmpdir="$outdir/dvd-slideshow_temp_$$"
yuvfifo="dvdss-pipe-$$"   # pipe to mpeg2enc process

## create temporary directory:
if [ -d "$tmpdir" ] ; then
	echo "[dvd-slideshow] Removing old temporary directory $tmpdir"
	rmdir "$tmpdir"
fi
mkdir "$tmpdir"

## initialize log file:
echo "[dvd-slideshow] `date`" > "$outdir/$logfile"
logecho "[dvd-slideshow] Command line was:"
logecho "[dvd-slideshow] $0 $theargs"
logecho "[dvd-slideshow] dvd-slideshow version $version" 
logecho "[dvd-slideshow] `uname -a`"
logecho "[dvd-slideshow] Output directory=$outdir" 

#############################################################
## Now, read in the ~/.dvd-slideshowrc file if it exists:
if [ -f "${HOME}/.dvd-slideshowrc" ] ; then
	echo "[dvd-slideshow] Reading default variables in ${HOME}/.dvd-slideshowrc"
	while read thisline
	do
	  set_system_variables "${thisline}" 1
	  it=`set_system_variables "${thisline}" 0`
	  if [ -n "$it" ] ; then
		myecho "[dvd-slideshow] Set system variable $it"
		continue
	  fi

	  it=`set_variables "${thisline}" 0`
	  if [ -n "$it" ] ; then
		myecho "[dvd-slideshow] Set variable $it"
		continue
	  fi
	done < "$HOME/.dvd-slideshowrc"
fi


################################################################
## Now, set the variables that were passed on the command-line:
[ -n "$commandline_pal" ] && pal=$commandline_pal
[ -n "$commandline_autocrop" ] && autocrop=$commandline_autocrop
[ -n "$commandline_copy" ] && copy=$commandline_copy
[ -n "$commandline_ac3" ] && ac3=$commandline_ac3
[ -n "$commandline_debug" ] && debug=$commandline_debug
[ -n "$commandline_theme" ] && theme=$commandline_theme
[ -n "$commandline_high_quality" ] && high_quality=$commandline_high_quality
[ -n "$commandline_output_size" ] && output_size=$commandline_output_size
[ -n "$commandline_output_framerate" ] && output_framerate=$commandline_output_framerate
[ -n "$commandline_border" ] && border=$commandline_border
[ -n "$commandline_sharpen" ] && sharpen=$commandline_sharpen

## now, read the theme file if it was passed on the commandline:
[ -n "$theme" ] && read_theme "$theme" 0

## we will read the .txt file next...

## report version of bash for debugging:
logecho "[dvd-slideshow] Using `which bash` version `bash --version | head -n 1`"
bashversion=`bash --version | head -n 1 | awk '{print $4}' | awk -F. '{print $1"."$2}'`
#logecho "bash version is $bashversion"


## Check for required programs
# ppmtoy4m
# progver="`rpmversion mjpegtools`"
#checkforprog ppmtoy4m
progver=`mplex 2>&1 | grep version | awk '{ print $4 }'`
logecho "[dvd-slideshow] Found mjpegtools version $progver"
it=`which ppmtoy4m 2> /dev/null`
if [ -z "$it" ] ; then # no ppmtoy4m
               myecho "[dvd-slideshow] ERROR:  no mjpegtools found for audio processing"
               myecho "[dvd-slideshow]         You need to download and install mjpegtools."
               myecho "[dvd-slideshow]         http://mjpegtools.sourceforge.net"
		cleanup ; exit 0
fi
if ppmtoy4m -S 420mpeg2 xxxxx 2>&1 | grep -q xxxxx; then
	logecho "[dvd-slideshow] Using mjpegtools subsampling -S 420mpeg2"
	subsample='420mpeg2'
else
	logecho "[dvd-slideshow] Using mjpegtools subsampling -S 420_mpeg2"
	subsample='420_mpeg2'
fi
	
#checkforprog sox
progver=`sox -h 2>&1 | head -n 1 | awk '{ print $3 }'`
logecho "[dvd-slideshow] Found sox version $progver"
it=`which sox 2> /dev/null`
if [ -z "$it" ] ; then # no sox
               myecho "[dvd-slideshow] ERROR:  no sox found for audio processing"
               myecho "[dvd-slideshow]         You need to download and install sox."
               myecho "[dvd-slideshow]         http://sox.sourceforge.net"
		cleanup ; exit 0
fi

#checkforprog convert
progver=`convert -help | head -n 1 | awk '{ print $3 }'`
logecho "[dvd-slideshow] Found ImageMagick version $progver"
it=`which convert 2> /dev/null`
if [ -z "$it" ] ; then # no convert
               myecho "[dvd-slideshow] ERROR:  no ImageMagick found for audio processing"
               myecho "[dvd-slideshow]         You need to download and install ImageMagick."
               myecho "[dvd-slideshow]         http://ImageMagick.sourceforge.net"
		cleanup ; exit 0
fi

#checkforprog dvdauthor
progver=`dvdauthor -h 2>&1 | head -n 1 | awk '{ print $3 }'`
logecho "[dvd-slideshow] Found dvdauthor version $progver"
it=`which dvdauthor 2> /dev/null`
if [ -z "$it" ] ; then # no dvdauthor
               myecho "[dvd-slideshow] ERROR:  no dvdauthor found for audio processing"
               myecho "[dvd-slideshow]         You need to download and install dvdauthor."
               myecho "[dvd-slideshow]         http://dvdauthor.sourceforge.net"
		cleanup ; exit 0
fi

# ffmpeg
it=`which ffmpeg 2> /dev/null`
      if [ -z "$it" ] ; then
              # no ffmpeg!  use mp2 audio instead:
              myecho "[dvd-slideshow] Warning:  no ffmpeg found for AC3 audio encoding."
              myecho "[dvd-slideshow]           Using MP2 audio instead."
              myecho "[dvd-slideshow]           MP2 audio is less compatible with DVD player hardware."
 		myecho "[dvd-slideshow]		http://ffmpeg.sourceforge.net"
              ac3=0
		mpeg_encoder='mpeg2enc'
else
	# found ffmpeg
	logecho "`ffmpeg -version 2>&1`"
	## check to see if we have mpeg2video output option:
	it=`ffmpeg -f mpeg2video 2>&1 | grep 'Unknown input or output format: mpeg2video'`
	if [ -z "$it" ] ; then
		# mpeg2video should be ok
		[ "$mpeg_encoder" == 'ffmpeg' ] && mpeg_encoder='ffmpeg' 
	else
		[ "$mpeg_encoder" == 'ffmpeg' ] && mpeg_encoder='mpeg2enc' 
		myecho "[dvd-slideshow] Warning:  ffmpeg is not compiled with the mpeg2video option"
		myecho "[dvd-slideshow] 	  required for making dvds!  Using mpeg2enc instead."
	fi
fi
################################################## done finding programs

if [ -f "$tmpdir/slide_1.ppm" ] || [ -f "$tmpdir/slideshow_background.ppm" ] || [ -f "$tmpdir/fade_0001.ppm" ] ; then
	myecho "[dvd-slideshow] Found old files in output directory.  Removing them..."
	cleanup
fi


logecho "[dvd-slideshow] ####################################"
myecho "[dvd-slideshow] Parsing input file $input_txtfile"

## loop over input .txt file to include any other files:
## thanks to Thomas Weber for this feature!
## modified slightly by Scott Dylewski
# create a tepmorary text file

tmptxtfile="tmp_txtfile.txt"
check_rm "$tmpdir/$tmptxtfile"

total_lines=`wc -l "$input_txtfile" | awk '{print $1}'`
#total_lines=$(( $total_lines + 1 ))
line=1

#while [ $line -ne $total_lines -a $total_lines -ne 0 ];
while read thisline  ## read $input_txtfile
do
  # Search for included files:
#  thisline=`sed -n "$line"p "$input_txtfile"`
  mygrep=`echo "$thisline" | grep -i ^include`
  mygrep_kb=`echo "$thisline" | grep -i :kenburns:`
  if [ -n "$mygrep" ]; then
	  # Extract file name out of line: Correct statement is include:filename.txt
	  incfile=`echo $thisline | awk -F: '{print $2}'`
	  # Check if the incfile is present
	  if [ -r "$incfile" ]; then
	    # Append contents of the incfile to the temporary file
	    myecho "[dvd-slideshow] Including input file $incfile"
	    cat "$incfile" >> "$tmpdir/$tmptxtfile"
## cat removed the backslashes protecting special characters?
#	    sed -e '/*/p' >> "$tmpdir/$tmptxtfile"
	  fi
  elif [ -n "$mygrep_kb" ]; then
	  # found kenburns syntax:  1,5,1
	# convert to crop, kb, crop
	kb_image=`echo "${thisline}" | cut -d: -f1`
	kb_duration=`echo "${thisline}" | cut -d: -f2`
	kb_duration1=`echo $kb_duration | cut -s -d, -f1`
	kb_duration2=`echo $kb_duration | cut -s -d, -f2`
	kb_duration3=`echo $kb_duration | cut -s -d, -f3`
	kb_subtitle=`echo "${thisline}" | cut -d: -f3`
	kb_effect1=`echo "${thisline}" | cut -d: -f4`
#	echo "duration1=$kb_duration1. duration2=$kb_duration2. duration3=$kb_duration3."
	if [ "$kb_effect1" == 'kenburns' ] && [ -n "$kb_duration1" ] && [ -n "$kb_duration2" ] && [ -n "$kb_duration3" ] ; then  # just to be sure
		kb_effect1_params=`echo "${thisline}" | cut -d: -f5 | awk -F' #' '{print $1}' | tr -d \[:blank:\]`
		kb_start_size=`echo $kb_effect1_params | awk -F';' '{print $1}'`
		kb_start_loc=`echo $kb_effect1_params | awk -F';' '{print $2}'`
		kb_end_size=`echo $kb_effect1_params | awk -F';' '{print $3}'`
		kb_end_loc=`echo $kb_effect1_params | awk -F';' '{print $4}'`
#	    echo "[dvd-slideshow] Converting kenburns syntax $kb_duration to crop $kb_duration1,kb $kb_duration2, crop $kb_duration3"
	    logecho "[dvd-slideshow] Converting kenburns syntax $kb_duration to crop $kb_duration1,kb $kb_duration2, crop $kb_duration3"
		echo "$kb_image:$kb_duration1:$kb_subtitle:crop:$kb_start_size;$kb_start_loc" >> "$tmpdir"/"$tmptxtfile"
		echo "$kb_image:$kb_duration2:$kb_subtitle:kenburns:$kb_start_size;$kb_start_loc;$kb_end_size;$kb_end_loc"  >> "$tmpdir"/"$tmptxtfile"
		echo "$kb_image:$kb_duration3:$kb_subtitle:crop:$kb_end_size;$kb_end_loc"  >> "$tmpdir"/"$tmptxtfile"
	else
	   # Print lines in the temporary file
	   sed -n "$line"p "$input_txtfile" >> "$tmpdir"/"$tmptxtfile"
	fi
  else
	   # Print lines in the temporary file
	   sed -n "$line"p "$input_txtfile" >> "$tmpdir"/"$tmptxtfile"
  fi
  line=$(( $line + 1 ))
done  < "$input_txtfile"
echo " " >> "$tmpdir"/"$tmptxtfile"  # make sure last line has a return character.


lastbar=0 # required for progressbar
## loop over input .txt file, looking first for config variables
let i=0
total_video_length=0
audio_inside_txtfile=0
imagefiles=0 ; moviefiles=0 ; audiofiles=0
background_slides=0; transitions=0; titles=0
manual_chapter_markers=0 # default, set to 1 if/when "chapter" keyword is found
spumux_header=0

## let's parse the txtfile:
total_lines=`wc -l "$tmpdir/$tmptxtfile" | awk '{print $1}'`
#total_lines=$(( $total_lines + 1 ))
let line=1

echo -n "[dvd-slideshow] "  # for progressbar
#while [ $line -ne $total_lines -a $total_lines -ne 0 ];
while read crap  ## read $tmpdir/$tmptxtfile
do
	progressbar $line $total_lines
        # change @: which is "escaped" : to something else so that
        # it doesn't separate parameters.
        thisline=`sed -n "$line"p "$tmpdir/$tmptxtfile" | sed -e 's/\\\:/xxx_xxx/g'`
	if [ "${thisline:0:1}" == '#' ] ; then
		line=$(( $line + 1 )); continue # commented line. ignore it.
	elif [ -z `echo "$thisline" | tr -d \[:blank:\]` ] ; then
		line=$(( $line + 1 )); continue # blank line. ignore it.
	elif [ "$thisline" == 'exit' ] ; then
		line=$(( $line + 1 )); break # skip ahead
	fi 
	# check for theme variables:
#	  set_theme "${thisline}" 1
	  it=`set_theme "${thisline}" 0`
	  if [ -n "$it" ] ; then
		logecho "[dvd-slideshow] Set theme to $it"
		read_theme "$it" 1
		## need to ignore these lines from now on!
		line=$(( $line + 1 )) ; continue
	  fi

	# check for system variables:
	  set_system_variables "${thisline}" 1
	  it=`set_system_variables "${thisline}" 0`
	  if [ -n "$it" ] ; then
		logecho "[dvd-slideshow] Set system variable $it"
		## need to ignore these lines from now on!
		line=$(( $line + 1 )) ; continue
	  fi

	image[$i]=`echo "${thisline}" | awk -F' #' '{print $1}' | cut -d: -f1`
	filetype[$i]=`echo "${image[$i]}" | awk -F. '{print tolower($NF)}'`
	duration[$i]=`echo "${thisline}" | cut -d: -f2 | awk -F' #' '{print $1}'`
	[ -z "${duration[$i]}" ] && duration[$i]=0
	subtitle[$i]=`echo "${thisline}" | cut -d: -f3 | awk -F' #' '{print $1}'`

	## check for other variable settings:
	it=`set_variables "${thisline}" 0`  
	if [ -n "$it" ] ; then
		## need to process these lines still!  Variable was found.
		image_file[$i]=0 ; audio_file[$i]=0 ; avi_file[$i]=0
		duration[$i]=0
        	subtitle[$i]=''
		i=$(( $i+1 )) ; line=$(( $line + 1 )) ; continue
	fi

	## check data file type and build arrays
        # change "xxx_xxx" back to ":"
        # - this should only be needed in subtitle
        subtitle[$i]=`echo ${subtitle[$i]} | sed -e 's/xxx_xxx/:/g'`

	if [ "${image[$i]}" == 'background' ] ; then  # trap potential # before hex color:
		effect1[$i]=`echo "${thisline}" | cut -d: -f4 | awk -F':#' '{print $1}' | awk -F' #' '{print $1}'`
	else
		effect1[$i]=`echo "${thisline}" | cut -d: -f4 | awk -F' #' '{print $1}'`
	fi
	if [ "${filetype[$i]}" == 'musictitle' ] || [ "${filetype[$i]}" == 'title' ] || [ "${filetype[$i]}" == 'Title' ] ; then
		effect1_params[$i]=`echo "${thisline}" | cut -d: -f5 | awk -F' #' '{print $1}'`
	else
		effect1_params[$i]=`echo "${thisline}" | cut -d: -f5 | awk -F' #' '{print $1}' | tr -d \[:blank:\]`
	fi
	effect2[$i]=`echo "${thisline}" | cut -d: -f6 | awk -F' #' '{print $1}'`
	effect2_params[$i]=`echo "${thisline}" | cut -d: -f7 | awk -F' #' '{print $1}' | tr -d \[:blank:\]`
	effect3[$i]=`echo "${thisline}" | cut -d: -f8 | awk -F' #' '{print $1}'`
	effect_params3[$i]=`echo "${thisline}" | cut -d: -f9 | awk -F' #' '{print $1}' | tr -d \[:blank:\]`
	effect4[$i]=`echo "${thisline}" | cut -d: -f10 | awk -F' #' '{print $1}'`
	effect_params4[$i]=`echo "${thisline}" | cut -d: -f11 | awk -F' #' '{print $1}' | tr -d \[:blank:\]`

	if [ "${filetype[$i]}" == 'jpg' ] || [ "${filetype[$i]}" == 'png' ] || [ "${filetype[$i]}" == 'jpeg' ] ; then
		## make sure file exists:
                if [ ! -f "${image[$i]}" ] ; then
			myecho ""
                	myecho "[dvd-slideshow] ERROR: Image ${image[$i]} does not exist"
                	exit 1
                fi
		image_file[$i]=1 ; audio_file[$i]=0 ; avi_file[$i]=0
                ## optinally copy images to new directory for backup onto dvd:
                newname=`echo "${slideshow_name}" | sed -e 's/ /_/g'`
                if [ "$copy" -eq 1 ] ; then
                        mkdir -p "$outdir/$newname"_pics
                fi
                if [ "$copy" -eq 1 ] ; then
                        cp "${image[$i]}" "$outdir/$newname"_pics
                fi
		if [ "${effect1[$i]}" == 'kenburns' ] ; then  # add crop before/after kenburns
			## check for x,D,y duration syntax for kenburns effect:
			duration_fields=$( echo "${duration[$i]}" | awk -F, '{print NF}' )
			if [ "$duration_fields" -eq 3 ] ; then
				duration1=`echo ${duration[$i]} | cut -d, -f1 | awk -F' #' '{print $1}'`
				duration[$i]=`echo ${duration[$i]} | cut -d, -f2 | awk -F' #' '{print $1}'`
				duration3=`echo ${duration[$i]} | cut -d, -f3 | awk -F' #' '{print $1}'`
			elif [ "$duration_fields" -eq 2 ] ; then
				duration1=`echo ${duration[$i]} | cut -d, -f1 | awk -F' #' '{print $1}'`
				duration[$i]=`echo ${duration[$i]} | cut -d, -f2 | awk -F' #' '{print $1}'`
				duration3=0
			else
				duration1=0
				duration3=0
			fi	
		fi
		if [ "${duration[$i]}" == '0' ] ; then
			myecho ""
			myecho "[dvd-slideshow] ERROR: Bad duration time of zero:"
			myecho "[dvd-slideshow]	$thisline"
			myecho "[dvd-slideshow] You need to specify a non-zero duration"
			cleanup; exit 1
		fi
		duration_ms=`seconds2ms ${duration[$i]}`
		total_video_length="$(( $total_video_length + $duration_ms ))"
		imagefiles=$(( $imagefiles + 1 ))
		## check for common syntax errors:
		## forgetting subtitle in crop/scroll/kenburns:
		if [ "${subtitle[$i]}" == 'crop' ] && [ "${effect1[$i]}" != 'crop' ] ; then
			myecho ""
			myecho "[dvd-slideshow] ERROR: Bad syntax in line:"
			myecho "[dvd-slideshow]	$thisline"
			myecho "[dvd-slideshow] You probably forgot to add an empty subtitle placeholder:"
			myecho "[dvd-slideshow] image.jpg:duration::crop:50%;middle"
			myecho "[dvd-slideshow] image.jpg:duration:my subtitle:crop:50%;middle"
			cleanup; exit 1
		fi
		if [ "${subtitle[$i]}" == 'scroll' ] && [ "${effect1[$i]}" != 'scroll' ] ; then
			myecho ""
			myecho "[dvd-slideshow] ERROR: Bad syntax in line:"
			myecho "[dvd-slideshow]	$thisline"
			myecho "[dvd-slideshow] You probably forgot to add an empty subtitle placeholder:"
			myecho "[dvd-slideshow] image.jpg:duration::scroll:right"
			myecho "[dvd-slideshow] image.jpg:duration:my subtitle:sroll:right"
			cleanup; exit 1
		fi
		if [ "${subtitle[$i]}" == 'kenburns' ] && [ "${effect1[$i]}" != 'kenburns' ] ; then
			myecho ""
			myecho "[dvd-slideshow] ERROR: Bad syntax in line:"
			myecho "[dvd-slideshow]	$thisline"
			myecho "[dvd-slideshow] You probably forgot to add an empty subtitle placeholder:"
			myecho "[dvd-slideshow] image.jpg:duration::kenburns:50%;middle:75%:right"
			myecho "[dvd-slideshow] image.jpg:duration:my subtitle:kenburns:50%;middle:75%:right"
			cleanup; exit 1
		fi
		#######################################################################
		## Roate?
		## rotate image first, then apply other effects?
#		for e in `seq 2 -1 1`; do
		for (( e=2; e>=1 ; e-- )) ; do
			if [ "$e" -eq 1 ] ; then
				this_effect="${effect1[$i]}"
				this_effect_params="${effect1_params[$i]}"
			elif [ "$e" -eq 2 ] ; then
				this_effect="${effect2[$i]}"
				this_effect_params="${effect2_params[$i]}"
			fi
	#		myecho "effect=$this_effect params=$this_effect_params"
			if [ "${image_file[$i]}" -eq 1 ] && [ "$this_effect" == 'rotate' ] ; then 
				logecho "[dvd-slideshow] Rotating ${image[$i]} $this_effect_params"
				## get basename of image:
				suffix=`echo "${image[$i]}" | awk -F. '{print tolower($NF)}'`	
				it=`basename "${image[$i]}" .$suffix`
				convert "${image[$i]}" -background transparent -bordercolor transparent -rotate "$this_effect_params" -quality 100 "$tmpdir"/"$it"_rotated.png
				image[$i]="$tmpdir"/"$it"_rotated.png
				if [ "$e" -eq 1 ] ; then
					effect1[$i]="${effect2[$i]}"
					effect1_params[$i]="${effect2_params[$i]}"
					effect2[$i]=''
					effect2_params[$i]=''
				elif [ "$e" -eq 2 ] ; then
					effect2[$i]=''
					effect2_params[$i]=''
				fi
			fi
		done
		#######################################################################

	elif [ "${image[$i]}" == 'fadein' ] || [ "${image[$i]}" == 'fadeout' ] || [ "${image[$i]}" == 'crossfade' ] || [ "${image[$i]}" == 'wipe' ] ; then
		image_file[$i]=0 ; audio_file[$i]=0 ; avi_file[$i]=0
		if [ "${duration[$i]}" == '0' ] ; then
			myecho ""
			myecho "[dvd-slideshow] ERROR: Bad duration time of zero:"
			myecho "[dvd-slideshow]	$thisline"
			myecho "[dvd-slideshow] You need to specify a non-zero duration"
			cleanup; exit 1
		fi	
		duration_ms=`seconds2ms ${duration[$i]}`
#		total_video_length="$(( $total_video_length + $duration_ms ))"
		transitions=$(( $transitions + 1 ))
	elif [ "${image[$i]}" == 'title' ] || [ "${image[$i]}" == 'Title' ] ; then
                if [ -z "${subtitle[$i]}" ] && [ -z "${effect1[$i]}" ] ; then
			echo ""
			myecho "[dvd-slideshow] ERROR: no title text found in line:"
			myecho "[dvd-slideshow] ${thisline}"
			cleanup; exit 1
		fi
		if [ "${duration[$i]}" == '0' ] ; then
			myecho ""
			myecho "[dvd-slideshow] ERROR: Bad duration time of zero:"
			myecho "[dvd-slideshow]	$thisline"
			myecho "[dvd-slideshow] You need to specify a non-zero duration"
			cleanup; exit 1
		fi
		image_file[$i]=0 ; audio_file[$i]=0 ; avi_file[$i]=0
		duration_ms=`seconds2ms ${duration[$i]}`
		total_video_length="$(( $total_video_length + $duration_ms ))"
		titles=$(( $titles + 1 ))
        elif [ "${image[$i]}" == 'titlebar' ] || [ "${image[$i]}" == 'Titlebar' ] ; then
                if [ -z "${subtitle[$i]}" ] && [ -z "${effect1[$i]}" ] ; then
			echo ""
			myecho "[dvd-slideshow] ERROR: no titlebar text found in line:"
			myecho "[dvd-slideshow] ${thisline}"
			cleanup; exit 1
		fi
                if [ "${duration[$i]}" == '0' ] ; then
                        myecho ""
                        myecho "[dvd-slideshow] ERROR: Bad duration time of zero:"
                        myecho "[dvd-slideshow] $thisline"
                        myecho "[dvd-slideshow] You need to specify a non-zero duration"
                        cleanup; exit 1
                fi
                image_file[$i]=0 ; audio_file[$i]=0 ; avi_file[$i]=0
                duration_ms=`seconds2ms ${duration[$i]}`
                total_video_length="$(( $total_video_length + $duration_ms ))"
                titles=$(( $titles + 1 ))
	elif [ "${image[$i]}" == 'chapter' ] || [ "${image[$i]}" == 'Chapter' ] || [ "${image[$i]}" == 'CHAPTER' ] ; then
		image_file[$i]=0 ; audio_file[$i]=0 ; avi_file[$i]=0
		duration[$i]=0;
		duration_ms=`seconds2ms ${duration[$i]}`
#		total_video_length="$(( $total_video_length + $duration_ms ))"
	elif [ "${image[$i]}" == 'background' ] ; then
		if [ "${duration[$i]}" != 0 ] ; then
			background_slides=$(( $background_slides + 1 ))
		fi
		image_file[$i]=0 ; audio_file[$i]=0 ; avi_file[$i]=0
		duration_ms=`seconds2ms ${duration[$i]}`
		total_video_length="$(( $total_video_length + $duration_ms ))"
        elif [ "${filetype[$i]}" == 'avi' ] ; then
                image_file[$i]=0 ; audio_file[$i]=0 ; avi_file[$i]=1
		### need to get the length of the video here and set the duration
		### so the audio is the correct length!
		checkforprog tcprobe
		if [ -n "${duration[$i]}" ] ; then
			# user specified something in duration field:
			if [ "${duration[$i]}" == 'noaudio' ] ; then
				# do not use audio contained in video
				audio_track[$i]='noaudio'
			else
				audio_track[$i]='audio'
			fi
		fi
		effect1[$i]=`echo "${thisline}" | cut -s -d: -f3 | awk -F' #' '{print $1}'`  
		effect1_params[$i]=`echo "${thisline}" | cut -s -d: -f4 | awk -F' #' '{print $1}' | tr -d \[:blank:\]`
		effect2[$i]=`echo "${thisline}" | cut -s -d: -f5 | awk -F' #' '{print $1}'`
		effect2_params[$i]=`echo "${thisline}" | cut -s -d: -f6 | awk -F' #' '{print $1}' | tr -d \[:blank:\]`
        	video_length=`tcprobe -i "${image[$i]}" 2> /dev/null | grep 'duration=' | awk -F'duration=' '{print $2}'`
		it=`hms2seconds "$video_length"`
		duration_ms=`seconds2ms $it`
		duration[$i]="`hms2seconds $video_length`"
		total_video_length="$(( $total_video_length + $duration_ms ))"
		echo ""
        	myecho "[dvd-slideshow] Found AVI video ${image[$i]} length=$video_length duration=${duration[$i]}"
		myechon "[dvd-slideshow] "
		## optionally copy images to new directory for backup onto dvd:
		newname=`echo "${slideshow_name}" | sed -e 's/ /_/g'`
		if [ "$copy" -eq 1 ] ; then
			mkdir -p "$outdir/$newname"_pics
		fi
		if [ "$copy" -eq 1 ] ; then
			cp -af "${image[$i]}" "$outdir/$newname"_pics
		fi
		moviefiles=$(( $moviefiles + 1 ))
	elif [ "${filetype[$i]}" == 'ogg' ] || [ "${filetype[$i]}" == 'mp3' ] || [ "${filetype[$i]}" == 'wav' ] || [ "${image[$i]}" == 'silence' ] || [ "${filetype[$i]}" == 'm4a' ] || [ "${filetype[$i]}" == 'aac' ] ; then
		## make sure audio file exists (if not silence):
                if [ "${image[$i]}" != 'silence' -a ! -f "${image[$i]}" ] ; then
			myecho ""
                	myecho "[dvd-slideshow] ERROR: Audio file ${image[$i]} does not exist"
                	cleanup; exit 1
                fi
		audio_inside_txtfile=1
		audio_file[$i]=1 ; image_file[$i]=0 ; avi_file[$i]=0
		effect1[$i]=`echo "${thisline}" | cut -d: -f3 | awk -F' #' '{print $1}'`  # no subtitle for audio 
		effect1_params[$i]=`echo "${thisline}" | cut -d: -f4 | awk -F' #' '{print $1}' | tr -d \[:blank:\]`
		effect2[$i]=`echo "${thisline}" | cut -d: -f5 | awk -F' #' '{print $1}'`
		effect2_params[$i]=`echo "${thisline}" | cut -d: -f6 | awk -F' #' '{print $1}' | tr -d \[:blank:\]`
		if [ "${effect1[$i]}" != 'fadein' ] && [ -n "${effect1[$i]}" ]; then
			myecho ""
			myecho "[dvd-slideshow] ERROR: First audio effect must be fadein"
			cleanup; exit 1
		fi
		if [ "${effect2[$i]}" != 'fadeout' ] && [ -n "${effect2[$i]}" ]; then
			myecho ""
			myecho "[dvd-slideshow] ERROR: Second audio effect must be fadeout"
			cleanup; exit 1
		fi
		## get audio track number:
		if [ -z "${duration[$i]}" ] ; then 
			# duration is the field for the audio track numuber
			# if empty, assume track=1
			audio_track[$i]='1'
		elif [ "${duration[$i]}" -gt 2 ]; then
			myecho ""
			myecho "[dvd-slideshow] ERROR: Only 2 audio tracks supported at this time."
			myecho "[dvd-slideshow]        Fix this audio file track number!"
			myecho "[dvd-slideshow]        $thisline"
			cleanup; exit 1
		else
			# use the duration as the audio track number:
			audio_track[$i]="${duration[$i]}"
		fi
		## get filetype:
		if [ "${filetype[$i]}" == 'ogg' ] ; then
			checkfor_oggdec
		fi
		if [ "${filetype[$i]}" == 'mp3' ] ; then
			checkfor_lame
		fi
		if [ "${filetype[$i]}" == 'm4a' ] || [ "${filetype[$i]}" == 'aac' ] ; then
			checkfor_faad
		fi
		duration[$i]=0
		audiofiles=$(( $audiofiles + 1 ))
	else
		echo "else:  no image found"
		image_file[$i]=0 ; audio_file[$i]=0 ; avi_file[$i]=0
		duration_ms=`seconds2ms ${duration[$i]}`
		total_video_length="$(( $total_video_length + $duration_ms ))"
	fi
	[ $debug -ge 3 ] && echo "[dvd-slideshow:parsetxtfile] Total video length = $total_video_length"
#	echo "line=$i"
	line=$(( $line + 1 ))
	i=$(( $i + 1 ))
#done  ## end of loop over input .txt file  ##################################
done < "$tmpdir"/"$tmptxtfile"
finish_progressbar $line $total_lines

# check to see if any functions had errors:
if [ $function_error -eq 1 ] ; then
	cleanup
	exit 1
fi

##############################################
#  Set default font:
if [ -d "$font_dir" ] ; then
	default_font1=`find $font_dir -name $default_fontname1 | head -n 1` 
fi
if [ -d "$font_dir2" ] ; then
	default_font2=`find $font_dir2 -name $default_fontname1 | head -n 1`
fi
if [ -d "$font_dir3" ] ; then
	default_font3=`find $font_dir3 -name $default_fontname1 | head -n 1`
fi
if [ -d "$font_dir" ] ; then
	default_font4=`find $font_dir -name $default_fontname2 | head -n 1` 
fi

# verify fonts exist:
if [ -f "$default_font1" ] ; then 
	default_font="$default_font1"
elif [ -f "$default_font2" ] ; then
	default_font="$default_font2"
elif [ -f "$default_font3" ] ; then
	default_font="$default_font3"
elif [ -f "$default_font4" ] ; then
	default_font="$default_font4"
else
	default_font="Helvetica-Bold"
	myecho "[dvd-slideshow] Cannot find default fonts.  Using default ImageMagick font."
fi

if [ -n "$title_font" ] ; then   # title font passed
        if [ ! -f "$title_font" ] ; then  # look in font directory
                echo title_font="`find "font_dir" -name "$title_font" | head -n 1`"
                title_font="`find "font_dir" -name "$title_font" | head -n 1`"
                if [ ! -f "$title_font" ] ; then
                        echo "Error:  bad title_font filename"
                fi
        fi
fi
if [ -n "$subtitle_font" ] ; then   # title font passed
        if [ ! -f "$subtitle_font" ] ; then  # look in font directory
                echo subtitle_font="`find "font_dir" -name "$subtitle_font" | head -n 1`"
                subtitle_font="`find "font_dir" -name "$subtitle_font" | head -n 1`"
                if [ ! -f "$subtitle_font" ] ; then
                        echo "Error:  bad subtitle_font filename"
                fi
        fi
fi

if [ -z "$title_font" ] ; then  # no user font passed in variables
	title_font="$default_font"
else
	title_font="$title_font"
fi

if [ -z "$subtitle_font" ] ; then  # no user font passed in variables
	subtitle_font="$default_font"
else
	subtitle_font="$subtitle_font"
fi


#############################################################################

## summarize scan of .txt file:
if [ -n "$themefile" ] ; then
	myecho "[dvd-slideshow] Using theme $( truncate_filename $themefile )"
fi
if [ $commandline_audiofiles -eq 0 ] ; then
	myecho "[dvd-slideshow] Found $imagefiles images."
	myecho "[dvd-slideshow] Found $audiofiles audio files."
elif [ $audiofiles -eq 0 ] ; then
	myecho "[dvd-slideshow] Found $imagefiles images."
	myecho "[dvd-slideshow] Found $commandline_audiofiles audio files."
else
	myecho "[dvd-slideshow] Found $imagefiles images"
	myecho "[dvd-slideshow] Found $commandline_audiofiles audio files on command-line."
	myecho "[dvd-slideshow] Found $audiofiles audio files in .txtfile."
fi
myecho "[dvd-slideshow] Found $background_slides background slides."
myecho "[dvd-slideshow] Found $titles title slides."
myecho "[dvd-slideshow] Found $transitions transitions (fadein/fadeout/crossfade/wipe)."
# myecho ", and $moviefiles videos"

# setup audio parameters
if [ "$vcd" -eq 1 ] ; then
        ac3=0  # force mp2
        audio_bitrate=224
	video_bitrate='1152'
        audio_sample_rate=44100
	mplex_type=1
	aspect_ratio="4:3"
	mpeg2enc_params="-v 0 -4 2 -2 1 -H -b 1150 -n n -s -f $mplex_type"
elif [ "$svcd" -eq 1 ] ; then
        ac3=0  # force mp2
        audio_bitrate=128
	video_bitrate='4500'
        audio_sample_rate=44100
	mplex_type=4
	aspect_ratio="4:3"
	mpeg2enc_params="-v 0 -4 2 -2 1 -H -b 2500 -n n -s -f $mplex_type"
else
        audio_bitrate=192
	video_bitrate='3800'
        audio_sample_rate=48000 
	mplex_type=8
	if [ "$widescreen" -eq 1 ] ; then
		aspect_ratio="16:9"
		mpeg2enc_params="-v 0 -a 3 -q 4 -4 2 -2 1 -s -M 0 -f $mplex_type"
	else
		aspect_ratio="4:3"
	#	mpeg2enc_params="-v 0 -a 2 -q 4 -4 2 -2 1 -s -M 0 -f $mplex_type"
		mpeg2enc_params="-v 0 -a 2 -q 4 -4 2 -2 1 -s -M 0 -f $mplex_type -E -N -R 2"
	fi
fi


## setup video parameters:
if [ "$output_format" == 'flv' ] ; then
	video_bitrate=100  # this works ok for 320x240. 
	## video_bitrate will be scaled if user specifies -s 240x180, for example, by about 1/2
	video_suffix='flv'
	framerate='15'  # is this needed for .flv?
	frames_per_ms=15000  # in ms
	sq_pixel_multiplier=$(( 1000 ))  # keep pixels square?
	ppmtoy4m_frc='15:1'  # 15 fps
	ppmtoy4m_aspect='1:1'  # square pixels
		# see http://www.uwasa.fi/~f76998/video/conversion
	dvd_width='320' ; dvd_height='240'
elif [ "$output_format" == 'swf' ] ; then
	video_bitrate=50
	video_suffix='swf'
	framerate='15'  # is this needed for .swf?
	frames_per_ms=15000  # in ms
	sq_pixel_multiplier=$(( 1000 ))  # keep pixels square?
	ppmtoy4m_frc='15:1'  # 15 fps
	ppmtoy4m_aspect='1:1'  # square pixels
		# see http://www.uwasa.fi/~f76998/video/conversion
	dvd_width='320' ; dvd_height='240'
elif [ "$output_format" == 'mp4' ] ; then
	video_suffix='mp4'
	framerate='29.97'  # is this needed for .
	frames_per_ms=29970  # in ms
#	sq_pixel_multiplier=$(( 1000 * 320 / 240 ))  # keep pixels square?
	ppmtoy4m_frc='30000:1001'
	ppmtoy4m_aspect='10:11'  # 4:3
		# see http://www.uwasa.fi/~f76998/video/conversion
	dvd_width='320' ; dvd_height='240'
else 
	video_suffix='mpg'
	if [ "$pal" -eq 1 ] ; then
		framerate='25'
		frames_per_ms=25000  # in ms
	#	sq_to_dvd_pixels='93.75x100%' # i.e., make the horizontal smaller
#		sq_pixel_multiplier=$(( 1000 * 540 / 576 ))
		ppmtoy4m_frc='25:1'
		ppmtoy4m_aspect='59:54'
			# see http://www.uwasa.fi/~f76998/video/conversion
		if [ "$vcd" -eq 1 ] ; then
			dvd_width='352' ; dvd_height='288'
			ffmpeg_target='pal-vcd'
		elif [ "$svcd" -eq 1 ] ; then
			dvd_width='480' ; dvd_height='576'
			ffmpeg_target='pal-svcd'
		elif [ "$high_quality" -eq 1 ] ; then
			dvd_width='720' ; dvd_height='576'
			ffmpeg_target='pal-dvd'
		elif [ "$low_quality" -eq 1 ] ; then
			dvd_width='352' ; dvd_height='288'
			ffmpeg_target='pal-dvd'
		else
			dvd_width='720' ; dvd_height='576'
			ffmpeg_target='pal-dvd'
		fi
	else  ## NTSC
		framerate='29.97'
		frames_per_ms=29970  # in ms
	#	sq_to_dvd_pixels='112.5x100%' # i.e., make the horizontal 12% larger
#		sq_pixel_multiplier=$(( 1000 * 540 / 480 ))
		ppmtoy4m_frc='30000:1001'
		ppmtoy4m_aspect='10:11'
			# see http://www.uwasa.fi/~f76998/video/conversion
		if [ "$vcd" -eq 1 ] ; then
			dvd_width='352' ; dvd_height='240'
			ffmpeg_target='ntsc-vcd'
		elif [ "$svcd" -eq 1 ] ; then
			dvd_width='480' ; dvd_height='480'
			ffmpeg_target='ntsc-svcd'
		elif [ "$high_quality" -eq 1 ] ; then
			dvd_width='720' ; dvd_height='480'
			ffmpeg_target='ntsc-dvd'
		elif [ "$low_quality" -eq 1 ] ; then
			dvd_width='352' ; dvd_height='240'
			ffmpeg_target='ntsc-dvd'
		else
			dvd_width='720' ; dvd_height='480'
			ffmpeg_target='ntsc-dvd'
		fi
	fi
fi

resize_factor=`awk -vw=$dvd_width -vh=$dvd_height -var=$aspect_ratio 'BEGIN{if (ar=="4:3"){ar=4/3} else {ar=16/9};printf "%0.2f", (100/((h/w)*(ar)));exit;}'`
sq_to_dvd_pixels="${resize_factor}x100%"
sq_pixel_multiplier=$( printf %5.0f $( echo "scale=0; 10 * $resize_factor" | bc ) )
[ $debug -ge 2 ] && myecho "[dvd-slideshow] sq_to_dvd_pixels=$sq_to_dvd_pixels"
[ $debug -ge 2 ] && myecho "[dvd-slideshow] sq_pixel_multiplier=$sq_pixel_multiplier"

if [ -n "$output_size" ] ; then
	# used user-set size, instead of defaults!
	orig_dvd_width=$dvd_width ; orig_dvd_height=$dvd_height
	dvd_width=$( echo "$output_size" | cut -dx -f1 | tr -d \[:blank:\] )
	dvd_height=$( echo "$output_size" | cut -dx -f2 | tr -d \[:blank:\] )
	if [ "$output_format" == 'flv' ] ; then
		video_bitrate=$(( $video_bitrate * ( $dvd_width * $dvd_height ) / ( $orig_dvd_width * $orig_dvd_height ) ))
		myecho "[dvd-slideshow] Set new video bitrate to $video_bitrate kb/s"
	fi
fi

if [ -n "$output_framerate" ] ; then
	framerate="$output_framerate"
	frames_per_ms=$( echo "$output_framerate * 1000" | bc )
	frames_per_ms=$( printf %3.0f $frames_per_ms )
	myecho "[dvd-slideshow] Frames per sec * 1000 = $frames_per_ms"
	ppmtoy4m_frc="$framerate:1"  # fps  need to fix this to allow any option!
	myecho "[dvd-slideshow] ppmtoy4m frc=$ppmtoy4m_frc"
fi

[ -n "$border" ] && frame_border=$border || frame_border=0
frame_width=$(( $dvd_width - 2 * $frame_border ))
frame_height=$(( $dvd_height - 2 * $frame_border ))

if [ -n "$sharpen" -a "$sharpen" == "1" ] ; then
	sharpen='-unsharp 4.8x2.2+0.5+0.05'
else
	sharpen=''
fi

## summarize configuration:
[ "$pal" -eq 1 ] && ntsc_or_pal="PAL" || ntsc_or_pal="NTSC"
[ "$ac3" -eq 1 ] && mp2_or_ac3="AC3" || mp2_or_ac3="MP2"

#myecho "[dvd-slideshow] Configuration summary:"
[ "$vcd" -eq 1 ] && myecho "[dvd-slideshow] VCD mode"
[ "$svcd" -eq 1 ] && myecho "[dvd-slideshow] SVCD mode"
myecho "[dvd-slideshow] Video: $ntsc_or_pal $dvd_width"x"$dvd_height $framerate"fps" $aspect_ratio"
myecho "[dvd-slideshow] Audio: $mp2_or_ac3 $audio_sample_rate $audio_bitrate" 
myecho "[dvd-slideshow] Debug=$debug  Autocrop=$autocrop Subtitles=$subtitle_type Border=$frame_border"
if [ "$manual_chapter_markers" == 1 ] ; then
	myecho "[dvd-slideshow] Chapter markers= Manual"
fi	
if [ "$smp" == 1 ] ; then
	myecho "[dvd-slideshow] Using SMP optimizations for multi-processor machines"
fi	
if [ "$nocleanup" == 1 ] ; then
	myecho "[dvd-slideshow] Leaving all temporary files in temp directory"
fi	
myecho "[dvd-slideshow] Title_font=$(truncate_filename "$title_font")"
myecho "[dvd-slideshow] Subtitle_font=$(truncate_filename "$subtitle_font")"

## convert command-line audio files to wav format first, so we know how long they are:
if [ -n "${passed_audio[0]}" ] && [ $audio_inside_txtfile -eq 0 ] ; then  ## only command-line passed audio
	total_audio_length=0
	track=1 ; i=1
	myecho "[dvd-slideshow] Decoding command-line passed audio files..."
	for file in "${passed_audio[@]}"; do
		## verify files exist:
		if [ ! -f "$file" ] ; then
			myecho "[dvd-slideshow] ERROR: file $file does not exist."
			cleanup ; exit 1
		fi
		suffix=`echo "$file" | awk -F. '{print tolower($NF)}'`
		audio_index_padded=`addzeros "$i_audio"`
		if [ "$suffix" == "mp3" ] ; then
			myecho "[dvd-slideshow] Decoding mp3 audio: $file"
			lame --decode "$file" "$tmpdir/audio$track"_"$audio_index_padded.wav" 2> /dev/null
		elif [ "$suffix" == "ogg" ] ; then
			myecho "[dvd-slideshow] Decoding ogg audio: $file"
			oggdec --quiet -o "$tmpdir/audio$track"_"$audio_index_padded.wav" "$file"
		elif [ "$suffix" == "m4a" ] || [ "$suffix" == "aac" ] ; then
			myecho "[dvd-slideshow] Decoding m4a audio: $file"
			faad -o "$tmpdir/audio$track"_"$audio_index_padded.wav" "$file"
		elif [ "$suffix" == "wav" ] ; then
			myecho "[dvd-slideshow] Processing wav audio $file"
			cp "$file" "$tmpdir/audio$track"_"$audio_index_padded.wav"
		else
			myecho "[dvd-slideshow] ERROR:  Unknown audio file format.  Must be mp3, ogg, aac/mp4 or wav"
		fi	
		length=`wavlength "$tmpdir/audio$track"_"$audio_index_padded.wav"`
		length_array[$i]=`hms $length`
		total_audio_length="$(( $total_audio_length + $length ))"
#		myecho "[dvd-slideshow] length=$length total_audio_length=$total_audio_length"
		let i=$i+1
		i_audio=$(( $i_audio + 1 ))
	done
#	i=1
#	for file in "${passed_audio[@]}"; do
#		myecho "[dvd-slideshow] ${length_array[$i]} `basename \"$file\"`"
#		let i=$i+1
#	done
	# estimate total audio length:
	length_hms=`hms $total_audio_length`
elif [ -n "${passed_audio[0]}" ] && [ $audio_inside_txtfile -eq 1 ] ; then  ## only command-line passed audio
	myecho "[dvd-slideshow] WARNING:  You specified audio on the command line, and"
	myecho "[dvd-slideshow]           you have audio files inside your input .txt file"
	myecho "[dvd-slideshow]           Use one or the other, but not both!"
	myecho "[dvd-slideshow]           Ignoring command-line passed audio!"
	passed_audio=''
fi

video_time_hms=`hms $total_video_length`
myecho "[dvd-slideshow] Total audio length = $length_hms"
myecho "[dvd-slideshow] Total video length = $video_time_hms"

if [ ! -d "$outdir" ] ; then	
#        myecho "ERROR... output directory does not exist!"
#        exit
	myecho "creating directory $outdir"
	mkdir -p "$outdir"  # create directory
fi

#mpeg2enc_params='-v 0 -a 2 -q 8 -s -M 0 -f $mplex_type -b 6000 -I 0'
#mpeg2enc_params='-v 0 -a 2 -s -M 0 -f $mplex_type -b 6000'


if [ "$low_quality" -eq 1 ] ; then
	myecho "[dvd-slideshow] WARNING: Using low-quality mode."
	myecho "[dvd-slideshow]   This mode is for testing only."
	myecho "[dvd-slideshow]   output resolution is $dvd_width"x"$dvd_height"
	myecho "[dvd-slideshow]   Ignore [mpeg2enc] warnings (usually)"
elif [ "$high_quality" -eq 1 ] ; then
	myecho "[dvd-slideshow] Using high-quality mode.  "
elif [ "$svcd" -eq 1 ] ; then
	myecho "[dvd-slideshow] Using svcd mode.  "
elif [ "$vcd" -eq 1 ] ; then
	myecho "[dvd-slideshow] Using vcd mode.  "
fi
has_subtitles=0
has_subtitles2=0
frame_time=0
total_slideshow_frames=0

orig_slideshow_name="${slideshow_name}"
slideshow_name=`echo "${slideshow_name}" | sed -e 's/ /_/g'`
if [ "$orig_slideshow_name" != "$slideshow_name" ] ; then
	myecho "[dvd-slideshow] Output filename is $slideshow_name"
fi
myecho "[dvd-slideshow] Temp dir is $( truncate_filename "$outdir"/"dvd-slideshow_temp_$$" )"

# create the mpeg2enc pipeline here if we are in $yuvcat mode
# create the fifo
rm -f "$tmpdir/$yuvfifo"
mkfifo "$tmpdir/$yuvfifo"

if [ "$mpeg_encoder" == 'ffmpeg' ] ; then
	if [ "$output_format" == 'flv' ] ; then
		# do pass one first, then add audio at the end during pass 2?
		# don't do mplex, do second pass instead.
		myecho "[dvd-slideshow] Exporting .flv file"
		ffmpeg -f yuv4mpegpipe -i "$tmpdir"/$yuvfifo -r $framerate -b $video_bitrate -an -aspect $aspect_ratio -s "$dvd_width"x"$dvd_height" -y -f flv "$tmpdir/video.flv" >> "$outdir/$logfile" 2>&1 &
	elif [ "$output_format" == 'swf' ] ; then
		# do pass one first, then add audio at the end during pass 2?
		# don't do mplex, do second pass instead.
		myecho "[dvd-slideshow] Exporting .swf file"
		ffmpeg -f yuv4mpegpipe -i "$tmpdir"/$yuvfifo -r $framerate -b $video_bitrate -an -aspect $aspect_ratio -s "$dvd_width"x"$dvd_height" -y -f swf "$tmpdir/video.swf" >> "$outdir/$logfile" 2>&1 &
	elif [ "$output_format" == 'mp4' ] ; then   # NOT TESTED YET
		# do pass one first, then add audio at the end during pass 2?
		# don't do mplex, do second pass instead.
		myecho "[dvd-slideshow] Exporting .mp4 file"
		ffmpeg -f yuv4mpegpipe -i "$tmpdir"/$yuvfifo -r $framerate -an -aspect $aspect_ratio -s "$dvd_width"x"$dvd_height" -y -f mp4 -vcodec mpeg4 "$tmpdir/video.mp4" >> "$outdir/$logfile" 2>&1 &
	elif [ "$output_format" == 'mp4_ipod' ] ; then   # NOT TESTED YET
		# see http://www.ubuntuforums.org/showthread.php?t=114946
		# do pass one first, then add audio at the end during pass 2?
		# don't do mplex, do second pass instead.
		myecho "[dvd-slideshow] Exporting ipod .mp4 file"
		ffmpeg -f yuv4mpegpipe -i "$tmpdir"/$yuvfifo -target $ffmpeg_target -r $framerate -an -aspect $aspect_ratio -s "$dvd_width"x"$dvd_height" -y -f mp4 -vcodec mpeg4 -maxrate 1000 -b 700 -qmin 3 -qmax 5 -bufsize 4096 -g 300 "$tmpdir/video.mov" >> "$outdir/$logfile" 2>&1 &
	else  # default mpeg2 video for dvd/vcd
		ffmpeg -f yuv4mpegpipe -i "$tmpdir"/$yuvfifo -target $ffmpeg_target -r $framerate -an -aspect $aspect_ratio -s "$dvd_width"x"$dvd_height" -y -bf 2 -f mpeg2video "$tmpdir/video.mpg" >> "$outdir/$logfile" 2>&1 &
#		ffmpeg -f yuv4mpegpipe -i "$tmpdir"/$yuvfifo -r $framerate -an -aspect $aspect_ratio -s "$dvd_width"x"$dvd_height" -y -f mpeg2video "$tmpdir/video.mpg" >> "$outdir/$logfile" 2>&1 &
	fi
else
	mpeg2enc $mpeg2enc_params -o "$tmpdir/video.mpg" < "$tmpdir"/$yuvfifo >> "$outdir/$logfile" 2>&1 & 
fi
yuvpid=${!}

# open the fifo for writing as fd 3 (unlikely to be used!)
exec 3>"$tmpdir/$yuvfifo"

## make both a slideshow_background file and a title_background file
if [ -f "${bgfile}" ] ; then
	background "$bgfile"
else
	background "black"
fi

# prepare transparent background file:
transparent_bg="$tmpdir"/transparent_background.png
normal_bg="$tmpdir/slideshow_background.ppm"
convert -size "$dvd_width"'x'"$dvd_height" xc:transparent -type TrueColor -depth 8 "$transparent_bg"

myecho "[dvd-slideshow]############################################################"

total_slideshow_time=0
total_slideshow_frames=0

let i=0 # full
let v=0 # vob
image_number=1
for file in "${image[@]}"; do
	## convert i to a 2-digit text version so we can cat the mpgs together
	## in the correct order easily:
	di=`addzeros $i`
	## check for variable settings first:
#	echo "i=$i file=$file duration=${duration[$i]}"
	set_variables "$file" 1
	it=`set_variables "$file" 0`
	if [ -n "$it" ] ; then
		myecho "[dvd-slideshow] Set variable $it"
		i=$(( $i+1 )) ; continue
	fi
	
	##### Set slide duration
	if [ -z "${duration[$i]}" ] ; then
		myecho "[dvd-slideshow] WARNING:  No duration specified for ${image[$i]}"
		myecho "[dvd-slideshow]	     Using default duration of 5 seconds"
		duration[$i]=5
		duration[$i]=`seconds2ms ${duration[$i]}`  # duration in thousandths of a sec.
	elif [ "${duration[$i]}" == 'audio' ] ; then
		## make the duration the length of the last audio track
		# because audio is rendered in the baackground now, we need
		# to wait for it to finish so the .wav file is present:
		waitforfile "$tmpdir/audio$track"_"$audio_index_padded.wav" # last audio file
		song_length_ms=`wavlength "$tmpdir/audio$track"_"$audio_index_padded.wav"`
		if [ -z "$song_length_ms" ] ; then
			myecho '# ERROR: You must have an audio track before a slide specifying "audio"'
			cleanup; exit 1
		fi
		duration[$i]="$song_length_ms"  # duration in thousandths of a sec.
	else  # duration should be ok
		duration[$i]=`seconds2ms ${duration[$i]}`  # duration in thousandths of a sec.
	fi
	
	## number of frames to render for this picture:
        frames=`div1000 $(( $frames_per_ms * ${duration[$i]} / 1000 ))` # both duration and fps are in ms
	frames=$( duration2frames ${duration[$i]} )
	rendered_frames="$frames"
	## get start frame & time:
	slide_start_frame=$(( $total_slideshow_frames ))
	slide_start_time=$(( $slide_start_frame *1000 * 1000 / $frames_per_ms )) ## in thousandths of a sec.
	slide_start_hms=`hms "$slide_start_time"`
	if [ $debug -ge 1 ] ; then
		myecho "[dvd-slideshow] start_frame_number=$slide_start_frame start_time=$slide_start_hms"
#		myecho "[dvd-slideshow] This line duration=`echo ${duration[$i]} | tr -d \[:blank:\]` ms"
	fi


	if [ $debug -ge 2 ] ; then
		[ -n "${effect1[$i]}" ] && myecho "[dvd-slideshow] effect1='${effect1[$i]}' effect_params='${effect1_params[$i]}'"
		[ -n "${effect1[$i]}" ] && myecho "[dvd-slideshow] effect2='${effect2[$i]}' effect_params='${effect2_params[$i]}'"
	fi
        if [ "$file" == 'title' -o "$file" == 'Title' ] ; then # TITLE
                if [ -n "${effect1[$i]}" ] ; then
                        myecho "[dvd-slideshow] WARNING: This keyword has changed since dvd-slideshow 0.7.5"
                        myecho "[dvd-slideshow]       Title only has one argument. Use titlebar for"
                        myecho "[dvd-slideshow]       the same menu type as before. See documentation."
                        myecho "[dvd-slideshow]       Only using one title line, centered in the screen."
                fi
                if [ -n "${subtitle[$i]}" ] ; then
                	title="${subtitle[$i]}"
		elif [ -n "${effect1[$i]}" ] ; then
                	title="${effect1[$i]}"
		else
			myecho "[dvd-slideshow] ERROR: no title text found in line:"
			myecho "[dvd-slideshow] ${thisline}"
			cleanup; exit 1
		fi
                myecho "[dvd-slideshow] Title `hms ${duration[$i]}`"
                myecho "[dvd-slideshow]         Title=$title"

		# calculate actual frames rendered:
		previous_increment="`previouseffectincrement`"
		previous_duration="${duration[$i-$previous_increment]}" # already in thousandths.
		previous_slide="${image[$i-$previous_increment]}"
		next_increment="`nexteffectincrement`"
		next_duration=`seconds2ms "${duration[$i+$next_increment]}"` # already in thousandths.
		next_slide="${image[$i+$next_increment]}"
		[ -z "$previous_slide" ] && previous_slide=0
		[ -z "$next_slide" ] && next_slide=0
#		echo "duration=${duration[$i]}  previous_inc=$previous_increment previous_slide=$previous_slide previous_duration=$previous_duration"
		if [ "$previous_slide" == 'crossfade' ] || [ "$previous_slide" == 'wipe' ] ; then
			# subtract 1/2 time from rendered time:
			rendered_time=$(( ${duration[$i]} - $previous_duration / 2 )) 
			old_rendered_time=$(( ${duration[$i]} + $previous_duration ))
		elif [ "$previous_slide" == 'fadein' ] ; then
			rendered_time=$(( ${duration[$i]} - $previous_duration )) 
			old_rendered_time=$(( ${duration[$i]} + $previous_duration ))
		else  # no previous fade
			rendered_time=${duration[$i]}
			old_rendered_time=$rendered_time
		fi
#		echo "duration=${duration[$i]}  next_increment=$next_increment next_slide=$next_slide next_duration=$next_duration"
		if [ "$next_slide" == 'crossfade' ] || [ "$next_slide" == 'wipe' ] ; then
			# subtract time from rendered time:
			rendered_time=$(( $rendered_time - $next_duration / 2 )) 
			old_rendered_time=$(( $rendered_time + $next_duration )) 
		elif [ "$next_slide" == 'fadeout' ] ; then
			rendered_time=$(( $rendered_time - $next_duration )) 
			old_rendered_time=$(( $rendered_time + $next_duration )) 
		else  # no next fade
			rendered_time=$rendered_time	
			old_rendered_time=$old_rendered_time
		fi

		set_end_frame_time $rendered_time
		rendered_frames="$frames_to_render"

		[ $debug -ge 2 ] && echo "[dvd-slideshow] rendered_frames=$rendered_frames"
		if [ "$rendered_frames" -le 0 ] ; then
			echo "[dvd-slideshow] WARNING: Frames rendered are less than 1!"
			echo "[dvd-slideshow] 	Either you specified a duration = 0 "
			echo "[dvd-slideshow] 	or the fade time(s) are longer than the slide time."
			echo "[dvd-slideshow] 	!! This timing changed in dvd-slideshow 0.8.0."
			echo "[dvd-slideshow] 	!! so now the fades get applied on top of the slides"
			echo "[dvd-slideshow] 	!! and thus fades do not add time to the slideshow."
			echo "[dvd-slideshow] 	MODIFYING SLIDE FRAMES RENDERED to $old_rendered_frames"
			rendered_frames="$old_rendered_frames"
		fi
                subtitle[$i]=''  # set subtitle to nothing so we don't get a subtitle
                ## now the slide may already exist if we had a fadein or crossfade before
                if [ ! -f "$tmpdir/slide_$i.ppm" ] ; then
                        titleslide "$title"
                        waitforfile "$tmpdir/title.ppm"
                        cp "$tmpdir/title.ppm" "$tmpdir/slide_$i.ppm"
                fi
		encode "$tmpdir/slide_$i.ppm" $rendered_frames
                [ "$manual_chapter_markers" -eq 0 ] && write_chap=1
		[ $debug -ge 1 ] &&  myecho "[dvd-slideshow] end_frame_number=$slide_end_frame end_time=$slide_end_hms"
                myecho "[dvd-slideshow]############################################################"
        elif [ "$file" == 'titlebar' -o "$file" == 'Titlebar' ] ; then # TITLEBAR
                title1="${subtitle[$i]}"
                subtitle[$i]=''  # set subtitle to nothing so we don't get a subtitle
                title2="${effect1[$i]}"
                myecho "[dvd-slideshow] Titlebar `hms ${duration[$i]}`"
	        myecho "[dvd-slideshow]         Title1=$title1"
		myecho "[dvd-slideshow]         Title2=$title2"

		# calculate actual frames rendered:
		previous_increment="`previouseffectincrement`"
		previous_duration="${duration[$i-$previous_increment]}" # already in thousandths.
		previous_slide="${image[$i-$previous_increment]}"
		next_increment="`nexteffectincrement`"
		next_duration=`seconds2ms "${duration[$i+$next_increment]}"` # already in thousandths.
		next_slide="${image[$i+$next_increment]}"
		[ -z "$previous_slide" ] && previous_slide=0
		[ -z "$next_slide" ] && next_slide=0
#		echo "duration=${duration[$i]}  previous_inc=$previous_increment previous_slide=$previous_slide previous_duration=$previous_duration"
		if [ "$previous_slide" == 'crossfade' ] || [ "$previous_slide" == 'wipe' ] ; then
			# subtract 1/2 time from rendered time:
			rendered_time=$(( ${duration[$i]} - $previous_duration / 2 )) 
			old_rendered_time=$(( ${duration[$i]} + $previous_duration ))
		elif [ "$previous_slide" == 'fadein' ] ; then
			rendered_time=$(( ${duration[$i]} - $previous_duration )) 
			old_rendered_time=$(( ${duration[$i]} + $previous_duration ))
		else  # no previous fade
			rendered_time=${duration[$i]}
			old_rendered_time=$rendered_time
		fi
#		echo "duration=${duration[$i]}  next_increment=$next_increment next_slide=$next_slide next_duration=$next_duration"
		if [ "$next_slide" == 'crossfade' ] || [ "$next_slide" == 'wipe' ] ; then
			# subtract time from rendered time:
			rendered_time=$(( $rendered_time - $next_duration / 2 )) 
			old_rendered_time=$(( $rendered_time + $next_duration )) 
		elif [ "$next_slide" == 'fadeout' ] ; then
			rendered_time=$(( $rendered_time - $next_duration )) 
			old_rendered_time=$(( $rendered_time + $next_duration )) 
		else  # no next fade
			rendered_time=$rendered_time	
			old_rendered_time=$old_rendered_time
		fi

		set_end_frame_time $rendered_time
		rendered_frames="$frames_to_render"

		if [ "$rendered_frames" -le 0 ] ; then
			echo "[dvd-slideshow] WARNING: Frames rendered are less than 1!"
			echo "[dvd-slideshow] 	Either you specified a duration = 0 "
			echo "[dvd-slideshow] 	or the fade time(s) are longer than the slide time."
			echo "[dvd-slideshow] 	!! This timing changed in dvd-slideshow 0.8.0."
			echo "[dvd-slideshow] 	!! so now the fades get applied on top of the slides"
			echo "[dvd-slideshow] 	!! and thus fades do not add time to the slideshow."
			echo "[dvd-slideshow] 	MODIFYING SLIDE FRAMES RENDERED to $old_rendered_frames"
			rendered_frames="$old_rendered_frames"
		fi

                ## now the slide may already exist if we had a fadein or crossfade before
                if [ ! -f "$tmpdir/slide_$i.ppm" ] ; then
                        titlebarslide "$title1" "$title2"
                        waitforfile "$tmpdir/title.ppm"
                        cp "$tmpdir/title.ppm" "$tmpdir/slide_$i.ppm"
                fi
		encode "$tmpdir/slide_$i.ppm" $rendered_frames
                [ "$manual_chapter_markers" -eq 0 ] && write_chap=1
		[ $debug -ge 1 ] &&  myecho "[dvd-slideshow] end_frame_number=$slide_end_frame end_time=$slide_end_hms"
               	myecho "[dvd-slideshow]############################################################"
	elif [ "$file" == 'musictitle' ] ; then # MUSICTITLE
		## add a music-video style title page
		## format is:
		## musictitle:duration:subtitle:MusicTitle:MusicArtist;MusicAlbum
		Title="Title: ${effect1[$i]}"
		Artist="Artist: `echo ${effect1_params[$i]} | awk -F';' '{print $1}'`"
		Album="Album: `echo ${effect1_params[$i]} | awk -F';' '{print $2}'`"
#		subtitle[$i]=''  # set subtitle to nothing so we don't get a subtitle
		myecho "[dvd-slideshow] Making musictitle slide:"
		myecho "[dvd-slideshow] $Title $Artist $Album"
		[ -n "${subtitle[$i]}" ] && myecho "[dvd-slideshow] Subtitle""= ${subtitle[$i]}"

		# calculate actual frames rendered:
		previous_increment="`previouseffectincrement`"
		previous_duration="${duration[$i-$previous_increment]}" # already in thousandths.
		previous_slide="${image[$i-$previous_increment]}"
		next_increment="`nexteffectincrement`"
		next_duration=`seconds2ms "${duration[$i+$next_increment]}"` # already in thousandths.
		next_slide="${image[$i+$next_increment]}"
		[ -z "$previous_slide" ] && previous_slide=0
		[ -z "$next_slide" ] && next_slide=0
#		echo "duration=${duration[$i]}  previous_inc=$previous_increment previous_slide=$previous_slide previous_duration=$previous_duration"
		if [ "$previous_slide" == 'crossfade' ] || [ "$previous_slide" == 'wipe' ] ; then
			# subtract 1/2 time from rendered time:
			rendered_time=$(( ${duration[$i]} - $previous_duration / 2 )) 
			old_rendered_time=$(( ${duration[$i]} + $previous_duration ))
		elif [ "$previous_slide" == 'fadein' ] ; then
			rendered_time=$(( ${duration[$i]} - $previous_duration )) 
			old_rendered_time=$(( ${duration[$i]} + $previous_duration ))
		else  # no previous fade
			rendered_time=${duration[$i]}
			old_rendered_time=$rendered_time
		fi
#		echo "duration=${duration[$i]}  next_increment=$next_increment next_slide=$next_slide next_duration=$next_duration"
		if [ "$next_slide" == 'crossfade' ] || [ "$next_slide" == 'wipe' ] ; then
			# subtract time from rendered time:
			rendered_time=$(( $rendered_time - $next_duration / 2 )) 
			old_rendered_time=$(( $rendered_time + $next_duration )) 
		elif [ "$next_slide" == 'fadeout' ] ; then
			rendered_time=$(( $rendered_time - $next_duration )) 
			old_rendered_time=$(( $rendered_time + $next_duration )) 
		else  # no next fade
			rendered_time=$rendered_time	
			old_rendered_time=$old_rendered_time
		fi

		set_end_frame_time $rendered_time
		rendered_frames="$frames_to_render"

		if [ "$rendered_frames" -le 0 ] ; then
			echo "[dvd-slideshow] WARNING: Frames rendered are less than 1!"
			echo "[dvd-slideshow] 	Either you specified a duration = 0 "
			echo "[dvd-slideshow] 	or the fade time(s) are longer than the slide time."
			echo "[dvd-slideshow] 	!! This timing changed in dvd-slideshow 0.8.0."
			echo "[dvd-slideshow] 	!! so now the fades get applied on top of the slides"
			echo "[dvd-slideshow] 	!! and thus fades do not add time to the slideshow."
			echo "[dvd-slideshow] 	MODIFYING SLIDE FRAMES RENDERED to $old_rendered_frames"
			rendered_frames="$old_rendered_frames"
		fi

                ## now the slide may already exist if we had a fadein or crossfade before
                if [ ! -f "$tmpdir/slide_$i.ppm" ] ; then
                        musictitleslide "$Title" "$Artist" "$Album"
                        waitforfile "$tmpdir/title.ppm"
                        mv "$tmpdir/title.ppm" "$tmpdir/slide_$i.ppm"
                fi
		encode "$tmpdir/slide_$i.ppm" $rendered_frames
		[ "$manual_chapter_markers" -eq 0 ] && write_chap=1
		[ $debug -ge 1 ] &&  myecho "[dvd-slideshow] end_frame_number=$slide_end_frame end_time=$slide_end_hms"
                myecho "[dvd-slideshow]############################################################"
        elif [ "${avi_file[$i]}" -eq 1 ] ; then  ##########  AVI 
		## use ffmpeg to encode video.  No audio.  
		myecho "[dvd-slideshow] AVI file passed."
		[ "$manual_chapter_markers" -eq 0 ] && write_chap=1
		# check for bad syntax:
		previous_increment="`previouseffectincrement`"
		previous_duration="${duration[$i-$previous_increment]}" # already in thousandths.
		next_increment="`nexteffectincrement`"
		next_duration=`seconds2ms "${duration[$i+$next_increment]}"` # already in thousandths.
		if [ "${image[$i-$previous_increment]}" == 'fadein' ] || [ "${image[$i-$previous_increment]}" == 'crossfade' ] || [ "${image[$i-$previous_increment]}" == 'wipe' ] ; then 
			myecho "[dvd-slideshow] ERROR: Cannot fadein or crossfade to a .avi file (yet)"
			exit 1
		fi
		if [ "${image[$i+$next_increment]}" == 'fadeout' ] || [ "${image[$i+$next_increment]}" == 'crossfade' ] || [ "${image[$i+$next_increment]}" == 'wipe' ]; then
			myecho "[dvd-slideshow] ERROR: Cannot fadeout or crossfade from a .avi file (yet)"
			exit 1
		fi
		## encode video
#		myecho "[dvd-slideshow] Encoding ${image[$i]} to video.mpg"
		encode_video "${image[$i]}"

		# convert audio to wav format?  
		echo "audio_track[$i] = ${audio_track[$i]}"
		if [ "${audio_track[$i]}" != 'noaudio' ] ; then
			myecho "[dvd-slideshow] Processing audio from video file..."
			## now set the starting and ending point of this audio track:
			audio_track[$i]=1
			audio1_effect1[$i_audio]="${effect1[$i]}"
			audio1_effect1_params[$i_audio]="${effect1_params[$i]}"
			audio1_effect2[$i_audio]="${effect2[$i]}"
			audio1_effect2_params[$i_audio]="${effect2_params[$i]}"
			audio_index="$i_audio"
			audio_index_padded=`addzeros "$i_audio"`
			audio_1[$i_audio]="$tmpdir/audio1_$audio_index_padded.wav"
#			echo "i_audio=$i_audio audio_index=$audio_index padded=$audio_index_padded"
#			echo "audio_1=${audio_1[$i_audio]}"
			i_audio=$(( $i_audio + 1 ))  # increment for next file

			ffmpeg -i "${image[$i]}" -y -vn -ar $audio_sample_rate -ac 2 "$tmpdir/audio1_$audio_index_padded".wav >> "$outdir/$logfile" 2>&1
			if [ $? -ne 0 ] ; then
				## ffmpeg errored
				myecho "[dvd-slideshow] ERROR during ffmpeg execution!"
				myecho "[dvd-slideshow] see $outdir/$logfile for details"
				cleanup; exit 1
			fi
			audio1_start[$audio_index]="$slide_start_time"   # in ms
			## set ending point of the audio track:
			if [ "$audio_index" -gt 0 ] ; then # not first audio track
				audio1_end[$(($audio_index-1))]="$slide_end_time"   # in ms from last slide
				myecho "[dvd-slideshow] Set end time for audio file $audio_index to `hms $slide_end_time`"
			else # set audio end to zero for now...
				audio1_end[$audio_index]=0   # in ms from last slide
			fi
			myecho "[dvd-slideshow] track=${audio_track[$i]} audio_start=$slide_start_time audio_end=$slide_end_time"
	#		myecho "[dvd-slideshow] track=${audio_track[$i]} audio_start=${audio1_start[$audio_index]} audio_end=${audio1_end[$audio_index]}"
			song_length_ms=`wavlength "$tmpdir/audio1_$audio_index_padded".wav`
			song_length_hms=`hms "$song_length_ms"`
			echo "[dvd-slideshow] Audio length ms=$song_length_ms  $song_length_hms"
		fi
		subtitle[$i]=''  # set subtitle to nothing so we don't get a subtitle
		set_end_frame_time ${duration[$i]}
#		end_frame_info $rendered_frames
		[ $debug -ge 1 ] &&  myecho "[dvd-slideshow] end_frame_number=$slide_end_frame end_time=$slide_end_hms"
		myecho "[dvd-slideshow]############################################################"
	elif [ "${image_file[$i]}" -eq 1 ] && [ -z "${effect1[$i]}" ] ; then  # JPG IMAGE
		## use real jpeg. 
		## now the slide may already exist if we had a fadein or crossfade before
		myecho "[dvd-slideshow] $image_number/$imagefiles $(truncate_filename "$file") `hms ${duration[$i]}`"
		[ -n "${subtitle[$i]}" ] && myecho "[dvd-slideshow] Subtitle""= ${subtitle[$i]}"

		# calculate actual frames rendered:
		previous_increment="`previouseffectincrement`"
		previous_duration="${duration[$i-$previous_increment]}" # already in thousandths.
		previous_slide="${image[$i-$previous_increment]}"
		next_increment="`nexteffectincrement`"
		next_duration=`seconds2ms "${duration[$i+$next_increment]}"` # already in thousandths.
		next_slide="${image[$i+$next_increment]}"
		[ -z "$previous_slide" ] && previous_slide=0
		[ -z "$next_slide" ] && next_slide=0
#		echo "duration=${duration[$i]}  previous_inc=$previous_increment previous_slide=$previous_slide previous_duration=$previous_duration"
		if [ "$previous_slide" == 'crossfade' ] || [ "$previous_slide" == 'wipe' ] ; then
			# subtract 1/2 time from rendered time:
			rendered_time=$(( ${duration[$i]} - $previous_duration / 2 )) 
			old_rendered_time=$(( ${duration[$i]} + $previous_duration ))
		elif [ "$previous_slide" == 'fadein' ] ; then
			rendered_time=$(( ${duration[$i]} - $previous_duration )) 
			old_rendered_time=$(( ${duration[$i]} + $previous_duration ))
		else  # no previous fade
			rendered_time=${duration[$i]}
			old_rendered_time=$rendered_time
		fi
#		echo "duration=${duration[$i]}  next_increment=$next_increment next_slide=$next_slide next_duration=$next_duration"
		if [ "$next_slide" == 'crossfade' ] || [ "$next_slide" == 'wipe' ] ; then
			# subtract time from rendered time:
			rendered_time=$(( $rendered_time - $next_duration / 2 )) 
			old_rendered_time=$(( $rendered_time + $next_duration )) 
		elif [ "$next_slide" == 'fadeout' ] ; then
			rendered_time=$(( $rendered_time - $next_duration )) 
			old_rendered_time=$(( $rendered_time + $next_duration )) 
		else  # no next fade
			rendered_time=$rendered_time	
			old_rendered_time=$old_rendered_time
		fi

		set_end_frame_time "$rendered_time"
		rendered_frames="$frames_to_render"

		[ $debug -ge 3 ] && echo "[dvd-slideshow] previous_increment=$previous_increment next_increment=$next_increment"
		[ $debug -ge 3 ] && echo "[dvd-slideshow] previous_duration=$previous_duration next_duration=$next_duration"
		[ $debug -ge 3 ] && echo "[dvd-slideshow] rendered_frames=$rendered_frames frames=$frames"
		[ $debug -ge 1 ] && echo "[dvd-slideshow] Rendering $rendered_frames frames at this time."
		if [ "$rendered_frames" -lt 0 ] ; then
			echo "[dvd-slideshow] WARNING: Frames rendered are less than 0!"
			echo "[dvd-slideshow] 	Either you specified a duration = 0 "
			echo "[dvd-slideshow] 	or the fade time(s) are longer than the slide time."
			echo "[dvd-slideshow] 	!! This timing changed in dvd-slideshow 0.8.0."
			echo "[dvd-slideshow] 	!! so now the fades get applied on top of the slides"
			echo "[dvd-slideshow] 	!! and thus fades do not add time to the slideshow."
			echo "[dvd-slideshow] 	MODIFYING SLIDE FRAMES RENDERED to $old_rendered_frames"
			rendered_frames="$old_rendered_frames"
		fi

		
		if [ ! -f "$tmpdir/slide_$i.ppm" ] ; then 
			create_slide "$file" "$tmpdir/slide_$i.ppm"
		fi
		subtitle1[$i]="$( echo "${subtitle[$i]}" | awk -F';' '{print $1}' )"
		if [ -n "${subtitle1[$i]}" -a "$subtitle_type" == 'render' ] ; then
			subtitle "${subtitle1[$i]}" $i transparent # just creates the .png file for overlay
			composite -compose src-over -type TrueColor -depth 8 "$tmpdir"/subtitle_"$i".png "$tmpdir"/slide_"$i".ppm "$tmpdir"/slide_"$i".ppm
		fi
		if [ "$frames_to_render" -ge 1 ] ; then
			encode "$tmpdir/slide_$i.ppm" $frames_to_render
		fi
		image_number=$(( $image_number + 1 ))
		[ "$manual_chapter_markers" -eq 0 ] && write_chap=1
		[ $debug -ge 1 ] &&  myecho "[dvd-slideshow] end_frame_number=$slide_end_frame end_time=$slide_end_hms"
#		if [ "${image[$i+$next_increment]}" == 'fadeout' ] ; then
#                	echo -n ""
#		else
                	myecho "[dvd-slideshow]############################################################"
#		fi
	elif [ "$file" == 'fadein' ] ; then  # FADEIN
		## ok, let's copy the background and just fade the foreground:
		## check to make sure the next slide is an image:
		next_effect_increment="`nexteffectincrement`"
		myecho "[dvd-slideshow] Applying Fadein to next image `hms ${duration[$i]}`"
		# we should check this while parsing the .txt file!
		if [ "$next_effect_increment" -ne 0 ] ; then
			myecho "[dvd-slideshow] ERROR: Cannot fadein to another fade!"
			cleanup; exit 1
		fi
		[ -n "${subtitle[$i]}" ] && myecho "[dvd-slideshow] Fadein Subtitle= ${subtitle[$i]}"
		nextslide=`nextslidename`
		increment=`nextslideincrement`
		[ -z "$increment" ] && ( cleanup ; exit 0 )
		nextslide_effect="${effect1[$i+$increment]}"
		check_rm "$tmpdir/slide_$(($i+$increment)).ppm" # make sure it doesn't already exist!
		## we need to prepare the NEXT image now:
                if [ "$nextslide" == 'title' ] || [ "$nextslide" == 'Title' ] ; then
	                if [ -n "${subtitle[$i+$increment]}" ] ; then
	                	title="${subtitle[$i+$increment]}"
			elif [ -n "$nextslide_effect" ] ; then
	                	title="$nextslide_effect"
			else
				myecho "[dvd-slideshow] ERROR: no title text found in line:"
				myecho "[dvd-slideshow] ${thisline}"
				cleanup; exit 1
			fi
                        titleslide "$title"
                        waitforfile "$tmpdir/title.ppm"
                        mv "$tmpdir"/title.ppm "$tmpdir"/"slide_$(($i+$increment)).ppm"
                elif [ "$nextslide" == 'titlebar' ] || [ "$nextslide" == 'Titlebar' ] ; then
                        title1="${subtitle[$i+$increment]}"
                        title2="$nextslide_effect"
                        titlebarslide "$title1" "$title2"
                        waitforfile "$tmpdir/title.ppm"
                        mv "$tmpdir"/title.ppm "$tmpdir"/"slide_$(($i+$increment)).ppm"
                elif [ "$nextslide" == 'musictitle' ] ; then
			Title="Title: $nextslide_effect"
			Artist="Artist: `echo ${effect1_params[$i+$increment]} | awk -F';' '{print $1}'`"
			Album="Album: `echo ${effect1_params[$i+$increment]} | awk -F';' '{print $2}'`"
                        musictitleslide "$Title" "$Artist" "$Album"
                        waitforfile "$tmpdir/title.ppm"
                        mv "$tmpdir"/title.ppm "$tmpdir"/"slide_$(($i+$increment)).ppm"
		elif [ "$nextslide_effect" == 'crop' ] ; then  # if next picture is specifically cropped
			window=`echo "${effect1_params[$i+$increment]}" | awk -F';' '{print $1";"$2}'`
			parse_window "$window" "${image[$i+$increment]}"
			mycrop  # takes the parameters from <parse_window> and returns: 
			convert "${image[$i+$increment]}" -resize "$sq_to_dvd_pixels" -crop "$c_width"x"$c_height+$xc0+$yc0" +repage -resize "$frame_width"x"$frame_height" miff:- | composite -compose src-over -geometry "+$(( $xci + $frame_border ))+$(( $yci + $frame_border ))" -type TrueColor -depth 8 - "$normal_bg" "$tmpdir/slide_$(($i+$increment)).ppm"
		elif [ "$nextslide_effect" == 'kenburns' ] ; then  # if next picture has kenburns effect
			myecho "[dvd-slideshow] Pre-rendering kenburns effect for fadein..."
			[ -f "$tmpdir"/fade_0001.ppm ] && \rm "$tmpdir"/fade_????.ppm  # remove any old files
			window_start=`echo "${effect1_params[$i+$increment]}" | awk -F';' '{print $1";"$2}'`
			window_end=`echo "${effect1_params[$i+$increment]}" | awk -F';' '{print $3";"$4}'`
			## number of frames in kenburns effect:
			next_duration=`seconds2ms ${duration[$i+$increment]}`  # duration in thousandths of sec
#			frames=$( duration2frames ${duration[$i]} )  # already calculated
			next_frames=$( duration2frames $next_duration )  # frames for next slide
			kenburns "$window_start" "$window_end" "${image[$i+$increment]}" "$next_frames" 1 "$frames" "$normal_bg" "."
#			progressbar_frames="$next_frames" ; progressbar_fr="$(( $frames + 1 ))"
#			echo "progressbar_fr=$progressbar_fr progressbar_frames=$progressbar_frames"
		elif [ "$nextslide_effect" == 'scroll' ] ; then  # if next picture has scroll effect
			myecho "[dvd-slideshow] Pre-rendering scroll effect for fadein..."
			[ -f "$tmpdir"/fade_0001.ppm ] && \rm "$tmpdir"/fade_????.ppm  # remove any old files
			direction="${effect1_params[$i+$increment]}"
			next_duration=`seconds2ms ${duration[$i+$increment]}`  # duration in thousandths of sec
			next_frames=$( duration2frames $next_duration )  # frames for next slide
			scroll "$direction" "${image[$i+$increment]}" "$normal_bg" "$next_frames" 1 "$frames" "."
		elif [ "$nextslide" == 'background' ] && [ "${duration[$i+$increment]}" -ne 0 ] ; then
			bg="$nextslide_effect"
			if [ -n "$bg" ] ; then
				background "$bg"   # calls the background image subroutine
				cp "$normal_bg" "$tmpdir/slide_$(($i+$increment)).ppm"
			else
				myecho "[dvd-slideshow] ERROR: Cannot fadein to the same background!"
				cleanup; exit 1
			fi
		else # no manual cropping next picture and it's not a title or background
			# need to read next variables BEFORE making next slide!
			read_next_variables
			create_slide "${image[$i+$increment]}" "$tmpdir/slide_$(($i+$increment)).ppm"
			subtitle1[$i+$increment]="$( echo "${subtitle[$i+$increment]}" | awk -F';' '{print $1}' )"
#			echo "subtitle1=${subtitle1[$i+$increment]}"
			if [ -n "${subtitle1[$i+$increment]}" -a "$subtitle_type" == 'render' ] ; then
				subtitle "${subtitle1[$i+$increment]}" "$(( $i + $increment))" transparent # creates subtitle_$(($i+$increment)).png
				composite -compose src-over -type TrueColor -depth 8 "$tmpdir"/subtitle_"$(($i+$increment))".png "$tmpdir"/slide_"$(($i+$increment))".ppm "$tmpdir"/slide_"$(($i+$increment))".ppm
			fi
		fi

		if [ "$low_quality" -eq 1 ] ; then
			stepsize=3
		elif [ "$high_quality" -eq 1 ] ; then
			stepsize=1
		elif [ "$nextslide_effect" == 'kenburns' ] || [ "$nextslide_effect" == 'scroll' ] ; then
			stepsize=1
			myecho "[dvd-slidsehow] Fading..."
		else
			stepsize=1
		fi
		## convert ppm to mpc for better speed:
#		if [ "$nextslide_effect" != 'kenburns' ] && [ "$nextslide_effect" != 'scroll' ] ; then
#			convert "$tmpdir/slide_$(($i+$increment)).ppm" -type TrueColor -depth 8 "$tmpdir/slide_$(($i+$increment)).mpc"
#		fi
		set_end_frame_time ${duration[$i]}
		[ $debug -ge 1 ] &&  myecho "[dvd-slideshow] end_frame_number=$slide_end_frame end_time=$slide_end_hms"
#		[ "$progressbar_fr" -eq 0 ] && echo -n  "[dvd-slideshow]" # i.e., no kenburns
		lastbar=0 # required for progressbar reset
		echo -n  "[dvd-slideshow]" # i.e., no kenburns
#		echo "progressbar_fr=$progressbar_fr progressbar_frames=$progressbar_frames"
		for (( fr=1 ; fr<=frames ; fr=fr+stepsize )) ; do
			dj=`addzeros $fr`
#			progressbar $progressbar_fr $progressbar_frames 'f' 0
			progressbar $fr $frames
#			echo "progressbar_fr=$progressbar_fr progressbar_frames=$progressbar_frames"
			percent=$(( 100 * $fr / $frames ))
#			echo "fr=$fr frames=$frames percent=$percent"
			if [ "$nextslide_effect" == 'kenburns' ] || [ "$nextslide_effect" == 'scroll' ] ; then
				if [ "$smp" -eq 1 ] ; then
				(mv "$tmpdir"/fade_$dj.ppm "$tmpdir"/kb_$dj.ppm ; composite -compose src-over -gravity center -type TrueColor -depth 8 -dissolve $percent "$tmpdir/kb_$dj.ppm" "$normal_bg" "$tmpdir/fade_$dj.ppm" ; extracopies $fr $frames ) &
				else
				(mv "$tmpdir"/fade_$dj.ppm "$tmpdir"/kb_$dj.ppm ; composite -compose src-over -gravity center -type TrueColor -depth 8 -dissolve $percent "$tmpdir/kb_$dj.ppm" "$normal_bg" "$tmpdir/fade_$dj.ppm" ; extracopies $fr $frames )
				fi
			elif [ "$smp" -eq 1 ] ; then
				(composite -compose src-over -gravity center -type TrueColor -depth 8 -dissolve $percent "$tmpdir/slide_$(($i+$increment)).ppm" "$normal_bg" "$tmpdir/fade_$dj.ppm" ; extracopies $fr $frames ) &
			else
				(composite -compose src-over -gravity center -type TrueColor -depth 8 -dissolve $percent "$tmpdir/slide_$(($i+$increment)).ppm" "$normal_bg" "$tmpdir/fade_$dj.ppm" ; extracopies $fr $frames )
			fi
		done
		waitforfiles "$tmpdir/fade" ppm $dj
		encode_fade
		finish_progressbar "$fr" $frames
		if [ "$nextslide_effect" == 'kenburns' ] || [ "$nextslide_effect" == 'scroll' ] ; then
			rm "$tmpdir"/kb_????.ppm
		fi
		rm "$tmpdir"/fade_????.ppm
	elif [ "$file" == 'crossfade' ] ; then  # CROSSFADE
		## ok, for crossfades, we need to fade both the foreground and background.
		## check to make sure the next slide is an image:
		## now make this get the last real image and the next real image
		## get next image:
#		progressbar_fr=0 ; progrssbar_frames=0
		nextslide=`nextslidename`
		if [ -z "$nextslide" ] ; then
			cleanup ; exit 0 
		fi
		increment=`nextslideincrement` 
		nextslide_effect="${effect1[$i+$increment]}"
		previous_increment="`previousslideincrement`"
		if [ -z "$previous_increment" ] ; then 
			cleanup ; exit 0 
		fi
		previousslide_effect="${effect1[$i-$previous_increment]}"
		next_effect_increment=`nexteffectincrement`
		previous_frames=0; next_frames=0;
		# this should be done while parsing the .txt file!
		if [ "$next_effect_increment" -ne 0 ] ; then
			myecho "[dvd-slideshow] ERROR: Cannot crossfade to another fade!"
			cleanup; exit 1
		fi
		myecho "[dvd-slideshow] Applying Crossfade between images `hms ${duration[$i]}`"
		[ -n "${subtitle[$i]}" ] && myecho "[dvd-slideshow] Crossfade Subtitle= ${subtitle[$i]}"
#		check_rm "$tmpdir/slide_$(($i+$increment)).ppm"  # make sure it doesn't already exist!
#		check_rm "$tmpdir/slide_$(($i+1)).cache"  # make sure it doesn't already exist!
#		myecho "[dvd-slideshow] next slide=$nextslide. increment=$increment."

		## need to break this up for new version:
		## first, render any previous effects (fixed slides should already exist)
		## then, render any next effects and/or fixed slides, including cropped slides.
		if [ "$previousslide_effect" == 'kenburns' ] ; then
			myecho "[dvd-slideshow] Rendering previous kenburns effect for crossfade..."
			# render end of last kenburns effect first:
			window_start=`echo "${effect1_params[$i-$previous_increment]}" | awk -F';' '{print $1";"$2}'`
			window_end=`echo "${effect1_params[$i-$previous_increment]}" | awk -F';' '{print $3";"$4}'`
			previous_duration="${duration[$i-$previous_increment]}" # already in thousandths.
			previous_frames=`div1000 $(( $frames_per_ms * $previous_duration / 1000 ))` 
			## number of frames in kenburns effect:
			start_frame="$(( $previous_frames - $frames  + 1 ))"
			kenburns "$window_start" "$window_end" "${image[$i-$previous_increment]}" "$previous_frames" "$start_frame" "$previous_frames" "$normal_bg" "."
			for (( fr=1 ; fr<=frames ; fr=fr+1 )) ; do
				dj=`addzeros $fr`
				kb_dj=`addzeros $(( $start_frame + $fr - 1 ))`
				mv "$tmpdir/fade_$kb_dj.ppm" "$tmpdir/kb_prev_$dj.ppm"
			done
		elif [ "$previousslide_effect" == 'scroll' ] ; then
			myecho "[dvd-slideshow] Rendering previous scroll effect for crossfade..."
			direction="${effect1_params[$i-$previous_increment]}"
			previous_duration="${duration[$i-$previous_increment]}" # already in thousandths.
			previous_frames=`div1000 $(( $frames_per_ms * $previous_duration / 1000 ))` 
			start_frame="$(( $previous_frames - $frames  + 1 ))"
			scroll "$direction" "${image[$i-$previous_increment]}" "$normal_bg" "$previous_frames" "$start_frame"  "$previous_frames" "."
			for (( fr=1 ; fr<=frames ; fr=fr+1 )) ; do
				dj=`addzeros $fr`
				kb_dj=`addzeros $(( $start_frame + $fr - 1 ))`
				mv "$tmpdir/fade_$kb_dj.ppm" "$tmpdir/kb_prev_$dj.ppm"
			done
		elif [ "$previousslide_effect" == 'wipe' ] ; then
			myecho "[dvd-slideshow] Not possible to crossfade from a wipe!"
			exit 1
		fi  # all other frames are static and should alaready be rendered
		#### Now prepare next frames:
		lastbar=0 # required for progressbar reset
		if [ "$nextslide" == 'title' ] || [ "$nextslide" == 'Title' ] ; then
	                if [ -n "${subtitle[$i+$increment]}" ] ; then
	                	title="${subtitle[$i+$increment]}"
			elif [ -n "$nextslide_effect" ] ; then
	                	title="$nextslide_effect"
			else
				myecho "[dvd-slideshow] ERROR: no title text found in line:"
				myecho "[dvd-slideshow] ${thisline}"
				cleanup; exit 1
			fi
			titleslide "$title"
			waitforfile "$tmpdir/title.ppm"
			mv "$tmpdir"/title.ppm "$tmpdir"/"slide_$(($i+$increment)).ppm"
                elif [ "$nextslide" == 'titlebar' ] || [ "$nextslide" == 'Titlebar' ] ; then
                        title1="${subtitle[$i+$increment]}"
                        title2="$nextslide_effect"
                        titlebarslide "$title1" "$title2"
                        waitforfile "$tmpdir/title.ppm"
                        mv "$tmpdir"/title.ppm "$tmpdir"/"slide_$(($i+$increment)).ppm"
                elif [ "$nextslide" == 'musictitle' ] ; then
			Title="Title: $nextslide_effect"
			Artist="Artist: `echo ${effect1_params[$i+$increment]} | awk -F';' '{print $1}'`"
			Album="Album: `echo ${effect1_params[$i+$increment]} | awk -F';' '{print $2}'`"
                        musictitleslide "$Title" "$Artist" "$Album"
                        waitforfile "$tmpdir/title.ppm"
                        mv "$tmpdir"/title.ppm "$tmpdir"/"slide_$(($i+$increment)).ppm"
		elif [ "$nextslide_effect" == 'crop' ] ; then  # if next picture is specifically cropped
			window=`echo "${effect1_params[$i+$increment]}" | awk -F';' '{print $1";"$2}'`
			parse_window "$window" "${image[$i+$increment]}"
			mycrop  # takes the parameters from <parse_window> and returns: 
			convert "${image[$i+$increment]}" -resize "$sq_to_dvd_pixels" -crop "$c_width"x"$c_height+$xc0+$yc0" +repage -resize "$frame_width"x"$frame_height" -type TrueColor -depth 8 miff:- | \
			composite -compose src-over -geometry "+$(( $xci + $frame_border ))+$(( $yci + $frame_border ))" -type TrueColor -depth 8 - "$normal_bg" "$tmpdir/slide_$(($i+$increment)).ppm"
		elif [ "$nextslide_effect" == 'kenburns' ] ; then
			myecho "[dvd-slideshow] Rendering next kenburns effect for crossfade..."
			window_start=`echo "${effect1_params[$i+$increment]}" | awk -F';' '{print $1";"$2}'`
			window_end=`echo "${effect1_params[$i+$increment]}" | awk -F';' '{print $3";"$4}'`
			next_duration=`seconds2ms ${duration[$i+$increment]}`  # duration in thousandths of sec
			next_frames=$( duration2frames $next_duration )  # frames for next slide
			kenburns "$window_start" "$window_end" "${image[$i+$increment]}" "$next_frames" 1 "$frames" "$normal_bg" '.'
			for (( fr=1 ; fr<=frames ; fr=fr+1 )) ; do
				dj=`addzeros $fr`
				mv "$tmpdir/fade_$dj.ppm" "$tmpdir/kb_next_$dj.ppm"
			done
		elif [ "$nextslide_effect" == 'scroll' ] ; then  # if next picture has scroll effect
			myecho "[dvd-slideshow] Rendering next scroll effect for crossfade..."
			direction="${effect1_params[$i+$increment]}"
			next_duration=`seconds2ms ${duration[$i+$increment]}`  # duration in thousandths of sec
			next_frames=$( duration2frames $next_duration )  # frames for next slide
			scroll "$direction" "${image[$i+$increment]}" "$normal_bg" "$next_frames" 1 "$frames" "."
			for (( fr=1 ; fr<=frames ; fr=fr+1 )) ; do
				dj=`addzeros $fr`
				mv "$tmpdir/fade_$dj.ppm" "$tmpdir/kb_next_$dj.ppm"
			done
		elif [ "$nextslide_effect" == 'wipe' ] ; then  # if next picture has scroll effect
			myecho "[dvd-slideshow] Not possible to crossfade to a wipe!"
			exit 1
		elif [ "$nextslide" == 'background' ] && [ "${duration[$i+$increment]}" -ne 0 ] ; then
			bg="$nextslide_effect"
			background "$bg"   # calls the background image subroutine
			cp "$normal_bg" "$tmpdir/slide_$(($i+$increment)).ppm"
		else # no manual cropping next picture and it's not a title
			read_next_variables
			create_slide "$nextslide" "$tmpdir/slide_$(($i+$increment)).ppm"
			subtitle1[$i+$increment]="$( echo "${subtitle[$i+$increment]}" | awk -F';' '{print $1}' )"
#			echo "subtitle1=${subtitle1[$i+$increment]}"
			if [ -n "${subtitle1[$i+$increment]}" -a "$subtitle_type" == 'render' ] ; then
				subtitle "${subtitle1[$i+$increment]}" "$(( $i + $increment))" transparent # creates subtitle_$(($i+$increment)).png
				composite -compose src-over -type TrueColor -depth 8 "$tmpdir"/subtitle_"$(($i+$increment))".png "$tmpdir"/slide_"$(($i+$increment))".ppm "$tmpdir"/slide_"$(($i+$increment))".ppm
			fi
		fi	
		## now do actual crossfade
		if [ "$low_quality" -eq 1 ] ; then
			stepsize=3
		elif [ "$high_quality" -eq 1 ] ; then
			stepsize=1
		elif [ "$previousslide_effect" == 'kenburns' ] || [ "$nextslide_effect" == 'kenburns' ] || [ "$previousslide_effect" == 'scroll' ] || [ "$nextslide_effect" == 'scroll' ] ; then
			stepsize=1
			myecho "[dvd-slidsehow] Crossfading..."
		else
			stepsize=1
		fi
		## convert ppm to mpc for better speed?:
#		convert "$tmpdir/slide_$(($i+1)).ppm" -type TrueColor -depth 8 "$tmpdir/slide_$(($i+1)).mpc"
		lastslide="`previousslideppm`"
#		lastslide_mpc="$tmpdir/temp_slideshow_image.mpc"
#		convert "$lastslide" +repage "$lastslide_mpc"  # gives "bad raw ppm magic" errors...
		## convert ppm to mpc for better speed:
#		if [ "$nextslide_effect" != 'kenburns' ] && [ "$nextslide_effect" != 'scroll' ] ; then
#			convert "$tmpdir/slide_$(($i+$increment)).ppm" -type TrueColor -depth 8 "$tmpdir/slide_$(($i+$increment)).mpc"
#		fi
		both=0
		if [ "$previousslide_effect" == 'scroll' ] && [ "$nextslide_effect" == 'scroll' ] ; then
			both=1
		elif [ "$previousslide_effect" == 'kenburns' ] && [ "$nextslide_effect" == 'kenburns' ] ; then
			both=1
		elif [ "$previousslide_effect" == 'scroll' ] && [ "$nextslide_effect" == 'kenburns' ] ; then
			both=1
		elif [ "$previousslide_effect" == 'kenburns' ] && [ "$nextslide_effect" == 'scroll' ] ; then
			both=1
		fi
		set_end_frame_time ${duration[$i]}
		[ $debug -ge 1 ] &&  myecho "[dvd-slideshow] end_frame_number=$slide_end_frame end_time=$slide_end_hms"
		lastbar=0 # required for progressbar reset
		echo -n  "[dvd-slideshow]" # i.e., no kenburns
		for (( fr=1 ; fr<=frames ; fr=fr+stepsize )) ; do
			progressbar $fr $frames 
			dj=`addzeros $fr`
			percent=$(( 100 * $fr / $frames ))
			if [ "$both" -eq 1 ] ; then
				if [ "$smp" -eq 1 ] ; then
				(composite -compose src-over -gravity center -type TrueColor -depth 8 -dissolve $percent "$tmpdir/kb_next_$dj.ppm" "$tmpdir/kb_prev_$dj.ppm" "$tmpdir/fade_$dj.ppm" ; extracopies $fr $frames ; rm "$tmpdir/kb_prev_$dj.ppm" ; rm "$tmpdir/kb_next_$dj.ppm" ) &
				else
				(composite -compose src-over -gravity center -type TrueColor -depth 8 -dissolve $percent "$tmpdir/kb_next_$dj.ppm" "$tmpdir/kb_prev_$dj.ppm" "$tmpdir/fade_$dj.ppm" ; extracopies $fr $frames ; rm "$tmpdir/kb_prev_$dj.ppm" ; rm "$tmpdir/kb_next_$dj.ppm" ) 
				fi
			elif [ "$previousslide_effect" == 'kenburns' ] || [ "$previousslide_effect" == 'scroll' ] ; then
				if [ "$smp" -eq 1 ] ; then
				(composite -compose src-over -gravity center -type TrueColor -depth 8 -dissolve $percent "$tmpdir/slide_$(($i+$increment)).ppm" "$tmpdir/kb_prev_$dj.ppm" "$tmpdir/fade_$dj.ppm" ; extracopies $fr $frames ; rm "$tmpdir/kb_prev_$dj.ppm" ) &
				else
				(composite -compose src-over -gravity center -type TrueColor -depth 8 -dissolve $percent "$tmpdir/slide_$(($i+$increment)).ppm" "$tmpdir/kb_prev_$dj.ppm" "$tmpdir/fade_$dj.ppm" ; extracopies $fr $frames ; rm "$tmpdir/kb_prev_$dj.ppm" ) 
				fi
			elif [ "$nextslide_effect" == 'kenburns' ] || [ "$nextslide_effect" == 'scroll' ] ; then
				if [ "$smp" -eq 1 ] ; then
				(composite -compose src-over -gravity center -type TrueColor -depth 8 -dissolve $percent "$tmpdir/kb_next_$dj.ppm" "$lastslide" "$tmpdir/fade_$dj.ppm" ; extracopies $fr $frames ; rm "$tmpdir/kb_next_$dj.ppm" ) &
				else
				(composite -compose src-over -gravity center -type TrueColor -depth 8 -dissolve $percent "$tmpdir/kb_next_$dj.ppm" "$lastslide" "$tmpdir/fade_$dj.ppm" ; extracopies $fr $frames ; rm "$tmpdir/kb_next_$dj.ppm" ) 
				fi
			elif [ "$smp" -eq 1 ] ; then
				(composite -compose src-over -gravity center -type TrueColor -depth 8 -dissolve $percent "$tmpdir/slide_$(($i+$increment)).ppm" "$lastslide" "$tmpdir/fade_$dj.ppm" ; extracopies $fr $frames ) &
			else
				(composite -compose src-over -gravity center -type TrueColor -depth 8 -dissolve $percent "$tmpdir/slide_$(($i+$increment)).ppm" "$lastslide" "$tmpdir/fade_$dj.ppm" ; extracopies $fr $frames )
			fi
		done
		waitforfiles "$tmpdir/fade" ppm $dj
		encode_fade
		finish_progressbar $fr $frames
		find "$tmpdir" -name "fade*.ppm" -type f -print0 | xargs -0 rm -f  # remove old files
		find "$tmpdir" -name "kb_*" -type f -print0 | xargs -0 rm -f  # remove old files
	elif [ "$file" == 'fadeout' ] ; then  # FADEOUT
		## ok, let's copy the background and just fade the foreground:
		## number of frames to render is $frames
		myecho "[dvd-slideshow] Doing fadeOUT to background...."
		myecho "[dvd-slideshow] Applying Fadeout to previous image `hms ${duration[$i]}`"
		[ -n "${subtitle[$i]}" ] && myecho "[dvd-slideshow] Fadeout Subtitle= ${subtitle[$i]}"
		previous_increment="`previousslideincrement`"
		if [ -z "$previous_increment" ] ; then 
			cleanup ; exit 0 
		fi
		previousslide_effect="${effect1[$i-$previous_increment]}"
		previous_frames=0; 
		next_effect_increment=`nexteffectincrement`
		if [ "$next_effect_increment" != 0 ] && ([ "${image[$i+$next_effect_increment]}" == 'crossfade' ] || [ "${image[$i+$next_effect_increment]}" == 'fadeout' ]) ; then
			myecho "[dvd-slideshow] ERROR: Cannot fadeout to a crossfade or another fadeout!"
			cleanup; exit 1
		fi
		start_frame=1
		# check if we're fading out from a kenburns or scroll effect:
		if [ "$previous_increment" -ne 0 ] ; then
			previous_duration="${duration[$i-$previous_increment]}" # already in thousandths.
			previous_frames=`div1000 $(( $frames_per_ms * $previous_duration / 1000 ))` 
		fi
		if [ "$previousslide_effect" == 'kenburns' ] ; then
			myecho "[dvd-slideshow] Rendering previous kenburns effect for fadeout..."
			# render end of last kenburns effect first:
			window_start=`echo "${effect1_params[$i-$previous_increment]}" | awk -F';' '{print $1";"$2}'`
			window_end=`echo "${effect1_params[$i-$previous_increment]}" | awk -F';' '{print $3";"$4}'`
			previous_duration="${duration[$i-$previous_increment]}" # already in thousandths.
			previous_frames=`div1000 $(( $frames_per_ms * $previous_duration / 1000 ))` 
			## number of frames in kenburns effect:
			start_frame="$(( $previous_frames - $frames  + 1 ))"
			kenburns "$window_start" "$window_end" "${image[$i-$previous_increment]}" "$previous_frames" "$start_frame" "$previous_frames" "$normal_bg" "."
			for (( fr=1 ; fr<=frames ; fr=fr+1 )) ; do
				dj=`addzeros $fr`
				kb_dj=`addzeros $(( $start_frame + $fr - 1 ))`
				mv "$tmpdir/fade_$kb_dj.ppm" "$tmpdir/kb_prev_$dj.ppm"
			done
		elif [ "$previousslide_effect" == 'scroll' ] ; then
			myecho "[dvd-slideshow] Rendering previous scroll effect for fadeout..."
			direction="${effect1_params[$i-$previous_increment]}"
			previous_duration="${duration[$i-$previous_increment]}" # already in thousandths.
			previous_frames=`div1000 $(( $frames_per_ms * $previous_duration / 1000 ))` 
			start_frame="$(( $previous_frames - $frames  + 1 ))"
			scroll "$direction" "${image[$i-$previous_increment]}" "$normal_bg" "$previous_frames" "$start_frame"  "$previous_frames" "."
			for (( fr=1 ; fr<=frames ; fr=fr+1 )) ; do
				dj=`addzeros $fr`
				kb_dj=`addzeros $(( $start_frame + $fr - 1 ))`
				mv "$tmpdir/fade_$kb_dj.ppm" "$tmpdir/kb_prev_$dj.ppm"
			done
		else
			## get last slide first?
			lastslide="`previousslideppm`"
			if [ ! -f "$lastslide" ] ; then
				myecho "[dvd-slideshow] ERROR: $lastslide doesn't exist!"
				myecho "[dvd-slideshow]        you probably are fading without having"
				myecho "[dvd-slideshow]        specified a real image first."
				cleanup; exit 1
			fi
			convert "$lastslide" "$tmpdir/temp_slideshow_image.mpc"
		fi

		if [ "$low_quality" -eq 1 ] ; then
			stepsize=3
		elif [ "$high_quality" -eq 1 ] ; then
			stepsize=1
		elif [ "$previousslide_effect" == 'kenburns' ] || [ "$previousslide_effect" == 'scroll' ] ; then
			stepsize=1
			myecho "[dvd-slidsehow] Fading..."
		else
			stepsize=1
		fi
		set_end_frame_time ${duration[$i]}
		[ $debug -ge 1 ] &&  myecho "[dvd-slideshow] end_frame_number=$slide_end_frame end_time=$slide_end_hms"
		echo -n "[dvd-slideshow]"
		lastbar=0 # required for progressbar
		for (( fr=1 ; fr<=frames ; fr=fr+stepsize )) ; do
			kb_dj=`addzeros $(( $fr + $start_frame - 1 ))`
			dj=`addzeros $fr`
			progressbar $fr $frames 
			percent=$(( 100 - 100 * $fr / $frames ))
#			echo "fr=$fr kb_fr=$kb_dj frames=$frames percent=$percent"
			if [ "$previousslide_effect" == 'kenburns' ] || [ "$previousslide_effect" == 'scroll' ] ; then
				if [ "$smp" -eq 1 ] ; then
				(composite -compose src-over -gravity center -type TrueColor -depth 8 -dissolve $percent "$tmpdir/kb_prev_$dj.ppm" "$normal_bg" "$tmpdir/fade_$dj.ppm" ; extracopies $fr $frames ) &
				else
				(composite -compose src-over -gravity center -type TrueColor -depth 8 -dissolve $percent "$tmpdir/kb_prev_$dj.ppm" "$normal_bg" "$tmpdir/fade_$dj.ppm" ; extracopies $fr $frames ) 
				fi
			elif [ "$smp" -eq 1 ] ; then
				(composite -compose src-over -gravity center -type TrueColor -depth 8 -dissolve $percent "$tmpdir/temp_slideshow_image.mpc" "$normal_bg" "$tmpdir/fade_$dj.ppm" ; extracopies $fr $frames ) &
			else
				(composite -compose src-over -gravity center -type TrueColor -depth 8 -dissolve $percent "$tmpdir/temp_slideshow_image.mpc" "$normal_bg" "$tmpdir/fade_$dj.ppm" ; extracopies $fr $frames )
			fi
		done
		waitforfiles "$tmpdir/fade" ppm $dj
		encode_fade
		finish_progressbar $fr $frames '#'
		find "$tmpdir" -name "fade*.ppm" -type f -print0 | xargs -0 rm -f  # remove old files
		find "$tmpdir" -name "kb_*" -type f -print0 | xargs -0 rm -f  # remove old files
	elif [ "$file" == 'wipe' ] ; then  # WIPE
		# wipe:duration:subtitle:[right|left|up|down]
		## This will wipe from left to right or right to left
		## check to make sure the next slide is an image:
		## now make this get the last real image and the next real image
		## get next image:
#		progressbar_fr=0 ; progrssbar_frames=0
		nextslide=`nextslidename`
		if [ -z "$nextslide" ] ; then
			cleanup ; exit 0 
		fi
		increment=`nextslideincrement` 
		nextslide_effect="${effect1[$i+$increment]}"
		previous_increment="`previousslideincrement`"
		if [ -z "$previous_increment" ] ; then 
			cleanup ; exit 0 
		fi
		previousslide_effect="${effect1[$i-$previous_increment]}"
		previousslide="${image[$i-$previous_increment]}"
		next_effect_increment=`nexteffectincrement`
		previous_frames=0; next_frames=0;
		# this should be done while parsing the .txt file!
		if [ "$next_effect_increment" -ne 0 ] ; then
			myecho "[dvd-slideshow] ERROR: Cannot wipe to another fade or wipe!"
			cleanup; exit 1
		fi
		myecho "[dvd-slideshow] Applying wipe between images `hms ${duration[$i]}`"
		[ -n "${subtitle[$i]}" ] && myecho "[dvd-slideshow] Wipe Subtitle= ${subtitle[$i]}"
#		myecho "[dvd-slideshow] next slide=$nextslide. increment=$increment."

		## need to break this up for new version:
		## first, render any previous effects (fixed slides should already exist)
		## then, render any next effects and/or fixed slides, including cropped slides.
		## Set temporary background to tranaparent?
		no_effects=0
		last_outfile="$tmpdir"/last_slideshow_image_scaled.mpc
		next_outfile="$tmpdir"/next_slideshow_image_scaled.mpc
		if [ "$previousslide" == 'title' ] || [ "$previousslide" == 'Title' ] ; then
			if [ -z "$title" ] ; then
				myecho "[dvd-slideshow] ERROR: no title text found in line"
				cleanup; exit 1
			fi
			titleslide "$title" "$last_outfile" "$transparent_bg"
			no_effects=1
                elif [ "$previousslide" == 'titlebar' ] || [ "$previousslide" == 'Titlebar' ] ; then
#                        title1="${subtitle[$i-$previous_increment]}"
#                        title2="$previousslide_effect"
                        titlebarslide "$title1" "$title2" "$last_outfile" "$transparent_bg"
			no_effects=1
                elif [ "$previousslide" == 'musictitle' ] ; then
			Title="Title: $previousslide_effect"
			Artist="Artist: `echo ${effect1_params[$i-$previous_increment]} | awk -F';' '{print $1}'`"
			Album="Album: `echo ${effect1_params[$i-$previous_increment]} | awk -F';' '{print $2}'`"
                        musictitleslide "$Title" "$Artist" "$Album" "$last_outfile" "$transparent_bg"
			no_effects=1
		elif [ "$previousslide_effect" == 'crop' ] ; then  # if previous picture is specifically cropped
			window=`echo "${effect1_params[$i-$previous_increment]}" | awk -F';' '{print $1";"$2}'`
			parse_window "$window" "${image[$i-$previous_increment]}"
			mycrop  # takes the parameters from <parse_window> and returns: 
			convert "${image[$i-$previous_increment]}" -resize "$sq_to_dvd_pixels" -crop "$c_width"x"$c_height+$xc0+$yc0" +repage -resize "$frame_width"x"$frame_height" -type TrueColor -depth 8 miff:- | \
			composite -compose src-over -geometry "+$(( $xci + $frame_border ))+$(( $yci + $frame_border ))" -type TrueColor -depth 8 - "$transparent_bg" "$last_outfile"
			no_effects=1
		elif [ "$previousslide_effect" == 'kenburns' ] ; then
			myecho "[dvd-slideshow] Rendering previous kenburns effect for wipe..."
			# render end of last kenburns effect first:
			window_start=`echo "${effect1_params[$i-$previous_increment]}" | awk -F';' '{print $1";"$2}'`
			window_end=`echo "${effect1_params[$i-$previous_increment]}" | awk -F';' '{print $3";"$4}'`
			previous_duration="${duration[$i-$previous_increment]}" 
			previous_frames=$( duration2frames $previous_duration )
			## number of frames in kenburns effect:
			start_frame="$(( $previous_frames - $frames  + 1 ))"
			kenburns "$window_start" "$window_end" "${image[$i-$previous_increment]}" "$previous_frames" "$start_frame" "$previous_frames" "$transparent_bg" "."
			for (( fr=1 ; fr<=frames ; fr=fr+1 )) ; do
				dj=`addzeros $fr`
				kb_dj=`addzeros $(( $start_frame + $fr - 1 ))`
				mv "$tmpdir/fade_$kb_dj.png" "$tmpdir/kb_prev_$dj.png"
			done
		elif [ "$previousslide_effect" == 'scroll' ] ; then
			myecho "[dvd-slideshow] Rendering previous scroll effect for wipe..."
			direction="${effect1_params[$i-$previous_increment]}"
			previous_duration="${duration[$i-$previous_increment]}" # already in thousandths.
			previous_frames=`div1000 $(( $frames_per_ms * $previous_duration / 1000 ))` 
			start_frame="$(( $previous_frames - $frames  + 1 ))"
			scroll "$direction" "${image[$i-$previous_increment]}" "$transparent_bg" "$previous_frames" "$start_frame"  "$previous_frames" "."
			for (( fr=1 ; fr<=frames ; fr=fr+1 )) ; do
				dj=`addzeros $fr`
				kb_dj=`addzeros $(( $start_frame + $fr - 1 ))`
				mv "$tmpdir/fade_$kb_dj.png" "$tmpdir/kb_prev_$dj.png"
			done
		else # no manual cropping next picture and it's not a title
			no_effects=1
			file1="$tmpdir/slide_$(($i-$previous_increment)).png"
			create_slide "${image[$i-$previous_increment]}" "$last_outfile" "$transparent_bg"
		fi  # all other frames are static and should alaready be rendered
		#### Now prepare next frames:
#		lastbar=0 # required for progressbar reset
		if [ "$nextslide" == 'title' ] || [ "$nextslide" == 'Title' ] ; then
	                if [ -n "${subtitle[$i+$increment]}" ] ; then
	                	title="${subtitle[$i+$increment]}"
			elif [ -n "$nextslide_effect" ] ; then
	                	title="$nextslide_effect"
			else
				myecho "[dvd-slideshow] ERROR: no title text found in line:"
				myecho "[dvd-slideshow] ${thisline}"
				cleanup; exit 1
			fi
			titleslide "$title" "$next_outfile" "$transparent_bg"
			if [ "$no_effects" -eq 1 ] ; then
				no_effects=2
				convert "$last_outfile" "$next_outfile" +append -type TrueColor -depth 8 "$tmpdir"/temp_slideshow_image_scaled.mpc		
			fi
                elif [ "$nextslide" == 'titlebar' ] || [ "$nextslide" == 'Titlebar' ] ; then
                        title1="${subtitle[$i+$increment]}"
                        title2="$nextslide_effect"
                        titlebarslide "$title1" "$title2" "$next_outfile" "$transparent_bg"
			if [ "$no_effects" -eq 1 ] ; then
				no_effects=2
				convert "$last_outfile" "$next_outfile" +append -type TrueColor -depth 8 "$tmpdir"/temp_slideshow_image_scaled.mpc		
			fi
                elif [ "$nextslide" == 'musictitle' ] ; then
			Title="Title: $nextslide_effect"
			Artist="Artist: `echo ${effect1_params[$i+$increment]} | awk -F';' '{print $1}'`"
			Album="Album: `echo ${effect1_params[$i+$increment]} | awk -F';' '{print $2}'`"
                        musictitleslide "$Title" "$Artist" "$Album" "$next_outfile" "$transparent_bg"
			if [ "$no_effects" -eq 1 ] ; then
				no_effects=2
				convert "$last_outfile" "$next_outfile" +append -type TrueColor -depth 8 "$tmpdir"/temp_slideshow_image_scaled.mpc		
			fi
		elif [ "$nextslide_effect" == 'crop' ] ; then  # if next picture is specifically cropped
			window=`echo "${effect1_params[$i+$increment]}" | awk -F';' '{print $1";"$2}'`
			parse_window "$window" "${image[$i+$increment]}"
			mycrop  # takes the parameters from <parse_window> and returns: 
			convert "${image[$i+$increment]}" -resize "$sq_to_dvd_pixels" -crop "$c_width"x"$c_height+$xc0+$yc0" +repage -resize "$frame_width"x"$frame_height" -type TrueColor -depth 8 miff:- | \
			composite -compose src-over -geometry "+$(( $xci + $frame_border ))+$(( $yci + $frame_border ))" -type TrueColor -depth 8 - "$transparent_bg" "$next_outfile"
		elif [ "$nextslide_effect" == 'kenburns' ] ; then
			myecho "[dvd-slideshow] Rendering next kenburns effect for wipe..."
			window_start=`echo "${effect1_params[$i+$increment]}" | awk -F';' '{print $1";"$2}'`
			window_end=`echo "${effect1_params[$i+$increment]}" | awk -F';' '{print $3";"$4}'`
			next_duration=`seconds2ms ${duration[$i+$increment]}`  # duration in thousandths of sec
			next_frames=$( duration2frames $next_duration )
			kenburns "$window_start" "$window_end" "${image[$i+$increment]}" "$next_frames" 1 "$frames" "$transparent_bg" '.'
			for (( fr=1 ; fr<=frames ; fr=fr+1 )) ; do
				dj=`addzeros $fr`
				mv "$tmpdir/fade_$dj.png" "$tmpdir/kb_next_$dj.png"
			done
		elif [ "$nextslide_effect" == 'scroll' ] ; then  # if next picture has scroll effect
			myecho "[dvd-slideshow] Rendering next scroll effect for wipe..."
			direction="${effect1_params[$i+$increment]}"
			next_duration=`seconds2ms ${duration[$i+$increment]}`  # duration in thousandths of sec
			next_frames=$( duration2frames $next_duration )  # frames for next slide
			scroll "$direction" "${image[$i+$increment]}" "$transparent_bg" "$next_frames" 1 "$frames" "."
#			for fr in `seq 1 $stepsize $frames`; do
			for (( fr=1 ; fr<=frames ; fr=fr+1 )) ; do
				dj=`addzeros $fr`
				mv "$tmpdir/fade_$dj.png" "$tmpdir/kb_next_$dj.png"
			done
		elif [ "$nextslide" == 'background' ] && [ "${duration[$i+$increment]}" -ne 0 ] ; then
			bg="$nextslide_effect"
			background "$bg"   # calls the background image subroutine
			cp "$normal_bg" "$tmpdir/slide_$(($i+$increment)).ppm"
		else # no manual cropping next picture and it's not a title
			create_slide "${image[$i+$increment]}" "$next_outfile" "$transparent_bg"
			if [ "$no_effects" -eq 1 ] ; then
				no_effects=2
				convert "$last_outfile" "$next_outfile" +append -type TrueColor -depth 8 "$tmpdir"/temp_slideshow_image_scaled.mpc		
			fi
		fi	
		lastslide="`previousslideppm`"
		both=0
		if [ "$previousslide_effect" == 'scroll' ] && [ "$nextslide_effect" == 'scroll' ] ; then
			both=1
		elif [ "$previousslide_effect" == 'kenburns' ] && [ "$nextslide_effect" == 'kenburns' ] ; then
			both=1
		elif [ "$previousslide_effect" == 'scroll' ] && [ "$nextslide_effect" == 'kenburns' ] ; then
			both=1
		elif [ "$previousslide_effect" == 'kenburns' ] && [ "$nextslide_effect" == 'scroll' ] ; then
			both=1
		fi
		set_end_frame_time ${duration[$i]}
## now, all previous and next frames are created if they need to.  Prepare for loop/composite:
		direction="$( echo "${effect1[$i]}" | tr -d \[:blank:\] )"
		[ -z "$direction" ] && direction='left'
		if [ "$direction" == 'right' ] ; then
			myecho "[dvd-slideshow] Doing wipe right effect"
			xs1=0 ; ys1=0 # Image 1
			xe1=$(( $dvd_width - 0 )) ; ye1=0
			xs2=$(( -1 * $dvd_width + 0 )) ; ys2=0
			xe2=0 ; ye2=0 # Image 2
		elif [ "$direction" == 'left' ] ; then
			myecho "[dvd-slideshow] Doing wipe left effect"
			xs1=0 ; ys1=0 # Image 1
			xe1=$(( -1 * $dvd_width + 0 )) ; ye1=0
			xs2=$(( $dvd_width - 0 )) ; ys2=0  # image 2
			xe2=0 ; ye2=0
		elif [ "$direction" == 'up' ] ; then
			myecho "[dvd-slideshow] Doing wipe up effect"
			xs1=0 ; ys1=0 # Image 1
			ye1=$(( -1 * $dvd_height + 0 )) ; xe1=0
			ys2=$(( $dvd_height - 0 )) ; xs2=0  # image 2
			xe2=0 ; ye2=0
		elif [ "$direction" == 'down' ] ; then
			myecho "[dvd-slideshow] Doing wipe down effect"
			xs1=0 ; ys1=0 # Image 1
			ye1=$(( $dvd_height - 0 )) ; xe1=0
			ys2=$(( -1 * $dvd_height + 0 )) ; xs2=0
			xe2=0 ; ye2=0 # Image 2
		else
			myecho "[dvd-slideshow] ERROR: bad effect parameters $direction."
			cleanup; exit 1
		fi
		[ "$debug" -ge 2 ] && myecho "[dvd-slideshow] params=$xs1,$ys1 ; $xs2,$ys2 ; $xe1,$ye1 ; $xe2,$ye2"
		if [ "$low_quality" -eq 1 ] ; then
			stepsize=3; interp=0
		elif [ "$previousslide_effect" == 'kenburns' ] || [ "$nextslide_effect" == 'kenburns' ] || [ "$previousslide_effect" == 'scroll' ] || [ "$nextslide_effect" == 'scroll' ] ; then
			stepsize=1; interp=0
			myecho "[dvd-slidsehow] Wiping..."
		elif [ "$high_quality" -eq 1 ] ; then
			stepsize=1; interp=1
		else
#			[ "$frames" -lt 45 ] && stepsize=1 || stepsize=2 
			stepsize=1; interp=0
		fi
		[ $debug -ge 1 ] &&  myecho "[dvd-slideshow] end_frame_number=$slide_end_frame end_time=$slide_end_hms"
		## smooth start and end parameters:
		F1=$(( $frames * 45 / 100 ))  # 20 percent smoothing
		F2=$(( $frames - $F1 ))	
		V1x=$( echo "scale=9; 2 * ( $xe1 - $xs1 ) / ( $frames + $F2 - $F1 )" | bc ) 
		V1y=$( echo "scale=9; 2 * ( $ye1 - $ys1 ) / ( $frames + $F2 - $F1 )" | bc )
		V2x=$( echo "scale=9; 2 * ( $xe2 - $xs2 ) / ( $frames + $F2 - $F1 )" | bc )
		V2y=$( echo "scale=9; 2 * ( $ye2 - $ys2 ) / ( $frames + $F2 - $F1 )" | bc )
		pi='3.14159265'
		echo -n "[dvd-slideshow]"
		lastbar=0 # required for progressbar
		for (( fr=1 ; fr<=frames ; fr=fr+stepsize )) ; do
			dj=`addzeros $fr`
			if [ $fr -le $F1 ] ; then   # inputs are relatively simple:  make function?
				# region 1
				x1=$( echo "scale=3; $xs1 + $V1x/2 *($fr - $F1/$pi *s($pi*$fr/$F1))" | bc -l )
				y1=$( echo "scale=3; $ys1 + $V1y/2 *($fr - $F1/$pi *s($pi*$fr/$F1))" | bc -l )
				[ $debug -ge 2 ] && myecho "[dvd-slideshow:wipe] $fr x1=$x1 y1=$y1 region 1"
				D1x1=$x1; D1y1=$y1
				x1_dec=`printf %3.3f "$x1" | awk -F. '{print "0."$2}'`; 
				y1_dec=`printf %3.3f "$y1" | awk -F. '{print "0."$2}'`;
				## Fix numbers without leading zeros:
				it=`printf %3f "$x1" | awk -F. '{print $1}'` ; [ -z "$it" ] && x1_whole=0 || x1_whole="$it"
				it=`printf %3f "$y1" | awk -F. '{print $1}'` ; [ -z "$it" ] && y1_whole=0 || y1_whole="$it"
				x1=$x1_whole ; y1=$y1_whole
				x2=$( echo "scale=3; $xs2 + $V2x/2 *($fr - $F1/$pi *s($pi*$fr/$F1))" | bc -l )
				y2=$( echo "scale=3; $ys2 + $V2y/2 *($fr - $F1/$pi *s($pi*$fr/$F1))" | bc -l )
				[ $debug -ge 2 ] && myecho "[dvd-slideshow:wipe] $fr x2=$x2 y2=$y2 region 1"
				D1x2=$x2; D1y2=$y2
				x2_dec=`printf %3.3f $x2 | awk -F. '{print "0."$2}'`; 
				y2_dec=`printf %3.3f $y2 | awk -F. '{print "0."$2}'`;
				## Fix numbers without leading zeros:
				it=`printf %3f "$x2" | awk -F. '{print $1}'` ; [ -z "$it" ] && x2_whole=0 || x2_whole="$it"
				it=`printf %3f "$y2" | awk -F. '{print $1}'` ; [ -z "$it" ] && y2_whole=0 || y2_whole="$it"
				x2=$x2_whole ; y2=$y2_whole
			elif [ $fr -ge $(( $F2 + 1 )) ] ; then
				# region 3
				x1=$( echo "scale=3; $D2x1 + $V1x/2 *( ($fr-$F2) + ($frames-$F2)/$pi*s(($fr-$F2)*$pi/($frames-$F2)) )" | bc -l )
				y1=$( echo "scale=3; $D2y1 + $V1y/2 *( ($fr-$F2) + ($frames-$F2)/$pi*s(($fr-$F2)*$pi/($frames-$F2)) )" | bc -l )
				[ $debug -ge 2 ] && myecho "[dvd-slideshow:wipe] $fr x1=$x1 y1=$y1 region 3"
				x1_dec=`printf %3.3f $x1 | awk -F. '{print "0."$2}'`; 
				y1_dec=`printf %3.3f $y1 | awk -F. '{print "0."$2}'`;
				## Fix numbers without leading zeros:
				it=`printf %3f "$x1" | awk -F. '{print $1}'` ; [ -z "$it" ] && x1_whole=0 || x1_whole="$it"
				it=`printf %3f "$y1" | awk -F. '{print $1}'` ; [ -z "$it" ] && y1_whole=0 || y1_whole="$it"
				x1=$x1_whole ; y1=$y1_whole
				x2=$( echo "scale=3; $D2x2 + $V2x/2 *( ($fr-$F2) + ($frames-$F2)/$pi*s(($fr-$F2)*$pi/($frames-$F2)) )" | bc -l )
				y2=$( echo "scale=3; $D2y2 + $V2y/2 *( ($fr-$F2) + ($frames-$F2)/$pi*s(($fr-$F2)*$pi/($frames-$F2)) )" | bc -l )
				[ $debug -ge 2 ] && myecho "[dvd-slideshow:wipe] $fr x2=$x2 y2=$y2 region 3"
				x2_dec=`printf %3.3f $x2 | awk -F. '{print "0."$2}'`; 
				y2_dec=`printf %3.3f $y2 | awk -F. '{print "0."$2}'`;
				## Fix numbers without leading zeros:
				it=`printf %3f "$x2" | awk -F. '{print $1}'` ; [ -z "$it" ] && x2_whole=0 || x2_whole="$it"
				it=`printf %3f "$y2" | awk -F. '{print $1}'` ; [ -z "$it" ] && y2_whole=0 || y2_whole="$it"
				x2=$x2_whole ; y2=$y2_whole
			else
				# middle region 2
				x1=$( echo "scale=3; $D1x1 + $V1x*($fr-$F1)" | bc )
				y1=$( echo "scale=3; $D1y1 + $V1y*($fr-$F1)" | bc )
				D2x1=$x1 ; D2y1=$y1
				[ $debug -ge 2 ] && myecho "[dvd-slideshow:wipe] $fr x1=$x1 y1=$y1 region 2"
				x1_dec=`printf %3.3f $x1 | awk -F. '{print "0."$2}'`; 
				y1_dec=`printf %3.3f $y1 | awk -F. '{print "0."$2}'`;
				## Fix numbers without leading zeros:
				it=`printf %3f "$x1" | awk -F. '{print $1}'` ; [ -z "$it" ] && x1_whole=0 || x1_whole="$it"
				it=`printf %3f "$y1" | awk -F. '{print $1}'` ; [ -z "$it" ] && y1_whole=0 || y1_whole="$it"
				x1=$x1_whole ; y1=$y1_whole
				x2=$( echo "scale=3; $D1x2 + $V2x*($fr-$F1)" | bc )
				y2=$( echo "scale=3; $D1y2 + $V2y*($fr-$F1)" | bc )
				D2x2=$x2 ; D2y2=$y2
				[ $debug -ge 2 ] && myecho "[dvd-slideshow:wipe] $fr x2=$x2 y2=$y2 region 2"
				x2_dec=`printf %3.3f $x2 | awk -F. '{print "0."$2}'`; 
				y2_dec=`printf %3.3f $y2 | awk -F. '{print "0."$2}'`;
				## Fix numbers without leading zeros:
				it=`printf %3f "$x2" | awk -F. '{print $1}'` ; [ -z "$it" ] && x2_whole=0 || x2_whole="$it"
				it=`printf %3f "$y2" | awk -F. '{print $1}'` ; [ -z "$it" ] && y2_whole=0 || y2_whole="$it"
				x2=$x2_whole ; y2=$y2_whole
			fi

## old method:
#			x1=`div1000 $(( 1000 * $xs1 + $(($xe1-$xs1)) * 1000 * $fr / $frames ))`
#			y1=`div1000 $(( 1000 * $ys1 + $(($ye1-$ys1)) * 1000 * $fr / $frames ))`
			[ "$x1" -eq 0 ] && x1="+0"
			[ "$y1" -eq 0 ] && y1="+0"
			[ "$x1" -gt 0 ] && x1="+$x1"
			[ "$y1" -gt 0 ] && y1="+$y1"
#			x2=`div1000 $(( 1000 * $xs2 + $(($xe2-$xs2)) * 1000 * $fr / $frames ))`
#			y2=`div1000 $(( 1000 * $ys2 + $(($ye2-$ys2)) * 1000 * $fr / $frames ))`
			[ "$x2" -eq 0 ] && x2="+0"
			[ "$y2" -eq 0 ] && y2="+0"
			[ "$x2" -gt 0 ] && x2="+$x2"
			[ "$y2" -gt 0 ] && y2="+$y2"

			progressbar $fr $frames '#'
			## optionally prepare interp image:
			if [ "$both" -eq 1 ] ; then
				if [ "$smp" -eq 1 ] ; then
				(composite -compose src-over -geometry "$x1""$y1" -type TrueColor -depth 8 "$tmpdir/kb_prev_$dj.png" "$normal_bg" - | composite -compose src-over -geometry "$x2""$y2" -type TrueColor -depth 8 "$tmpdir/kb_next_$dj.png" - "$tmpdir"/fade_$dj.ppm ; extracopies $fr $frames ) &
				else
				composite -compose src-over -geometry "$x1""$y1" -type TrueColor -depth 8 "$tmpdir/kb_prev_$dj.png" "$normal_bg" - | composite -compose src-over -geometry "$x2""$y2" -type TrueColor -depth 8 "$tmpdir/kb_next_$dj.png" - "$tmpdir"/fade_$dj.ppm ; extracopies $fr $frames
				fi
			elif [ "$previousslide_effect" == 'kenburns' ] || [ "$previousslide_effect" == 'scroll' ] ; then
				if [ "$smp" -eq 1 ] ; then
				(composite -compose src-over -geometry "$x1""$y1" -type TrueColor -depth 8 "$tmpdir/kb_prev_$dj.png" "$normal_bg" - | composite -compose src-over -geometry "$x2""$y2" -type TrueColor -depth 8 "$next_outfile" - "$tmpdir"/fade_$dj.ppm ; extracopies $fr $frames ) &
				else
				composite -compose src-over -geometry "$x1""$y1" -type TrueColor -depth 8 "$tmpdir/kb_prev_$dj.png" "$normal_bg" - | composite -compose src-over -geometry "$x2""$y2" -type TrueColor -depth 8 "$next_outfile" - "$tmpdir"/fade_$dj.ppm ; extracopies $fr $frames 
				fi
			elif [ "$nextslide_effect" == 'kenburns' ] || [ "$nextslide_effect" == 'scroll' ] ; then
				if [ "$smp" -eq 1 ] ; then
				(composite -compose src-over -geometry "$x1""$y1" -type TrueColor -depth 8 "$last_outfile" "$normal_bg" - | composite -compose src-over -geometry "$x2""$y2" -type TrueColor -depth 8 "$tmpdir/kb_next_$dj.png" - "$tmpdir"/fade_$dj.ppm ; extracopies $fr $frames ) &
				else
				composite -compose src-over -geometry "$x1""$y1" -type TrueColor -depth 8 "$last_outfile" "$normal_bg" - | composite -compose src-over -geometry "$x2""$y2" -type TrueColor -depth 8 "$tmpdir/kb_next_$dj.png" - "$tmpdir"/fade_$dj.ppm ; extracopies $fr $frames
				fi
			else  # flat files.  Optionally do interp
				if [ "$smp" -eq 1 ] ; then
					(composite -compose src-over -geometry "$x1""$y1" -type TrueColor -depth 8 "$last_outfile" "$normal_bg" - | composite -compose src-over -geometry "$x2""$y2" -type TrueColor -depth 8 "$next_outfile" - "$tmpdir"/fade_$dj.ppm ; extracopies $fr $frames ) &
				else
					(composite -compose src-over -geometry "$x1""$y1" -type TrueColor -depth 8 "$last_outfile" "$normal_bg" - | composite -compose src-over -geometry "$x2""$y2" -type TrueColor -depth 8 "$next_outfile" - "$tmpdir"/fade_$dj.ppm ; extracopies $fr $frames )
				fi
			fi  # end of pre/post options
		done
		waitforfiles "$tmpdir/fade" ppm $dj
		encode_fade
		finish_progressbar $fr $frames
		find "$tmpdir" -name "fade*.ppm" -type f -print0 | xargs -0 rm -f  # remove old files
		find "$tmpdir" -name "fade*.png" -type f -print0 | xargs -0 rm -f # remove old files
		find "$tmpdir" -name "kb_*" -type f -print0 | xargs -0 rm -f # remove old files
	elif [ "${image_file[$i]}" -eq 1 ] && [ "${effect1[$i]}" == 'crop' ] ; then  ## CROP
		myecho "[dvd-slideshow] $image_number/$imagefiles `truncate_filename $file` `hms ${duration[$i]}`"
		myecho "[dvd-slideshow] Crop ${effect1_params[$i]}"
		[ -n "${subtitle[$i]}" ] && myecho "[dvd-slideshow] Subtitle""= ${subtitle[$i]}"

		# calculate actual frames rendered:
		previous_increment="`previouseffectincrement`"
		previous_duration="${duration[$i-$previous_increment]}" # already in thousandths.
		previous_slide="${image[$i-$previous_increment]}"
		next_increment="`nexteffectincrement`"
		next_duration=`seconds2ms "${duration[$i+$next_increment]}"` # already in thousandths.
		next_slide="${image[$i+$next_increment]}"
		[ -z "$previous_slide" ] && previous_slide=0
		[ -z "$next_slide" ] && next_slide=0
#		echo "duration=${duration[$i]}  previous_inc=$previous_increment previous_slide=$previous_slide previous_duration=$previous_duration"
		if [ "$previous_slide" == 'crossfade' ] || [ "$previous_slide" == 'wipe' ] ; then
			# subtract 1/2 time from rendered time:
			rendered_time=$(( ${duration[$i]} - $previous_duration / 2 )) 
			old_rendered_time=$(( ${duration[$i]} + $previous_duration ))
		elif [ "$previous_slide" == 'fadein' ] ; then
			rendered_time=$(( ${duration[$i]} - $previous_duration )) 
			old_rendered_time=$(( ${duration[$i]} + $previous_duration ))
		else  # no previous fade
			rendered_time=${duration[$i]}
			old_rendered_time=$rendered_time
		fi
#		echo "duration=${duration[$i]}  next_increment=$next_increment next_slide=$next_slide next_duration=$next_duration"
		if [ "$next_slide" == 'crossfade' ] || [ "$next_slide" == 'wipe' ] ; then
			# subtract time from rendered time:
			rendered_time=$(( $rendered_time - $next_duration / 2 )) 
			old_rendered_time=$(( $rendered_time + $next_duration )) 
		elif [ "$next_slide" == 'fadeout' ] ; then
			rendered_time=$(( $rendered_time - $next_duration )) 
			old_rendered_time=$(( $rendered_time + $next_duration )) 
		else  # no next fade
			rendered_time=$rendered_time	
			old_rendered_time=$old_rendered_time
		fi

		set_end_frame_time $rendered_time
		rendered_frames="$frames_to_render"

		if [ "$rendered_frames" -le 0 ] ; then
			echo "[dvd-slideshow] WARNING: Frames rendered are less than 1!"
			echo "[dvd-slideshow] 	Either you specified a duration = 0 "
			echo "[dvd-slideshow] 	or the fade time(s) are longer than the slide time."
			echo "[dvd-slideshow] 	!! This timing changed in dvd-slideshow 0.8.0."
			echo "[dvd-slideshow] 	!! so now the fades get applied on top of the slides"
			echo "[dvd-slideshow] 	!! and thus fades do not add time to the slideshow."
			echo "[dvd-slideshow] 	MODIFYING SLIDE FRAMES RENDERED to $old_rendered_frames"
			rendered_frames="$old_rendered_frames"
		fi

		## now the slide may already exist if we had a fadein or crossfade before
		if [ ! -f "$tmpdir/slide_$i.ppm" ] ; then 
			window=`echo "${effect1_params[$i]}" | awk -F';' '{print $1";"$2}'`
			parse_window "$window" "$file"
			mycrop  # takes the parameters from <parse_window> and returns: 
			[ $debug -ge 2 ] && myecho "[dvd-slideshow] Crop $c_width"x"$c_height"+"$xc0"+"$yc0 composite" +"$xci"+$yci
			## now, do the actual crop:
			convert "${file}" -resize "$sq_to_dvd_pixels" -crop "$c_width"x"$c_height+$xc0+$yc0" +repage -resize "$frame_width"x"$frame_height" -type TrueColor -depth 8 miff:- | composite -compose src-over -geometry "+$(( $xci + $frame_border ))+$(( $yci + $frame_border ))" -type TrueColor -depth 8 - "$normal_bg" "$tmpdir/slide_$i.ppm"
			subtitle1[$i]="$( echo "${subtitle[$i]}" | awk -F';' '{print $1}' )"
#			echo "subtitle1=${subtitle1[$i]}"
			if [ -n "${subtitle1[$i]}" -a "$subtitle_type" == 'render' ] ; then
				subtitle "${subtitle1[$i]}" $i transparent # creates subtitle_$i.png
				composite -compose src-over -type TrueColor -depth 8 "$tmpdir"/subtitle_"$i".png "$tmpdir"/slide_"$i".ppm "$tmpdir"/slide_"$i".ppm
			fi
		fi
		encode "$tmpdir/slide_$i.ppm" $rendered_frames
		image_number=$(( $image_number + 1 ))
		[ "$manual_chapter_markers" -eq 0 ] && write_chap=1
		find "$tmpdir" -name "fade*.ppm" -type f -print0 | xargs -0 rm -f  # remove old files
		find "$tmpdir" -name "kb_*" -type f -print0 | xargs -0 rm -f  # remove old files
		[ $debug -ge 1 ] &&  myecho "[dvd-slideshow] end_frame_number=$slide_end_frame end_time=$slide_end_hms rendered_frames=$rendered_frames"
                myecho "[dvd-slideshow]############################################################"
	elif [ "${effect1[$i]}" == 'kenburns' ] ; then  # KENBURNS
		## Kenburns effect from starting point to ending point
		# x0,y0 is the top left corner of the image
		# x1,y1 is the bottom right corner of the image
		# xs0,ys1 is the starting point for the top left corner, etc
		# xe1,ye1 is the ending point for the bottom right corner
		# textfile format is:  
		# file:duration:comment:kenburns:xs0,ys0;xs1,ys1;xe0,ye0;xe1,ye1;startangle,endangle
		myecho "[dvd-slideshow] $image_number/$imagefiles `truncate_filename $file` `hms ${duration[$i]}`"
		myecho "[dvd-slideshow] Kenburns ${effect1_params[$i]}"
		[ -n "${subtitle[$i]}" ] && myecho "[dvd-slideshow] Subtitle""= ${subtitle[$i]}"

		window_start=`echo "${effect1_params[$i]}" | awk -F';' '{print $1";"$2}'`
		window_end=`echo "${effect1_params[$i]}" | awk -F';' '{print $3";"$4}'`
		previous_increment="`previouseffectincrement`"
		if [ "$previous_increment" -ne 0 ] ; then
			previous_duration="${duration[$i-$previous_increment]}" # already in thousandths.
			previous_frames=`div1000 $(( $frames_per_ms * $previous_duration / 1000 ))` 
		fi
		next_increment="`nexteffectincrement`"
		if [ "$next_increment" -ne 0 ] ; then
			next_duration=`seconds2ms ${duration[$i+$next_increment]}`  # duration in thousandths of sec
			next_frames=$( duration2frames $next_duration )  # frames for next slide
		fi

		set_end_frame_time ${duration[$i]}
		[ $debug -ge 1 ] &&  myecho "[dvd-slideshow] end_frame_number=$slide_end_frame end_time=$slide_end_hms"

		if [ "$previous_increment" -ne 0 ] && [ "$next_increment" -ne 0 ] ; then
			kenburns "$window_start" "$window_end" "$file" "$frames" "$(( $previous_frames + 1 ))" "$(( $frames - $next_frames ))" "$normal_bg"

			rendered_frames=`div1000 $(( $frames_per_ms * ( ${duration[$i]} - $previous_duration - $next_duration ) / 1000 ))` # both duration and fps are in ms
			old_rendered_frames=`div1000 $(( $frames_per_ms * ( ${duration[$i]} + $previous_duration + $next_duration ) / 1000 ))` # both duration and fps are in ms
		elif [ "$previous_increment" -ne 0 ] ; then
			kenburns "$window_start" "$window_end" "$file" "$frames" "$(( $previous_frames + 1 ))" "$frames" 
			rendered_frames=`div1000 $(( $frames_per_ms * ( ${duration[$i]} - $previous_duration ) / 1000 ))` # both duration and fps are in ms
			old_rendered_frames=`div1000 $(( $frames_per_ms * ( ${duration[$i]} + $previous_duration ) / 1000 ))` # both duration and fps are in ms
		elif [ "$next_increment" -ne 0 ] ; then
			kenburns "$window_start" "$window_end" "$file" "$frames" 1 "$(( $frames - $next_frames ))"
			rendered_frames=`div1000 $(( $frames_per_ms * ( ${duration[$i]} - $next_duration ) / 1000 ))` # both duration and fps are in ms
			old_rendered_frames=`div1000 $(( $frames_per_ms * ( ${duration[$i]} + $next_duration ) / 1000 ))` # both duration and fps are in ms
		else
			kenburns "$window_start" "$window_end" "$file" "$frames" 1 "$frames" "#"
			rendered_frames="$frames"
		fi
		if [ "$rendered_frames" -le 0 ] ; then
			echo "[dvd-slideshow] WARNING: Frames rendered are less than 1!"
			echo "[dvd-slideshow] 	Either you specified a duration = 0 "
			echo "[dvd-slideshow] 	or the fade time(s) are longer than the slide time."
			echo "[dvd-slideshow] 	!! This timing changed in dvd-slideshow 0.8.0."
			echo "[dvd-slideshow] 	!! so now the fades get applied on top of the slides"
			echo "[dvd-slideshow] 	!! and thus fades do not add time to the slideshow."
			echo "[dvd-slideshow] 	MODIFYING SLIDE FRAMES RENDERED to $old_rendered_frames"
			rendered_frames="$old_rendered_frames"
		fi
		encode_fade
		## just in case we want to fade out or crossfade, we need to save the last image:
		mv "$tmpdir/fade_$dj.ppm" "$tmpdir/slide_$i.ppm"
		find "$tmpdir" -name "fade*.ppm" -type f -print0 | xargs -0 rm -f  # remove old files
		find "$tmpdir" -name "fade*.png" -type f -print0 | xargs -0 rm -f # remove old files
		image_number=$(( $image_number + 1 ))
	elif [ "${effect1[$i]}" == 'scroll' ] ; then # SCROLL
		# textfile format is:  
		# file:duration:comment:scrollright
		myecho "[dvd-slideshow] $image_number/$imagefiles `truncate_filename $file` `hms ${duration[$i]}`"
		myecho "[dvd-slideshow] Scroll ${effect1_params[$i]}"
		[ -n "${subtitle[$i]}" ] && myecho "[dvd-slideshow] Subtitle""= ${subtitle[$i]}"
		direction="${effect1_params[$i]}"
		previous_increment="`previouseffectincrement`"
		if [ "$previous_increment" -ne 0 ] ; then
			previous_duration="${duration[$i-$previous_increment]}" # already in thousandths.
			previous_frames=`div1000 $(( $frames_per_ms * $previous_duration / 1000 ))` 
		fi
		next_increment="`nexteffectincrement`"
		if [ "$next_increment" -ne 0 ] ; then
			next_duration=`seconds2ms ${duration[$i+$next_increment]}`  # duration in thousandths of sec
			next_frames=$( duration2frames $next_duration )  # frames for next slide
		fi
		if [ "$previous_increment" -ne 0 ] && [ "$next_increment" -ne 0 ] ; then
			scroll "$direction" "$file" "$normal_bg" "$frames" "$(( $previous_frames + 1 ))" "$(( $frames - $next_frames ))"
			rendered_frames=`div1000 $(( $frames_per_ms * ( ${duration[$i]} - $previous_duration - $next_duration ) / 1000 ))` # both duration and fps are in ms
			old_rendered_frames=`div1000 $(( $frames_per_ms * ( ${duration[$i]} + $previous_duration - $next_duration ) / 1000 ))` # both duration and fps are in ms
		elif [ "$previous_increment" -ne 0 ] ; then
			scroll "$direction" "$file" "$normal_bg" "$frames" "$(( $previous_frames + 1 ))" "$frames" '#'
			rendered_frames=`div1000 $(( $frames_per_ms * ( ${duration[$i]} - $previous_duration ) / 1000 ))` # both duration and fps are in ms
			old_rendered_frames=`div1000 $(( $frames_per_ms * ( ${duration[$i]} + $previous_duration ) / 1000 ))` # both duration and fps are in ms
		elif [ "$next_increment" -ne 0 ] ; then
			scroll "$direction" "$file" "$normal_bg" "$frames" 1 "$(( $frames - $next_frames ))" '#'
			rendered_frames=`div1000 $(( $frames_per_ms * ( ${duration[$i]} - $next_duration ) / 1000 ))` # both duration and fps are in ms
			old_rendered_frames=`div1000 $(( $frames_per_ms * ( ${duration[$i]} + $next_duration ) / 1000 ))` # both duration and fps are in ms
		else
			scroll "$direction" "$file" "$normal_bg" "$frames" 1 "$frames" "#"
			rendered_frames="$frames"
		fi
		if [ "$rendered_frames" -le 0 ] ; then
			echo "[dvd-slideshow] ERROR: Frames rendered are less than 1!"
			echo "[dvd-slideshow] 	Either you specified a duration = 0 "
			echo "[dvd-slideshow] 	or the fade time(s) are longer than the slide time."
			cleanup; exit 0
		fi
		encode_fade
#		finish_progressbar $fr $frames
		## just in case we want to fade out or crossfade, we need to save the last image:
		mv "$tmpdir/fade_$dj.ppm" "$tmpdir/slide_$i.ppm"
		find "$tmpdir" -name "fade*.ppm" -type f -print0 | xargs -0 rm -f  # remove old files
		find "$tmpdir" -name "fade*.png" -type f -print0 | xargs -0 rm -f # remove old files
		set_end_frame_time ${duration[$i]}
#		end_frame_info $rendered_frames
		[ $debug -ge 1 ] &&  myecho "[dvd-slideshow] end_frame_number=$slide_end_frame end_time=$slide_end_hms"
		image_number=$(( $image_number + 1 ))
		interp=0
	elif [ "$file" == 'black' ] ; then  ###############################################
		## use plain black background with no picture
		## phase out "black" tag.  Use background:::black instead
		myecho "[dvd-slideshow] ERROR: use of black is depreciated.  Use the syntax:"
		myecho "[dvd-slideshow]        background:duration:subtitle:black   instead of:"
		myecho "[dvd-slideshow]        black:duration:subtitle            <depreciated>"
		cleanup; exit 1
	elif [ "$file" == 'testslide' ] ; then  # TESTSLIDE
		## Create a slide of size 720x480 with yellow lines
		convert -size 720x480 xc:gray -fill yellow -draw "line 0,0,719,0 text 110,0 \"0\" line 0,60,719,60 text 110,60 \"60\" line 0,120,719,120 text 110,120 \"120\" line 0,180,719,180 text 110,180 \"180\" line 0,240,719,240 text 110,240 \"240\" line 0,300,719,300 text 110,300 \"300\" line 0,360,719,360 text 110,360 \"360\" line 0,420,719,420 text 110,420 \"420\" line 0,479,719,479 text 110,479 \"479\" " -fill orange -draw "line 0,0,0,480 text 0,180 \"0\" line 90,0,90,480 text 90,180 \"90\" line 180,0,180,480 text 180,180 \"180\" line 270,0,270,480 text 270,180 \"270\" line 360,0,360,480 text 360,180 \"360\" line 450,0,450,480 text 450,180 \"450\" line 540,0,540,480 text 540,180 \"540\" line 630,0,630,480 text 630,180 \"630\" line 719,0,719,480 text 719,180 \"719\" " -type TrueColor -depth 8 -resize "$sq_to_dvd_pixels" -resize "$dvd_width"x"$dvd_height" -quality 100 "$tmpdir/slide_$i.ppm"
		set_end_frame_time ${duration[$i]}
#		end_frame_info $rendered_frames
		[ $debug -ge 1 ] &&  myecho "[dvd-slideshow] end_frame_number=$slide_end_frame end_time=$slide_end_hms"
		myecho "[dvd-slideshow]############################################################"
	elif [ "$file" == 'exit' ] ; then  # EXIT
		## stop here and finish .vob
		set_end_frame_time 0 
#		end_frame_info 0
		[ $debug -ge 1 ] &&  myecho "[dvd-slideshow] end_frame_number=$slide_end_frame end_time=$slide_end_hms"
		break
	elif [ "$file" == 'background' ] ; then  # BACKGROUND
		bg="${effect1[$i]}"
		if [ -n "$bg" ] ; then
			background "$bg"   # calls the background image subroutine
		fi
		if [ "${duration[$i]}" -ne 0 ] ; then  
			myecho "[dvd-slideshow] $file `hms ${duration[$i]}`"
			## user wants to actually display background for a given time
			myecho "[dvd-slideshow] Displaying background $(truncate_filename "$bgfile")"
			cp "$tmpdir/slideshow_background.ppm" "$tmpdir/slide_$i.ppm"
			if [ "${subtitle[$i]}" == 'black' ] ; then
				myecho "[dvd-slideshow] WARNING: Subtitle=${subtitle[$i]}. Are you sure?"
			elif [ -n "${subtitle[$i]}" ] ; then
				myecho "[dvd-slideshow] Subtitle=${subtitle[$i]}"
			fi
			subtitle1[$i]="$( echo "${subtitle[$i]}" | awk -F';' '{print $1}' )"
#			echo "subtitle1=${subtitle1[$i]}"
			if [ -n "${subtitle1[$i]}" -a "$subtitle_type" == 'render' ] ; then
				subtitle "${subtitle1[$i]}" $i transparent # creates subtitle_$i.png
				composite -compose src-over -type TrueColor -depth 8 "$tmpdir"/subtitle_"$i".png "$tmpdir"/slide_"$i".ppm "$tmpdir"/slide_"$i".ppm
			fi
			encode "$tmpdir/slide_$i.ppm" "$frames"
		fi
		set_end_frame_time ${duration[$i]}
#		end_frame_info $rendered_frames
		[ $debug -ge 1 ] &&  myecho "[dvd-slideshow] end_frame_number=$slide_end_frame end_time=$slide_end_hms"
		myecho "[dvd-slideshow]############################################################"
#identify "$tmpdir/slide_$i.ppm"
	elif [ "`echo $file | tr -d \[:blank:\]`" == 'chapter' ] ; then   # CHAPTER
		## create a chapter marker at this time, but don't do anything else...
		manual_chapter_markers=1  # allow manual chapter markers
		write_chap=1
		subtitle[$i]=''  # set subtitle to nothing so we don't get a subtitle
		myecho "[dvd-slideshow] Setting chapter marker at $slide_end_hms"
		set_end_frame_time 0
#		end_frame_info 0
		myecho "[dvd-slideshow]############################################################"
	elif [ "${audio_file[$i]}" -eq 1 ] ; then  # AUDIO MP3
		myecho "[dvd-slideshow] Audiofile $( truncate_filename "$file")"
		if [ "${audio_track[$i]}" -eq 1 ] ; then
			audio_1[$i_audio]="${file}"
			audio1_effect1[$i_audio]="${effect1[$i]}"
			audio1_effect1_params[$i_audio]="${effect1_params[$i]}"
			audio1_effect2[$i_audio]="${effect2[$i]}"
			audio1_effect2_params[$i_audio]="${effect2_params[$i]}"
			audio_index="$i_audio"
			audio_index_padded=`addzeros "$i_audio"`
			i_audio=$(( $i_audio + 1 ))
		elif [ "${audio_track[$i]}" -eq 2 ] ; then
			audio_2[$j_audio]="${file}"
			audio2_effect1[$j_audio]="${effect1[$i]}"
			audio2_effect1_params[$j_audio]="${effect1_params[$i]}"
			audio2_effect2[$j_audio]="${effect2[$i]}"
			audio2_effect2_params[$j_audio]="${effect2_params[$i]}"
			audio_index="$j_audio"
			audio_index_padded=`addzeros "$j_audio"`
			j_audio=$(( $j_audio + 1 ))
		else
			myecho "[dvd-slideshow] ERROR: Bad audio track number."
			myecho "[dvd-slideshow]        only use audio track 1 or 2"
			cleanup; exit 1
		fi
		track="${audio_track[$i]}"
		suffix=`echo "$file" | awk -F. '{print tolower($NF)}'`
		if [ "$suffix" == "mp3" ] ; then
			myecho "[dvd-slideshow] decoding mp3 audio file... be patient..."
			if [ "$smp" -eq 1 ] ; then
				lame --decode "${file}" "$tmpdir/audio$track"_"$audio_index_padded.wav" 2> /dev/null &
			else
				lame --decode "${file}" "$tmpdir/audio$track"_"$audio_index_padded.wav" 2> /dev/null
			fi
		elif [ "$suffix" == "m4a" ] || [ "$suffix" == "aac" ] ; then
			if [ "$smp" -eq 1 ] ; then
			faad -o "$tmpdir/audio$track"_"$audio_index_padded.wav" "$file" &
			else
			faad -o "$tmpdir/audio$track"_"$audio_index_padded.wav" "$file" 
			fi
		elif [ "$suffix" == "ogg" ] ; then
			myecho "[dvd-slideshow] decoding ogg audio... be patient."
			if [ "$smp" -eq 1 ] ; then
				oggdec --quiet -o "$tmpdir/audio$track"_"$audio_index_padded.wav" "${file}" &
			else
				oggdec --quiet -o "$tmpdir/audio$track"_"$audio_index_padded.wav" "${file}"
			fi
		elif [ "$suffix" == "wav" ] ; then
			myecho "[dvd-slideshow] processing wav audio... we will splice it later."
			cp "${file}" "$tmpdir/audio$track"_"$audio_index_padded.wav"
		elif [ "$file" == 'silence' ]; then
			myecho "[dvd-slideshow] creating silent audio track... we will splice it later."
			if [ "$smp" -eq 1 ] ; then
				sox -t raw -s -w -c 2 -r $audio_sample_rate /dev/zero -t wav -c 2 -r $audio_sample_rate "$tmpdir/audio$track"_"$audio_index_padded.wav" trim 0 1 &
			else
				sox -t raw -s -w -c 2 -r $audio_sample_rate /dev/zero -t wav -c 2 -r $audio_sample_rate "$tmpdir/audio$track"_"$audio_index_padded.wav" trim 0 1
			fi
		else
			myecho "[dvd-slideshow] ERROR:  Unknown audio file format.  Must be mp3, ogg, mp4/aac, wav, or silence"
		fi
		## now set the starting and ending point of this audio track:
#		myecho "audio_track=${audio_track[$i]} "
		if [ "${audio_track[$i]}" -eq 1 ] ; then
			audio1_start[$audio_index]="$slide_start_time"   # in ms
			## set ending point of the audio track:
			if [ "$audio_index" -gt 0 ] ; then # not first audio track
				audio1_end[$(($audio_index-1))]="$slide_end_time"   # in ms from last slide
#				myecho "[dvd-slideshow] Set end time for audio file $audio_index to `hms $slide_end_time`"
			else # set audio end to zero for now...
				audio1_end[$audio_index]=0   # in ms from last slide
			fi
		elif [ "${audio_track[$i]}" -eq 2 ] ; then
			audio2_start[$audio_index]="$slide_start_time"   # in ms
			## set ending point of the audio track:
			if [ "$audio_index" -gt 0 ] ; then
				audio2_end[$(($audio_index-1))]="$slide_end_time"   # in ms from last slide
#				myecho "[dvd-slideshow] Set end time for audio file $audio_index to `hms $slide_end_time`"
			else # set audio end to zero for now...
				audio2_end[$audio_index]=0   # in ms from last slide
			fi
		fi
#		myecho "[dvd-slideshow] track=${audio_track[$i]} audio_start=$slide_start_time audio_end=$slide_end_time"
#		myecho "[dvd-slideshow] track=${audio_track[$i]} audio_start=${audio1_start[$audio_index]} audio_end=${audio1_end[$audio_index]}"
#		song_length_ms=`wavlength "$audio_index_padded.wav"`  # needed for "audio" duration keyword
#		song_length_hms=`hms "$song_length_ms"`
#echo "song_length_ms=$song_length_ms song_length_hms=$song_length_hms"
		subtitle[$i]=''  # set subtitle to nothing so we don't get a subtitle
		set_end_frame_time 0
#		end_frame_info 0
		myecho "[dvd-slideshow]############################################################"
	else  
		myecho "[dvd-slideshow] Unrecognized or malformed line in your input file:"
		myecho "[dvd-slideshow] $file. effect=${effect1[$i]} effect_params=${effect1_params[$i]}"
		myecho "Fix it and try again."
		cleanup; exit 1
	fi
	
	thumb_width=$(( ( $dvd_width - 100 ) / 6 ))
	thumb_height=$(( ( $dvd_height - 100 ) / 4 ))
	## setup the chapter markers at the start of each picture:
	if [ "$write_chap" -eq 1 ] ; then   # and chapter-select =1 
#		chapter_marker="$(( ( ($slide_start_time / 100) + 1 ) * 100 ))" ## round up chapter marker
		chapter_marker="$slide_start_time"  # 
		chaps[$this_chap]=`hms "$chapter_marker"`
		## now make a tiny thumbnail for the menu?:
		thumbs[$this_chap]="$tmpdir/slide_"$i"_thumb.ppm"
#		convert "$tmpdir/slide_$i.ppm" -depth 8 -resize "$thumb_width"x"$thumb_height" "$tmpdir"/slide_$i"_thumb.ppm"
		this_chap=$(($this_chap + 1))
		write_chap=0
	fi

	## now, create the xml file to pass to spumux
	if [ "$spumux_header" -eq 0 ]; then  # only do once on first pass:
		spumux_header=1
		echo '<subpictures>' > "$tmpdir/$slideshow_name".spumux
		echo '	<stream>' >> "$tmpdir/$slideshow_name".spumux
		continuous_subtitle_flag=0
		echo '<subpictures>' > "$tmpdir/$slideshow_name".spumux2
		echo '	<stream>' >> "$tmpdir/$slideshow_name".spumux2
	fi	

	## Subtitles ########################################################
	## add the subtitle track if it exists:  SUBTITLE
	if [ -n "${subtitle[$i]}" ] && [ "$subtitle_type" != 'render' ] ; then
		## move all the pixel-related stuff into a function, but keep timing stuff here...
#		echo "$i subtitle_rendered=${subtitle[$i]}"
		# look for semicolon, indicating multiple subtitle tracks:
		subtitle1[$i]="$( echo "${subtitle[$i]}" | awk -F';' '{print $1}' )"
		subtitle2[$i]="$( echo "${subtitle[$i]}" | awk -F';' '{print $2}' )"
#		echo "subtitle1=${subtitle1[$i]}"
#		echo "subtitle2=${subtitle2[$i]}"
		if [ -n "${subtitle2[$i]}" ] ; then
			has_subtitles2=1
			subtitle "${subtitle2[$i]}" $i  # just creates the .png file for overlay
			mv "$tmpdir"/subtitle_$i.png "$tmpdir"/subtitle2_$i.png
		fi
		if [ -n "${subtitle1[$i]}" ] ; then
			has_subtitles=1
			subtitle "${subtitle1[$i]}" $i  # just creates the .png file for overlay
#		else
#			cp "$transparent_bg" "$tmpdir"/subtitle_$i.png
		fi
	fi

	## let's assume the subtitle stays on the whole duration of the slide?
	subtitle_start=`hms "$slide_start_time"`
	subtitle_end=`hms "$slide_end_time"`

        ### Fix by AW.  Check to see if last subtitle was the same as this one!
	## if so, then display it continuously:
	if [ "$i" -gt 0 ] ; then
		# subtitle track 1:
	        if [ "${subtitle1[$i]}" != "${subtitle1[$(($i-1))]}" ] ; then
			## subtitles different:
#			myecho "subtitles different i=${subtitle1[$i]} i-1=${subtitle1[$(($i-1))]}"
			## so, we have three cases here:  
		        if [ -n "${subtitle1[$i]}" -a -z "${subtitle1[$(($i-1))]}" ] ; then
				# Current subtitle is nonzero, and previous subtitle is empty:
				# Just update values, don't write out yet!
				write_last_subtitle=1
			else	## need to write out subtitle in all other cases:
				write_last_subtitle=0
				echo '		<spu start="'$continuous_subtitle_start'" end="'$continuous_subtitle_end'" transparent="'$transparent_color'" image="'$tmpdir/subtitle_$(($i-1)).png'">' >> "$tmpdir/$slideshow_name".spumux
				echo '		</spu>' >> "$tmpdir/$slideshow_name".spumux
				echo '		' >> "$tmpdir/$slideshow_name".spumux
			fi
			# set new subtitle starting point:
			continuous_subtitle_start="$subtitle_start"
		else
			# subtitles are the same.  Don't write it out yet!
			# save the continuous_subtitle_end variable until done...
			if [ -n "${subtitle1[$i]}" ] ; then
				write_last_subtitle=1
				# subtitles are the same AND the current one is not empty
			fi
		fi
		continuous_subtitle_end="$subtitle_end"  # update end point every time

		# subtitle track 2:
	        if [ "${subtitle2[$i]}" != "${subtitle2[$(($i-1))]}" ] ; then
			## subtitles different:
#			myecho "subtitles different i=${subtitle2[$i]} i-1=${subtitle2[$(($i-1))]}"
			## so, we have three cases here:  
		        if [ -n "${subtitle2[$i]}" -a -z "${subtitle2[$(($i-1))]}" ] ; then
				# Current subtitle is nonzero, and previous subtitle is empty:
				# Just update values, don't write out yet!
				write_last_subtitle2=1
			else	## need to write out subtitle in all other cases:
				write_last_subtitle2=0
				echo '		<spu start="'$continuous_subtitle_start2'" end="'$continuous_subtitle_end2'" transparent="'$transparent_color'" image="'$tmpdir/subtitle2_$(($i-1)).png'">' >> "$tmpdir/$slideshow_name".spumux2
				echo '		</spu>' >> "$tmpdir/$slideshow_name".spumux2
				echo '		' >> "$tmpdir/$slideshow_name".spumux2
			fi
			# set new subtitle starting point:
			continuous_subtitle_start2="$subtitle_start"
		else
			# subtitles are the same.  Don't write it out yet!
			# save the continuous_subtitle_end variable until done...
			if [ -n "${subtitle2[$i]}" ] ; then
				write_last_subtitle2=1
				# subtitles are the same AND the current one is not empty
			fi
		fi
		continuous_subtitle_end2="$subtitle_end"  # update end point every time
	fi

	let i=$i+1
done

#######################################################################
####### End of loop over each line of input .txt file

if [ -f "$tmpdir/$slideshow_name".spumux ] && [ "$subtitle_type" != 'render' ] ; then
	if [ "$write_last_subtitle" -eq 1 ] ; then
		# write out last subtitle:
		echo '		<spu start="'$continuous_subtitle_start'" end="'$continuous_subtitle_end'" transparent="'$transparent_color'" image="'$tmpdir/subtitle_$(($i-1)).png'">' >> "$tmpdir/$slideshow_name".spumux
		echo '		</spu>' >> "$tmpdir/$slideshow_name".spumux
		echo '		' >> "$tmpdir/$slideshow_name".spumux
	fi
	## write the bottom of the subpictures file:
	echo '	</stream>' >> "$tmpdir"/"$slideshow_name".spumux
	echo '</subpictures>' >> "$tmpdir"/"$slideshow_name".spumux
fi
if [ -f "$tmpdir/$slideshow_name".spumux2 ] && [ "$subtitle_type" != 'render' ] ; then
	if [ "$write_last_subtitle2" -eq 1 ] ; then
		# write out last subtitle:
		echo '		<spu start="'$continuous_subtitle_start2'" end="'$continuous_subtitle_end2'" transparent="'$transparent_color'" image="'$tmpdir/subtitle2_$(($i-1)).png'">' >> "$tmpdir/$slideshow_name".spumux2
		echo '		</spu>' >> "$tmpdir/$slideshow_name".spumux2
		echo '		' >> "$tmpdir/$slideshow_name".spumux2
	fi
	## write the bottom of the subpictures file:
	echo '	</stream>' >> "$tmpdir"/"$slideshow_name".spumux2
	echo '</subpictures>' >> "$tmpdir"/"$slideshow_name".spumux2
fi

############################### Wait for mpeg2enc to finish

# just close the fifo and wait for the encoder to finish
logecho "[dvd-slideshow] mpeg2enc process=$yuvpid"
logecho "[dvd-slideshow] output from ps:"
logecho "`ps $yuvpid`"
# close pipe to mpeg2enc
exec 3>&-  
myecho '[dvd-slideshow] waiting for encoder to finish...'
wait $yuvpid
yuvpid=0

## calculate total slideshow time:
#end_time=$(( $total_slideshow_frames * 1000 / $frames_per_ms ))  ## in seconds
end_time="$slide_end_time"
end_hms="$slide_end_hms"

############################################################################
# AUDIO section...
##########################################################################
myecho "[dvd-slideshow]#####################################"

# check that video worked, otherwise audio will hang for time=0:
if [ "$slide_end_time" -eq 0 ] ; then
	myecho "[dvd-slideshow] ERROR: audio duration = 0.  Exiting..."	
	exit
fi

## now do the audio for this slideshow ##########################
let i=0
total_audio_length=0
commandline_audio=0
if [ -n "${passed_audio[0]}" ] ; then  ## command-line passed audio
	myecho "[dvd-slideshow] Processing command-line audio..."
	for file in "${passed_audio[@]}"; do
		i_padded=`addzeros $i`
		myecho "[dvd-slideshow] Working on track 1 audio file $i"
		myecho "[dvd-slideshow] $file"
		fade_in_time="3000" # default 3 second
		fade_out_time="3000"
		fade_in_hms=`hms "$fade_in_time"`
		fade_out_hms=`hms "$fade_out_time"`
		myecho "[dvd-slideshow] fade_in_time=$fade_in_hms fade_out_time=$fade_out_hms"
		track=1
		song_length=`wavlength "$tmpdir/audio1_$i_padded.wav"`
		if [ "$song_length" -lt "$(( $fade_in_time + $fade_out_time ))" ] ; then
			fade_in_time=$(( ( $song_length - 1 ) / 2 ))
			fade_out_time="$fade_in_time"
		fi
		song_length_hms=`hms "$song_length"`
		total_audio_length="$(( $total_audio_length + $song_length ))"
		myecho "[dvd-slideshow] total_audio_length=`hms $total_audio_length`"
		sox -v 0.95 "$tmpdir/audio$track"_"$i_padded.wav" -w -s -c 2 -r $audio_sample_rate "$tmpdir/audio1_$i_padded.raw" fade t "$fade_in_hms" "$song_length_hms" "$fade_out_hms"
		let i=$i+1
		myecho "[dvd-slideshow] ###############"
	done
	i_padded=`addzeros $i`
	## check to make sure the audio spans the video time:
	if [ "$total_audio_length" -lt "$end_time" ] ; then
		# video is longer than audio.  need to add silence to end.
		thetime_hms=`hms $(( $end_time - $total_audio_length + 1000 ))` #plus 10 so sox actually crops.
		myecho "[dvd-slideshow] Buffering end of audio file with silence for $thetime_hms"
		sox -t raw -s -w -c 2 -r $audio_sample_rate /dev/zero -w -s -c 2 -r $audio_sample_rate "$tmpdir/audio1_$i_padded.raw" trim 0 "$thetime_hms"
	fi
	
	## cat all the audio files together: 
	cat "$tmpdir"/audio1_????.raw | sox -t raw -w -s -c 2 -r $audio_sample_rate - "$tmpdir/audio1.wav"
	## fade out at end of video:
	sox "$tmpdir/audio1.wav" "$tmpdir/audio_out.wav" fade t 0 "$end_hms" "$fade_out_hms"
	mv "$tmpdir/audio_out.wav" "$tmpdir/audio1.wav"
	## mpeg2 audio:
	## AC3 audio may be more compatible:
	if [ "$ac3" -eq 1 ] && [ "$output_format" != 'flv' ] ; then
		checkforprog ffmpeg
		myecho "[dvd-slideshow] Creating ac3 audio for $file..."
		ffmpeg -i "$tmpdir/audio1.wav" -y -vn -ab $audio_bitrate -acodec ac3 -ar $audio_sample_rate -ac 6 "$tmpdir/audio1.ac3" >> "$outdir/$logfile" 2>&1
		if [ $? -ne 0 ] ; then
			## ffmpeg errored
			myecho "[dvd-slideshow] ERROR during ffmpeg execution!"
			myecho "[dvd-slideshow] see $outdir/$logfile for details"
			cleanup; exit 1
		fi
	else
		## toolame is way faster! (3x in my test)
		it=`which toolame`
		if [ -n "$it" ] ; then
			toolame_version=`toolame -h | head -n 4 | grep version | awk '{ print $3 }'`
			myecho "[dvd-slideshow] using toolame $toolame_version..."
			if [ "$toolame_version" == '0.2m' ] ; then
				toolame -s $audio_sample_rate -b $audio_bitrate "$tmpdir/audio1.wav" "$tmpdir/audio1.mp2" >> "$outdir"/"$logfile" 2>&1
			else
				if [ "$vcd" -eq 1 ] || [ "$svcd" -eq 1 ] ; then
				toolame -s 44.1 -b $audio_bitrate "$tmpdir/audio1.wav" "$tmpdir/audio1.mp2" >> "$outdir"/"$logfile" 2>&1
				else
				toolame -s 48 -b $audio_bitrate "$tmpdir/audio1.wav" "$tmpdir/audio1.mp2" >> "$outdir"/"$logfile" 2>&1
				fi
			fi
		else
			myecho "[dvd-slideshow] using mp2enc"
			mp2enc -v $verbosity -b $audio_bitrate -r $audio_sample_rate -s -o "$tmpdir/audio1.mp2" < "$tmpdir/audio1.wav"
		fi
	fi
	commandline_audio=1
fi  # end processing command-line passed audio

if [ -z "${audio_1[0]}" ] && [ "$commandline_audio" -eq 0 ] ; then
	## no audio file passed on command line or txtfile.  use silence:
	audio_1[0]='silence'  # no duration needed
	myecho "[dvd-slideshow] No audio files passed.  Using $end_hms silence."
	audio1_start=0 
	audio1_end="$end_time"
fi


## let's split this audio processing into two loops:  one just prepares the
## initial fadein/fadeout, and the next loop figures out the timing and cropping 

let i=0
skip_next_audio_file=0
if [ -n "${audio_1[0]}" ] ; then   ## audio track 1 files specified in .txt file
#	myecho "[dvd-slideshow] Processing track 1 audio from .txt file..."
	for file in "${audio_1[@]}"; do
		if [ "$skip_next_audio_file" -eq 1 ] ; then
#			myecho -n "i=$i myindex=$myindex  "
			if [ $i -eq $myindex ] ; then
				skip_next_audio_file=0
			fi	
			myecho "[dvd-slideshow] Skipping un-needed audio file $i"
			myecho "[dvd-slideshow] ###############"
			let i=$i+1
			continue
		fi
		i_padded=`addzeros $i`
		myecho "[dvd-slideshow] Working on track 1 audio file $i"
		myecho "[dvd-slideshow] $file"
		
		if [ "${audio1_end[$i]:-0}" -eq 0 ] || [ -z "$audio1_end[$i]}" ] ; then
#		if [ -z "$audio1_end[$i]}" ] || [ $audio1_end[$i] ] ; then
			## must be last audio track.  assume run til end
			audio1_end[$i]="$end_time"	
		fi

#		if [ ${audio1_start[$i]} -ge ${audio1_end[$i]} ] ; then
#			myecho "[dvd-slideshow] ERROR: Audio file endpoint is same or before start."
#			myecho "[dvd-slideshow] 	     This is sometimes caused by having two audio files"
#			myecho "[dvd-slideshow] 	     sequentially one after another with no slide between."
#			myecho "[dvd-slideshow] 	     Fix it and try again."
#			cleanup; exit 1
#		fi
	
		if [ "$file" == 'silence' ]; then   # create silence for the correct time:
			song_end_ms=$(( ${audio1_end[$i]} - ${audio1_start[$i]} ))
			[ "$song_end_ms" -lt 0 ] && song_end_ms=0
			song_end_hms=`hms $song_end_ms`
			song_start_hms="0"  # cannot modify starting point yet...
			myecho "[dvd-slideshow] Creating silence audio file for $song_end_hms"
			sox -t raw -s -w -c 2 -r $audio_sample_rate /dev/zero -w -s -c 2 -r $audio_sample_rate "$tmpdir"/audio1_$i_padded.raw trim "0" "$song_end_hms"
		else
			## file should only be wav format at this point since it was decoded before
			## all audio files are of the format "$tmpdir"/audio_1.wav
			# I found some "popping" in the audio for some tracks.
			# it turns out that this is caused by audio going
			# too low or too high and getting clipped.
			# reducing the volume a little should help.
			volume=0.95
#			sox "$tmpdir/audio1_$i_padded.wav" -e stat 2> "$tmpdir"/trash.txt 
#			song_length=`cat "$tmpdir"/trash.txt | grep 'Length (seconds):' | awk -F: '{print $2}' | awk -F. '{print $1}'`
#			rm "$tmpdir"/trash.txt
#			song_length_ms="$(( 1000 * $song_length))"
			waitforfile "$tmpdir/audio1_$i_padded.wav"
			song_length_ms=`wavlength "$tmpdir/audio1_$i_padded.wav"`
			song_length_hms=`hms $song_length_ms`
			myecho "[dvd-slideshow] Original audio track length=$song_length_hms"

#			myecho "[dvd-slideshow] This audio plays in slideshow from `hms ${audio1_start[$i]}` to `hms ${audio1_end[$i]}`"
			if [ -z "${audio1_effect1_params[$i]}" ] ; then
				fade_in_time="0"
			else
				fade_in_time=`seconds2ms ${audio1_effect1_params[$i]}`
			fi
			if [ -z "${audio1_effect2_params[$i]}" ] ; then
				fade_out_time="0"
			else
				fade_out_time=`seconds2ms ${audio1_effect2_params[$i]}`
			fi
			fade_in_hms=`hms "$fade_in_time"`
			fade_out_hms=`hms "$fade_out_time"`
			myecho "[dvd-slideshow] Fade in time=$fade_in_hms Fade out time=$fade_out_hms"

			if [ "$song_length_ms" -lt "$(( $fade_in_time + $fade_out_time ))" ] ; then
				myecho "[dvd-slideshow] WARNING: Song length is shorter than the combined fadein and fadeout times"
				fade_in_time=$(( ( $song_length - 1 ) / 2 ))
				fade_out_time="$fade_in_time"
				myecho "[dvd-slideshow]          Setting fadein and fadeout time to `hms $fade_in_time`"
			fi

			song_end_ms=$(( ${audio1_end[$i]} - ${audio1_start[$i]} ))
			[ "$song_end_ms" -lt 0 ] && song_end_ms=0
			song_end_hms=`hms $song_end_ms`
			song_start_hms="0"  # cannot modify starting point yet...
#			myecho "[dvd-slideshow] audio1_start=${audio1_start[$i]} audio1_start+1=${audio1_start[$(($i+1))]}"
#			myecho "[dvd-slideshow] song_start_hms=$song_start_hms song_end_hms=$song_end_hms"
#			myecho "[dvd-slideshow] audio_start=`hms ${audio1_start[$i]}`. audio_end=`hms ${audio1_end[$i]}`."
			# check to see if we need to add multiple files together first:
			if [ -n "${audio1_start[$(($i+1))]}" ] && [ "${audio1_start[$i]}" -ge "${audio1_start[$(($i+1))]}" ] ; then
#				myecho " [dvd-slideshow] Multiple files found right after one another!"
				## User might add 10 audio files when only 2 are needed
				## to span the video...  check for this:
				## 1.  find next real audio start marker
				## 2. compare length of songs up to that point.
				myindex=$i
				while [ -n "${audio1_start[$(($myindex+1))]}" ] && [ "${audio1_start[$myindex]}" -ge "${audio1_start[$(($myindex+1))]}" ] ; do
					# grab last starting time:
					next_real_audio_start="${audio1_start[$(($myindex+2))]}"
					if [ -z "$next_real_audio_start" ] ; then
						## must be last audio track.  assume run til end
						next_real_audio_start="$end_time"	
					fi
#					myecho " [dvd-slideshow] next audio start=$next_real_audio_start myindex=$myindex"
					myindex=$(( $myindex + 1 ))
				done
				# set first file audio endpoint to the least
				# of the full length of song or the start of the next file:
				# (whichever comes first)
				if [ $next_real_audio_start -lt $(( ${audio1_start[$i]} + $song_length_ms )) ] ; then
					# this song is too long and needs to be cropped
					# set endpoint to starting point of next song
					audio1_end[$i]=$next_real_audio_start 
#					# ignore next audio files until $next_real_audio_start
					skip_next_audio_file=1
#					myecho "[dvd-slideshow] Next audio file not needed"
#					myecho "[dvd-slideshow] Setting audio1_end[$i]=${audio1_end[$i]}"
				else
					# song not long enough... need to add next audio file
					# or buffer with silence at end.
					audio1_end[$i]=$(( ${audio1_start[$i]} + $song_length_ms )) 
					# set second file audio startpoint to end of fist song:
					audio1_start[$(($i+1))]="${audio1_end[$i]}" 
#					myecho "[dvd-slideshow] Concatenating next audio file also"
#					myecho " [dvd-slideshow] Setting audio1_start[$(($i+1))]=${audio1_end[$i]} audio1_end[$i]=${audio1_end[$i]}"
				fi
			fi

			song_end_ms=$(( ${audio1_end[$i]} - ${audio1_start[$i]} ))
			[ "$song_end_ms" -lt 0 ] && song_end_ms=0
			song_end_hms=`hms $song_end_ms`
			song_start_hms="0"  # cannot modify starting point yet...
#			myecho "[dvd-slideshow] song_start_hms=$song_start_hms song_end_hms=$song_end_hms"

			if [ "$song_length_ms" -lt "$song_end_ms" ] ; then
#				myecho "Song length < song_end   `hms $song_length_ms` < `hms $song_end_ms`"
				# video is longer than audio.  need to add silence to end.
				# fade only to the end of song length now, because we may have to add silence:
				sox -v 0.95 "$tmpdir/audio1_$i_padded.wav" -w -s -c 2 -r $audio_sample_rate "$tmpdir/audio1_$i_padded.raw" fade t "$fade_in_hms" "$song_length_hms" "$fade_out_hms"
				thetime_hms=`hms $(( $song_end_ms - $song_length_ms + 1000 ))` #plus 1s so sox actually crops.
				thetime2_hms=`hms $(( $song_end_ms - $song_length_ms ))` 
				myecho "[dvd-slideshow] Adding $thetime2_hms of silence to end of original audio file"
				sox -t raw -s -w -c 2 -r $audio_sample_rate /dev/zero -w -s -c 2 -r $audio_sample_rate "$tmpdir/silence.raw" trim 0 "$thetime_hms"
				cat "$tmpdir/audio1_$i_padded.raw" "$tmpdir/silence.raw" > "$tmpdir/audio.raw" 
				mv "$tmpdir/audio.raw" "$tmpdir/audio1_$i_padded.raw"
				# hopefully there won't be many times where the audio needs to be buffered 
				# at the end, so we'll add one extra step to make the coding easier:
				sox -t raw -s -w -c 2 -r $audio_sample_rate "$tmpdir/audio1_$i_padded.raw" "$tmpdir/audio1_$i_padded.wav"
				rm "$tmpdir"/silence.raw
			fi
			## fade in by default... may change later
			sox -v 0.95 "$tmpdir/audio1_$i_padded.wav" -w -s -c 2 -r $audio_sample_rate "$tmpdir/audio1_$i_padded.raw" fade t "$fade_in_hms" "$song_end_hms" "$fade_out_hms"
		fi
		if [ $i -eq 0 ] && [ "${audio1_start[$i]}" -ne 0 ] ; then
			## buffer beginning with silence:
			thetime_hms=`hms "${audio1_start[$i]}"`
			myecho "[dvd-slideshow] Adding $thetime_hms to beginning of audio file"
			sox -t raw -s -w -c 2 -r $audio_sample_rate /dev/zero -w -s -c 2 -r $audio_sample_rate "$tmpdir/silence.raw" trim 0 "$thetime_hms"
			cat "$tmpdir"/silence.raw "$tmpdir/audio1_$i_padded.raw" > "$tmpdir/audio.raw" 
			mv "$tmpdir/audio.raw" "$tmpdir/audio1_$i_padded.raw"
			rm "$tmpdir"/silence.raw
		fi
		myecho "[dvd-slideshow] This audio plays in slideshow from `hms ${audio1_start[$i]}` to `hms ${audio1_end[$i]}`"
		if [ "$debug" -ge 1 ] ; then
			length=`rawlength "$tmpdir/audio1_$i_padded.raw"`
			myecho "[dvd-slideshow] Actual length of .raw file=`hms $length`"
		fi
		let i=$i+1
		myecho "[dvd-slideshow] ###############"
	done
		
	myecho "[dvd-slideshow] Concatenating all audio files..."
	## cat all the audio files together: 
#	ls "$tmpdir"/audio1_????.raw | xargs -0 cat | sox -t raw -w -s -c 2 -r $audio_sample_rate - "$tmpdir/audio1.wav"
#	find "$tmpdir" -name audio1_\?\?\?\?.raw -print0 | xargs -0 sox -t raw -w -s -c 2 -r $audio_sample_rate - "$tmpdir/audio1.wav"
	cat "$tmpdir"/audio1_????.raw | sox -t raw -w -s -c 2 -r $audio_sample_rate - "$tmpdir/audio1.wav"
	if [ "$debug" -ge 1 ] ; then
		length=`wavlength "$tmpdir/audio1.wav"`
		myecho "[dvd-slideshow] Actual length of .raw file=`hms $length`"
	fi
	## AC3 audio may be more compatible:
	if [ "$ac3" -eq 1 ] && [ "$output_format" != 'flv' ]; then
		myecho "[dvd-slideshow] Creating ac3 audio..."
		checkforprog ffmpeg
		check_rm "$tmpdir/audio1.ac3"
		ffmpeg -i "$tmpdir/audio1.wav" -vn -ab $audio_bitrate -acodec ac3 -ar $audio_sample_rate -ac 6 "$tmpdir/audio1.ac3" >> "$outdir/$logfile" 2>&1
		if [ $? -ne 0 ] ; then
			## ffmpeg errored
			myecho "[dvd-slideshow] ERROR during ffmpeg execution!"
			myecho "[dvd-slideshow] see $outdir/$logfile for details"
			cleanup; exit 1
		fi
	else
		## toolame is way faster! (3x in my test)
		it=`which toolame`
		if [ -n "$it" ] ; then
			toolame_version=`toolame -h | head -n 4 | grep version | awk '{ print $3 }'`
			myecho "[dvd-slideshow] Creating mp2 audio using toolame $toolame_version..."
			if [ "$toolame_version" == '0.2m' ] ; then
				toolame -s $audio_sample_rate -b $audio_bitrate "$tmpdir/audio1.wav" "$tmpdir/audio1.mp2" >> "$outdir"/"$logfile" 2>&1
			else
				if [ "$vcd" -eq 1 ] || [ "$svcd" -eq 1 ] ; then
				toolame -s 44.1 -b $audio_bitrate "$tmpdir/audio1.wav" "$tmpdir/audio1.mp2" >> "$outdir"/"$logfile" 2>&1
				else
				toolame -s 48 -b $audio_bitrate "$tmpdir/audio1.wav" "$tmpdir/audio1.mp2" >> "$outdir"/"$logfile" 2>&1
				fi
			fi
		else
			myecho "[dvd-slideshow] Creating mp2 audio using mp2enc"
			mp2enc -v $verbosity -b $audio_bitrate -r $audio_sample_rate -s -o "$tmpdir/audio1.mp2" < "$tmpdir/audio1.wav"
		fi
	fi
fi
		

#################################################################
## now do this all again for audio track number 2:
let i=0
skip_next_audio_file=0
if [ -n "${audio_2[0]}" ] ; then   ## audio track 2 files specified in .txt file
	myecho "[dvd-slideshow] #######################################"
	myecho "[dvd-slideshow] Processing track 2 audio from .txt file..."
	myecho "[dvd-slideshow] #######################################"
	for file in "${audio_2[@]}"; do
		if [ "$skip_next_audio_file" -eq 1 ] ; then
#			myecho -n "i=$i myindex=$myindex  "
			if [ $i -eq $myindex ] ; then
				skip_next_audio_file=0
			fi	
			myecho "[dvd-slideshow] Skipping un-needed audio file $i"
			myecho "[dvd-slideshow] ###############"
			let i=$i+1
			continue
		fi
		i_padded=`addzeros $i`
		myecho "[dvd-slideshow] Working on track 2 audio file $i"
		myecho "[dvd-slideshow] $file"
		
		if [ "${audio2_end[$i]:-0}" -eq 0 ] || [ -z "$audio2_end[$i]}" ] ; then
#		if [ -z "$audio2_end[$i]}" ] || [ $audio2_end[$i] ] ; then
			## must be last audio track.  assume run til end
			audio2_end[$i]="$end_time"	
		fi

#		if [ ${audio2_start[$i]} -ge ${audio2_end[$i]} ] ; then
#			myecho "[dvd-slideshow] ERROR: Audio file endpoint is same or before start."
#			myecho "[dvd-slideshow] 	     This is sometimes caused by having two audio files"
#			myecho "[dvd-slideshow] 	     sequentially one after another with no slide between."
#			myecho "[dvd-slideshow] 	     Fix it and try again."
#			cleanup; exit 1
#		fi
	
		if [ "$file" == 'silence' ]; then   # create silence for the correct time:
			song_end_ms=$(( ${audio2_end[$i]} - ${audio2_start[$i]} ))
			[ "$song_end_ms" -lt 0 ] && song_end_ms=0
			song_end_hms=`hms $song_end_ms`
			song_start_hms="0"  # cannot modify starting point yet...
			myecho "[dvd-slideshow] Creating silence audio file for $song_end_hms"
			sox -t raw -s -w -c 2 -r $audio_sample_rate /dev/zero -w -s -c 2 -r $audio_sample_rate "$tmpdir"/audio2_$i_padded.raw trim "0" "$song_end_hms"
		else
			## file should only be wav format at this point since it was decoded before
			## all audio files are of the format "$tmpdir"/audio_2.wav
			# I found some "popping" in the audio for some tracks.
			# it turns out that this is caused by audio going
			# too low or too high and getting clipped.
			# reducing the volume a little should help.
			volume=0.95
			sox "$tmpdir/audio2_$i_padded.wav" -e stat 2> "$tmpdir"/trash.txt 
			## need to fix this so it's accurate to 0.01 sec, not just 1 sec
			## this will get floor(time) now.
#			myecho "$tmpdir/audio2_$i_padded.wav"
#			cat "$tmpdir"/trash.txt
			song_length=`cat "$tmpdir"/trash.txt | grep 'Length (seconds):' | awk -F: '{print $2}' | awk -F. '{print $1}'`
			rm "$tmpdir"/trash.txt
			song_length_ms="$(( 1000 * $song_length))"
			song_length_hms=`hms $song_length_ms`
			myecho "[dvd-slideshow] Original audio track length=$song_length_hms"

#			myecho "[dvd-slideshow] This audio plays in slideshow from `hms ${audio2_start[$i]}` to `hms ${audio2_end[$i]}`"

			if [ -z "${audio2_effect1_params[$i]}" ] ; then
				fade_in_time="0"
			else
				fade_in_time=`seconds2ms ${audio2_effect1_params[$i]}`
			fi
			if [ -z "${audio2_effect2_params[$i]}" ] ; then
				fade_out_time="0"
			else
				fade_out_time=`seconds2ms ${audio2_effect2_params[$i]}`
			fi
			fade_in_hms=`hms "$fade_in_time"`
			fade_out_hms=`hms "$fade_out_time"`
			myecho "[dvd-slideshow] Fade in time=$fade_in_hms Fade out time=$fade_out_hms"

			if [ "$song_length_ms" -lt "$(( $fade_in_time + $fade_out_time ))" ] ; then
				myecho "[dvd-slideshow] WARNING: Song length is shorter than the combined fadein and fadeout times"
				fade_in_time=$(( ( $song_length - 1 ) / 2 ))
				fade_out_time="$fade_in_time"
				myecho "[dvd-slideshow]          Setting fadein and fadeout time to `hms $fade_in_time`"
			fi

			song_end_ms=$(( ${audio2_end[$i]} - ${audio2_start[$i]} ))
			[ "$song_end_ms" -lt 0 ] && song_end_ms=0
			song_end_hms=`hms $song_end_ms`
			song_start_hms="0"  # cannot modify starting point yet...
#			myecho "[dvd-slideshow] audio2_start=${audio2_start[$i]} audio2_start+1=${audio2_start[$(($i+1))]}"
#			myecho "[dvd-slideshow] song_start_hms=$song_start_hms song_end_hms=$song_end_hms"
#			myecho "[dvd-slideshow] audio_start=`hms ${audio2_start[$i]}`. audio_end=`hms ${audio2_end[$i]}`."
			# check to see if we need to add multiple files together first:
			if [ -n "${audio2_start[$(($i+1))]}" ] && [ "${audio2_start[$i]}" -ge "${audio2_start[$(($i+1))]}" ] ; then
#				myecho " [dvd-slideshow] Multiple files found right after one another!"
				## User might add 10 audio files when only 2 are needed
				## to span the video...  check for this:
				## 1.  find next real audio start marker
				## 2. compare length of songs up to that point.
				myindex=$i
				while [ -n "${audio2_start[$(($myindex+1))]}" ] && [ "${audio2_start[$myindex]}" -ge "${audio2_start[$(($myindex+1))]}" ] ; do
					# grab last starting time:
					next_real_audio_start="${audio2_start[$(($myindex+2))]}"
					if [ -z "$next_real_audio_start" ] ; then
						## must be last audio track.  assume run til end
						next_real_audio_start="$end_time"	
					fi
#					myecho " [dvd-slideshow] next audio start=$next_real_audio_start myindex=$myindex"
					myindex=$(( $myindex + 1 ))
				done
				# set first file audio endpoint to the least
				# of the full length of song or the start of the next file:
				# (whichever comes first)
				if [ $next_real_audio_start -lt $(( ${audio2_start[$i]} + $song_length_ms )) ] ; then
					# this song is too long and needs to be cropped
					# set endpoint to starting point of next song
					audio2_end[$i]=$next_real_audio_start 
#					# ignore next audio files until $next_real_audio_start
					skip_next_audio_file=1
#					myecho "[dvd-slideshow] Next audio file not needed"
#					myecho "[dvd-slideshow] Setting audio2_end[$i]=${audio2_end[$i]}"
				else
					# song not long enough... need to add next audio file
					# or buffer with silence at end.
					audio2_end[$i]=$(( ${audio2_start[$i]} + $song_length_ms )) 
					# set second file audio startpoint to end of fist song:
					audio2_start[$(($i+1))]="${audio2_end[$i]}" 
#					myecho "[dvd-slideshow] Concatenating next audio file also"
#					myecho " [dvd-slideshow] Setting audio2_start[$(($i+1))]=${audio2_end[$i]} audio2_end[$i]=${audio2_end[$i]}"
				fi
			fi

			song_end_ms=$(( ${audio2_end[$i]} - ${audio2_start[$i]} ))
			[ "$song_end_ms" -lt 0 ] && song_end_ms=0
			song_end_hms=`hms $song_end_ms`
			song_start_hms="0"  # cannot modify starting point yet...
#			myecho "[dvd-slideshow] song_start_hms=$song_start_hms song_end_hms=$song_end_hms"

			if [ "$song_length_ms" -lt "$song_end_ms" ] ; then
#				myecho "Song length < song_end   `hms $song_length_ms` < `hms $song_end_ms`"
				# video is longer than audio.  need to add silence to end.
				# fade only to the end of song length now, because we may have to add silence:
				sox -v 0.95 "$tmpdir/audio2_$i_padded.wav" -w -s -c 2 -r $audio_sample_rate "$tmpdir/audio2_$i_padded.raw" fade t "$fade_in_hms" "$song_length_hms" "$fade_out_hms"
				thetime_hms=`hms $(( $song_end_ms - $song_length_ms + 1000 ))` #plus 1s so sox actually crops.
				thetime2_hms=`hms $(( $song_end_ms - $song_length_ms ))` 
				myecho "[dvd-slideshow] Adding $thetime2_hms of silence to end of original audio file"
				sox -t raw -s -w -c 2 -r $audio_sample_rate /dev/zero -w -s -c 2 -r $audio_sample_rate "$tmpdir/silence.raw" trim 0 "$thetime_hms"
				cat "$tmpdir/audio2_$i_padded.raw" "$tmpdir/silence.raw" > "$tmpdir/audio.raw" 
				mv "$tmpdir/audio.raw" "$tmpdir/audio2_$i_padded.raw"
				# hopefully there won't be many times where the audio needs to be buffered 
				# at the end, so we'll add one extra step to make the coding easier:
				sox -t raw -s -w -c 2 -r $audio_sample_rate "$tmpdir/audio2_$i_padded.raw" "$tmpdir/audio2_$i_padded.wav"
				rm "$tmpdir"/silence.raw
			fi
			## fade in by default... may change later
			sox -v 0.95 "$tmpdir/audio2_$i_padded.wav" -w -s -c 2 -r $audio_sample_rate "$tmpdir/audio2_$i_padded.raw" fade t "$fade_in_hms" "$song_end_hms" "$fade_out_hms"
		fi
		if [ $i -eq 0 ] && [ "${audio2_start[$i]}" -ne 0 ] ; then
			## buffer beginning with silence:
			thetime_hms=`hms "${audio2_start[$i]}"`
			myecho "[dvd-slideshow] Adding $thetime_hms to beginning of audio file"
			sox -t raw -s -w -c 2 -r $audio_sample_rate /dev/zero -w -s -c 2 -r $audio_sample_rate "$tmpdir/silence.raw" trim 0 "$thetime_hms"
			cat "$tmpdir"/silence.raw "$tmpdir/audio2_$i_padded.raw" > "$tmpdir/audio.raw" 
			mv "$tmpdir/audio.raw" "$tmpdir/audio2_$i_padded.raw"
			rm "$tmpdir"/silence.raw
		fi
		myecho "[dvd-slideshow] This audio plays in slideshow from `hms ${audio2_start[$i]}` to `hms ${audio2_end[$i]}`"
		if [ "$debug" -ge 1 ] ; then
			length=`rawlength "$tmpdir/audio2_$i_padded.raw"`
			myecho "[dvd-slideshow] Actual length of .raw file=`hms $length`"
		fi
		let i=$i+1
		myecho "[dvd-slideshow] ###############"
	done
		
	myecho "[dvd-slideshow] Concatenating all audio files..."
	## cat all the audio files together: 
#	find "$tmpdir" -name audio2_????.raw -print0 | xargs -0 sox -t raw -w -s -c 2 -r $audio_sample_rate - "$tmpdir/audio2.wav"
	cat "$tmpdir"/audio2_????.raw | sox -t raw -w -s -c 2 -r $audio_sample_rate - "$tmpdir/audio2.wav"
	if [ "$debug" -ge 1 ] ; then
		length=`wavlength "$tmpdir/audio2.wav"`
		myecho "[dvd-slideshow] Actual length of .raw file=`hms $length`"
	fi
	## AC3 audio may be more compatible:
	if [ "$ac3" -eq 1 ] && [ "$output_format" != 'flv' ] ; then
		myecho "[dvd-slideshow] Creating ac3 audio..."
		checkforprog ffmpeg
		check_rm "$tmpdir/audio2.ac3"
		ffmpeg -i "$tmpdir/audio2.wav" -vn -ab $audio_bitrate -acodec ac3 -ar $audio_sample_rate -ac 6 "$tmpdir/audio2.ac3" >> "$outdir/$logfile" 2>&1
		if [ $? -ne 0 ] ; then
			## ffmpeg errored
			myecho "[dvd-slideshow] ERROR during ffmpeg execution!"
			myecho "[dvd-slideshow] see $outdir/$logfile for details"
			cleanup; exit 1
		fi
	else
		## toolame is way faster! (3x in my test)
		it=`which toolame`
		if [ -n "$it" ] ; then
			toolame_version=`toolame -h | head -n 4 | grep version | awk '{ print $3 }'`
			myecho "[dvd-slideshow] Creating mp2 audio using toolame $toolame_version..."
			if [ "$toolame_version" == '0.2m' ] ; then
				toolame -s $audio_sample_rate -b $audio_bitrate "$tmpdir/audio2.wav" "$tmpdir/audio2.mp2" >> "$outdir"/"$logfile" 2>&1
			else
				if [ "$vcd" -eq 1 ] || [ "$svcd" -eq 1 ] ; then
				toolame -s 44.1 -b $audio_bitrate "$tmpdir/audio2.wav" "$tmpdir/audio2.mp2">> "$outdir"/"$logfile" 2>&1
				else
				toolame -s 48 -b $audio_bitrate "$tmpdir/audio2.wav" "$tmpdir/audio2.mp2" >> "$outdir"/"$logfile" 2>&1
				fi
			fi
		else
			myecho "[dvd-slideshow] Creating mp2 audio using mp2enc"
			mp2enc -v $verbosity -b $audio_bitrate -r $audio_sample_rate -s -o "$tmpdir/audio2.mp2" < "$tmpdir/audio2.wav"
		fi
	fi
fi


## check to make sure the output files exist before running mplex:
if [ ! -f "$tmpdir/video.$video_suffix" ] ; then
	myecho "[dvd-slideshow] ERROR: no output .$video_suffix file found!"
	myecho "[dvd-slideshow] This usually happens when ffmpeg screws up something"
	myecho "[dvd-slideshow] or one image is messed up and the resulting video can't be created"
fi
	
myecho '[dvd-slideshow]############################################################'
myecho '[dvd-slideshow] Multiplexing audio and video...'
logecho '[dvd-slideshow] Some sequence marker warnings here are normal'

## now multiplex the audio and video:
## -M option is important:  it generates a "single" output file instead of "single-segement" ones
## if you don't use -M, the dvdauthor command will fail!
## total mplex bitrate = 128kBit audio + 1500 kBit video + a little overhead
verbosity=0
if [ "$output_format" == 'flv' ] ; then  # only one audio track for .flv, .swf, and .mp4, etc...
	myecho "[dvd-slideshow] Adding audio to .flv file"
	ffmpeg -y -i "$tmpdir/audio1.wav" -i "$tmpdir/video.flv" -vcodec copy -f flv -ar 22050 -ab 48 -ac 1 "$tmpdir/video1.flv" >> "$outdir"/"$logfile" 2>&1 
	mv "$tmpdir/video1.flv" "$outdir"/"$slideshow_name".flv
	myecho "[dvd-slideshow] Generating video thumbnail..."
	ffmpeg -y -i "$outdir"/"$slideshow_name".flv -f mjpeg -t 0.001 "$outdir"/"$slideshow_name".jpg >> "$outdir"/"$logfile" 2>&1
	if [ -f "/usr/bin/flvtool2" ] ; then
		myecho "[dvd-slideshow] Running flvtool2 -U $slideshow_name".flv
		/usr/bin/flvtool2 -U "$outdir"/"$slideshow_name".flv
	fi
elif [ "$output_format" == 'swf' ] ; then
	myecho "[dvd-slideshow] Adding audio to .swf file"
	ffmpeg -y -i "$tmpdir/audio1.wav" -i "$tmpdir/video.swf" -vcodec copy -f swf -ar 22050 -ab 48 -ac 1 "$tmpdir/video1.swf" >> "$outdir"/"$logfile" 2>&1 
	mv "$tmpdir/video1.swf" "$outdir"/"$slideshow_name".swf
	myecho "[dvd-slideshow] Generating video thumbnail..."
	ffmpeg -y -i "$outdir"/"$slideshow_name".swf -f mjpeg -t 0.001 "$outdir"/"$slideshow_name".jpg >> "$outdir"/"$logfile" 2>&1
elif [ "$output_format" == 'mp4' ] ; then   # NOT TESTED YET
	myecho "[dvd-slideshow] Exporting .mp4 file"
#	ffmpeg -f yuv4mpegpipe -i "$tmpdir"/$yuvfifo -r $framerate -an -aspect $aspect_ratio -s "$dvd_width"x"$dvd_height" -y -f mp4 -vcodec mpeg4 "$tmpdir/video.mp4" >> "$outdir/$logfile" 2>&1
elif [ "$output_format" == 'mp4_ipod' ] ; then   # NOT TESTED YET
	myecho "[dvd-slideshow] Exporting ipod .mp4 file"
#	ffmpeg -f yuv4mpegpipe -i "$tmpdir"/$yuvfifo -target $ffmpeg_target -r $framerate -an -aspect $aspect_ratio -s "$dvd_width"x"$dvd_height" -y -f mp4 -vcodec mpeg4 -maxrate 1000 -b 700 -qmin 3 -qmax 5 -bufsize 4096 -g 300 "$tmpdir/video.mov" >> "$outdir/$logfile" 2>&1
elif [ -n "${audio_2[0]}" ] && [ "$vcd" -eq 0 -a "$svcd" -eq 0 ] ; then
	## two audio tracks!
	echo "[dvd-slidehsow] two audio tracks found"
	if [ "$ac3" -eq 1 ] ; then
		mplex -V -v $verbosity $ignore_seq_end -f $mplex_type -o "$outdir"/"$slideshow_name".vob "$tmpdir/video.mpg" "$tmpdir"/audio1.ac3 "$tmpdir"/audio2.ac3 2>> "$outdir/$logfile"
	else
		mplex -V -v $verbosity $ignore_seq_end -f $mplex_type -o "$outdir"/"$slideshow_name".vob "$tmpdir/video.mpg" "$tmpdir"/audio1.mp2 "$tmpdir"/audio2.mp2 2>> "$outdir/$logfile"
	fi
else  # default mpeg2 video for dvd/vcd
	if [ "$ac3" -eq 1 ] ; then
		if [ ! -f "$tmpdir/audio1.ac3" ] ; then
			myecho "[dvd-slideshow] ERROR: no output .ac3 file found!"
			myecho "[dvd-slideshow] Must be some error with your input audio"
			myecho "[dvd-slideshow] or the ac3 encoder"
		fi
		mplex -V -v $verbosity $ignore_seq_end -f $mplex_type -o "$outdir"/"$slideshow_name".vob "$tmpdir/video.mpg" "$tmpdir"/audio1.ac3 2>> "$outdir/$logfile"
	else
		if [ ! -f "$tmpdir/audio1.mp2" ] ; then
			myecho "[dvd-slideshow] ERROR: no output .mp2 file found!"
			myecho "[dvd-slideshow] Must be some error with your input audio"
			myecho "[dvd-slideshow] or the mp2 audio encoder"
		fi
		mplex -V -v $verbosity $ignore_seq_end -f $mplex_type -o "$outdir"/"$slideshow_name".vob "$tmpdir/video.mpg" "$tmpdir"/audio1.mp2  2>> "$outdir/$logfile"
	fi
	if [ $? -ne 0 ] ; then
		## mplex errored
		myecho "[dvd-slideshow] ERROR during mplex execution!"
		myecho "[dvd-slideshow] see $outdir/$logfile for details"
		cleanup; exit 1
	fi
fi

myecho "[dvd-slideshow]############################################################"

verbosity=0
## now run spumux only if the png was generated:
if [ "$vcd" -eq 1 ] || [ "$svcd" -eq 1 ] ; then
	myecho "[dvd-slideshow] VCD mode: not running spumux"
elif [ "$output_format" == "flv" ] || [ "$output_format" == "mp4" ] || [ "$output_format" == 'swf' ] ; then
	myecho "[dvd-slideshow] FLV mode: not running spumux"
elif [ "$subtitle_type" != 'render' ] ; then   # dvd
	if [ "$has_subtitles" -eq 1 ] ; then
		spumux -m dvd -v $verbosity -s 0 -P "$tmpdir"/"$slideshow_name".spumux < "$outdir"/"$slideshow_name".vob > "$outdir/tmp.vob"  2>> "$outdir/$logfile"
		if [ $? -ne 0 ] ; then
			## spumux errored
			myecho "[dvd-slideshow] ERROR during spumux execution!"
			myecho "[dvd-slideshow] see $outdir/$logfile for details"
			cleanup; exit 1
		fi
		mv "$outdir/tmp.vob" "$outdir"/"$slideshow_name".vob
	fi
	if [ "$has_subtitles2" -eq 1 ] ; then
		spumux -m dvd -v $verbosity -s 1 -P "$tmpdir"/"$slideshow_name".spumux2 < "$outdir"/"$slideshow_name".vob > "$outdir/tmp.vob"  2>> "$outdir/$logfile"
		if [ $? -ne 0 ] ; then
			## spumux errored
			myecho "[dvd-slideshow] ERROR during spumux execution!"
			myecho "[dvd-slideshow] see $outdir/$logfile for details"
			cleanup; exit 1
		fi
		mv "$outdir/tmp.vob" "$outdir"/"$slideshow_name".vob
	fi
fi

## build the chapters string for passing to dvdauthor:
myecho "[dvd-slideshow] total chapters=${#chaps[@]}"
total_chapters="${#chaps[@]}"
new_total_chapters="$total_chapters"
factor=1  ;  mod=1
while [ $new_total_chapters -gt 99 ] ;  ## 99 chapters max
do
	factor=$(( 2 * $factor ))
	new_total_chapters=$(( $new_total_chapters / 2 ))	
done
if [ "$new_total_chapters" -ne "${#chaps[@]}" ] ; then
	myecho "[dvd-slideshow] reduced total chapter markers to $new_total_chapters"
fi
a=0 ; b=0
for chap in "${chaps[@]}"; do
	if [ $a == 0 ] ; then  # no comma for first chapter
		## first chapter should always be at 0 time!
		chaps_string="0"
		chapter_thumbs[$b]="${thumbs[$a]}"
		b=$(( $b + 1 ))
	else
		# only do every $factor chapters
		if [ "$mod" -eq "$factor" ] ; then
			chaps_string="$chaps_string,$chap"
			chapter_thumbs[$b]="${thumbs[$a]}"
			b=$(( $b + 1 ))
			mod=1
		else
			mod=$(( $mod + 1 ))
		fi
	fi
	a=$(( $a + 1 ))
done

if [ "$write_chaps" -eq 1 ] ; then
	# write out chapters to file:
	echo "$chaps_string" > "$outdir"/"${slideshow_name}.chap"
fi

myecho "[dvd-slideshow] chapter markers at $chaps_string"
myecho "[dvd-slideshow]############################################################"

if [ "$vcd" -eq 1 ] || [ "$svcd" -eq 1 ] ; then
	mv "$outdir"/"$slideshow_name".vob "$outdir"/"$slideshow_name".mpg
	echo "$outdir"/"$slideshow_name".mpg > "$outdir"/"$slideshow_name".xml
else
	echo '		<vob chapters="'$chaps_string'" file="'$outdir/$slideshow_name.vob'"  />' > "$outdir/$slideshow_name".xml
fi

cleanup

## now, just cleanup the logfile a little bit:
sed -e '/ bytes of data written[[:cntrl:]]INFO/d' "$outdir"/"$logfile" > "$outdir"/tmp.txt
sed -e '/ [[:cntrl:]]size= /d' "$outdir"/"tmp.txt" > "$outdir"/"$logfile"
\rm "$outdir"/tmp.txt
#mv "$outdir"/tmp.txt "$outdir"/"$logfile"

echo "[dvd-slideshow] More extensive logfile output is at:"
echo "[dvd-slideshow] $outdir/$logfile"
myecho "[dvd-slideshow] Done!"
echo ""
echo "[dvd-slideshow] use one of the following comands to view your output:"
echo "[dvd-slideshow] xine -g -u 0 \"$outdir/$slideshow_name.vob\""
echo "[dvd-slideshow] mplayer -sid 0 \"$outdir/$slideshow_name.vob\""
myecho
exit 0
